# 결제 요청, 인증, 승인, 멱등성

단순하게 아티클 읽고 요약한 정도의 글이다. <br>

# 1. 왜 결제 요청 과정에 인증과 승인 과정이 추가되는가?
## 1.1 결체 전체 과정

1. **결제 요청**
- 구매자는 토스 페이먼츠 결제창으로 클라이언트에서 결제하게 된다.

<br>

2. **결제 요청에 대한 인증**
- 결제를 요청한 이후, 인증을 해야 한다. 
- 신용 카드의 경우 해당 카드 회사에게 <br> **신용카드 정보가 올바르고, 거래가 유효한지, 결제를 허용해도 되는지 확인한다.** <br> 카드 번호나 CVC, 만료일 등의 정보로 인증한다.
- 이를 통해 카드회사는 구매자 정보와 가맹점을 보호한다. 부정거래나 사기 등을 방지할 수 있음
- 인증 이후 성공 URL을 반환받는다. ex) `https://store.com/success?paymentKey={PAYMENT_KEY}&orderld={0RDER_ID}&amount=100`

<br>

3. **결제 승인**

이제 유저 입장에선 결제가 완료된 것처럼 보이게 된다. <br>
하지만 개발자 입장에서는 요청만 마친 상태이다. <br>
**인증 이후 받게된 성공 URL을 이용해, 인증된 결제를 카드사에 승인해달라고 요청해야 한다.** <br>
승인 과정이 성공해야 실제로 카드사나 은행이 결제 금액을 구매자에게 청구하기 때문에, 실제로 결제가 마무리 되는 단계이다. <br>

<br>

## 1.2 결제 요청과 승인을 따로 진행하는 이유

한번에 처리한다면, 결제 요청 이후 승인 결과를 받기까지 얼마나 걸릴지 알 수 없다. <br>
때문에, 승인 결과를 보여주려면 웹훅을 연동해야 하는데, 만약 유저가 창을 닫아버린다거나, 우리 서버에 트래픽이 몰려 승인 완료 결과를 처리하지 못 하는 상황이 생기는 경우 문제가 생긴다. <br>
웹훅이 여러번 재전송 된다고 하더라도 서버 상태가 안 좋다면 우리 서버에서는 결제 실패로 남지만, PG 서버에서는 결제 완료 상태로 남아버려서 데이터가 어긋날 수도 있다. <br>
이렇게 요청-승인을 한번에 처리하면 정합성 보장을 위해 처리해야할 과정이 오히려 많다. <br> <br>

그래서 토스페이먼츠는 결제 요청과 승인을 따로 만드는 방식으로 데이터 정합정을 보장했다. <br>
요청과 승인을 따로 두면, 정합성에 문제가 생길 가능성은 거의 없다. <br>
물론 요청 이후 우리 서버가 승인을 요청하는 과정이 추가되겠지만, 성공 리다이렉트 URL을 보내주므로 서버에서 계속 기다릴 필요가 없다. 토스 페이먼츠 서버에서 리다이렉트 URL로 돌려준 정보를 통해 승인을 요청하면 되기 때문이다. <br>   <br>

## 1.3 결제 정보 검증하기
### 결제 요청 전에 결제할 데이터를 저장한다
1. 결제 요청 전에 구매자의 결제 정보를 저장한다. 
2. **주문서 페이지의** 적립금이나 쿠폰이 적용된 최종 결제 금액을 서버에 저장한다. <br> (이때 서버에서 실제로 그런 쿠폰이나 적립금이 있는지 확인하면 될듯??)
3. 저장 이후 결제를 요청한다.

- 이런 과정이 없으면 요청과 승인 사이에 장난질을 칠 수 있다.

### 결제 승인 전에 데이터를 검증한다.

요청-승인 이후 리다이렉션 된 정보와 서버에 저장된 정보를 비교한다. <br> 요청과 승인 사이에 악의적으로 적립금 등으로 장난칠 수 있다.
1. 결제 인증 완료 이후 성공 리다이렉트 URL에 들어온 값을 확인
2. 주문 ID로 결제 요청 전에 저장해 둔 정보와 비교 (적립금, 쿠폰 사용 가능 여부나 금액 등등)
3. 문제 없다면 승인을 요청한다!

### 요약

- 인증은 카드사가 진행
- 인증된 결제를 카드사에 승인해 달라고 부탁
- 승인이 성공해야 구매자에게 상품이나 서비스 제공 가능
- 결제 요청과 승인을 따로 하는 이유는 데이터 정합성을 보장 때문. 
- 토스페이먼츠 서버에서 리다이렉트 URL로 돌려준 정보를 가맹점에서 직접 받아 그 정보로 승인을 요청
- 그 사이의 장난질은 서버에 요청시 데이터를 저장해서 대조

# 2. 멱등성 API
**멱등하다는 것은 첫 수행 이후, 여러 차례 다시 적용되어도 결과를 변경시키지 않는 작업 또는 기능의 속성을 가리킨다.** <br> 
예를 들어 1에 계속 1을 곱해도 1이다. <br>
**절댓값 함수는 여러번 수행해도 같은 답이 돌아온다. -> 멱등함수** <br>

## 1. HTTP 메서드 멱등성

- GET, PUT처럼 리소스를 조회하거나 대체하는 메서드는 멱등하다.
- PUT은 여러 번 호출해도 매번 같은 리소스를 업데이트한다.
- 안정성이 보장된 메서드는 리소스를 변경하지 않는다. ex) GET, HEAD, OPTIONS
- **안정성이 보장된 메서드는 멱등성을 보장하지만, 멱등성을 지닌 메서드가 안정성을 보장하지는 않는다.** ex) PUT, DELETE는 멱등하지만 리소스에 변화를 준다.

## 2. 멱등성 API
토스페이먼츠에서는 멱등성을 가진 API를 지원하기 위해, 요청시 헤더에 멱등키를 포함할 수 있게 지원해준다. <br>
이미 저장된 멱등키로 요청이 온다면 막아주는 것이다. <br>

```json
Idempotency-Key: {IDEMPOTENCY_KEY}
```

```js
curl --request POST \
  --url https://api.tosspayments.com/v1/payments/5zJ4xY7m0kODnyRp/cancel \
  --header 'Authorization: Basic dGVzdF9za196WExrS0V5cE5BcldtbzUwblgzbG1lYXhZRzVSOg==' \
  --header 'Content-Type: application/json' \
  --header 'Idempotency-Key: SAAABPQbcqjEXiDL' \
  --data '{"cancelReason":"고객 변심"}'
```

<br>


멱등한 API는 멱등키를 무조건 포함하도록 해서 DB에 저장한다. <br>
멱등키가 포함된 요청이 오면 DB를 조사한다. <br>
멱등키의 유효기간을 정해 놓고, 동일한 멱등키가 들어온다면 이미 저장된 데이터를 반환해준다. <br>
기록이 없는 경우에만 처리한다. <br>
나름 연산량이 많은 연산이라면 일종의 얼리 리턴이니까 성능적으로도 좋다. <br> <br>

토스페이먼츠 서버에서는 멱등한 요청인지 식별하기 위해 API 요청 헤더로 보낸 멱등키와 API 키, API 주소, HTTP 메서드 조합을 확인한다.  <br>
따라서 API 키, API 주소, HTTP 메서드가 다르다면 같은 멱등키를 사용해도 새로운 요청으로 받아들인다. <br>

[토페 멱등키 문서](https://docs.tosspayments.com/guides/using-api/idempotency-key?utm_source=tosspayments&utm_medium=velog)

### 에러 시나리오

IETF 명세에 따라 세가지 에러에 대해 대응해야 한다
1. `400 Bad Request` : 멱등해야 하는 API 요청에 멱등키가 누락되거나, 형식이 잘못됨
2. `409 Conflict` : 이전 요청 처리가 아직 진행중인데, 같은 멱등키로 새로운 요청이 옴
3. `422 Unprocessable Entity` : 요청 자체는 다른데 (payload로 확인) 같은 멱등키를 활용함

`409 Conflict`, `422 Unprocessable Entity`이 다른 요청인데 같은 멱등키를 사용한 상황이다. <br>

## Reference
- [결제 요청, 인증, 승인… 이게 다 뭔가요?](https://velog.io/@tosspayments/%EA%B2%B0%EC%A0%9C-%EC%9A%94%EC%B2%AD-%EC%9D%B8%EC%A6%9D-%EC%8A%B9%EC%9D%B8-%EC%9D%B4%EA%B2%8C-%EB%8B%A4-%EB%AD%94%EA%B0%80%EC%9A%94)
- [멱등성이 뭔가요?](https://velog.io/@tosspayments/%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%B4-%EB%AD%94%EA%B0%80%EC%9A%94)
