# 함수 컴포넌트로 갈아타는 이유

## 1. 클래스형 컴포넌트 프로젝트
내가 참여중인 창업팀은 대부분의 컴포넌트가 클래스형으로 작성되어 있다. <Br>
지금으로 부터 약 3년 전 부터 조금씩 시작해온 프로젝트로, 나는 작년에 합류하였다.  <br>
아마 시작했을 당시엔 클래스형 컴포넌트가 대새였을 것 같다. 그러다보니 자연스럽게 대부분의 컴포넌트가 클래스형으로 작성된 것이다. <br> <br>

하지만 내가 합류할 때 쯤엔 대세가 함수 컴포넌트로 바뀌어 있었다. <br>
리액트 16.8 Hooks를 쓸 수 있게 되기 전엔, 함수 컴포넌트에서 state나 라이프사이클을 사용하기가 어려웠다. <Br>
클라이언트에 있어 랜더링 라이프사이클 기능을 이용할 수 있다는 것은 어마어마한 장점이기 때문에 클래스형 컴포넌트가 선호되었던 것 같다. (state는 굳이 말할 필요도 없이 강력하다.) <Br>
하지만, 우리는 리액트 17 버전을 사용중이고, 리액트 16.8 부터 Hooks를 사용할 수 있게 된 이후엔 Hooks로 state와 라이프사이클 기능을 이용할 수 있기 때문에, 이제 함수 컴포넌트라는 선택지도 사용할 수 있게 되었다. <br>
신난다! 즐겁다! <Br>
나는 항상 함수 컴포넌트로 갈아타고 싶었다. <br> 
함수 컴포넌트로 갈아탔을 때의 장점은 다양하지만, 나는 딱 하나의 이유 때문에 클래스형 컴포넌트의 사용이 꺼려졌었다. <br>

대략적인 기능이 세팅되고, 모든 팀원이 납득한 이후엔 각자 영역을 맡아 리팩토링을 시작하였다. <Br>

## 2. 함수 컴포넌트를 사용하면 뭐가 좋을까
그래서, "사용할 수 있게" 되었으니 신나서 갈아타자는 이유가 뭘까? <br>

일단 함수 컴포넌트로 갈아탔을 때의 장점은 아래와 같다.
1. 다양한 훅이 제공해주는 기능들을 편하게 사용할 수 있다. (+ 리덕스 사용이 훨씬 편해진다, 커스텀 훅 등)
2. 코드 자체가 줄어든다 render함수, constructor 등등
3. 자료가 많다!! <br> 이제 클래스형은 자료도 별로 없다.. 최신 자료들 대부분이 함수 컴포넌트로 작성되어 있다. <Br> -> 내가 처음 공부할 때도 클래스형으로 작성된 책이 아예 출고되지 않아, 밸로퍼트의 리액트 구판을 찾아 여기저기 발품을 팔았다. 

이 3가지 장점 외에도 내가 가장 싫어하는 단점이 있었는데 <br>
### this가 mutable 하기 때문에 리랜더링될 때 값이 고정되지 않는다는 문제가 있다. 


## 3. 랜더링 값이 고정되지 않는 문제

리액트의 아버지 Dan Abramov가 쓴 유명한 아티클에서 예시를 가져왔다. [링크](https://overreacted.io/ko/how-are-function-components-different-from-classes/) <br>

클래스형 컴포넌트로 작성된 아래와 같은 코드가 있다.

```javascript
class ProfilePage extends React.Component {
  showMessage = () => {
    alert('Followed ' + this.props.user);
  };

  handleClick = () => {
    setTimeout(this.showMessage, 3000);
  };

  render() {
    return <button onClick={this.handleClick}>Follow</button>;
  }
}
```

아래와 같은 화면이 그려지는데, follow를 누르면 3초 뒤, `this.props.user`를 follow했다는 메시지가 나오는 예제이다. <br>
아마 실제로 유저를 팔로우 하는 과정을 극단적으로 느리게 재현한 것 같다. <br>

![Alt text](image.png)


이런 상황에서 follow를 누르게 되면 setTimeout으로 인해 3초를 기다리게 된다. <Br>
문제는 이 상황에서 위쪽 빨간 동그라미를 눌러 보고 있는 유저를 다른 유저로 바꿀 때 발생한다. <br>

[그림]

그림과 같이 우리는 Dan을 팔로우 했으나, 소피아가 팔로우 되는 것이다! <br>
문제는 this가 변하기 때문이다. 리랜더링시 this.props의 user가 바뀌기 때문에, 표시되는 유저도 바뀐 것이다. <Br>
실제 상황이라면 굉장히 끔찍한 일이다. <br>
내가 좋아요를 누르지 않은 글에 좋아요가 눌릴 수도 있고, <br>
내가 삭제한 글 대신 다른 글이 삭제될 수도 있다. <Br>
혹은 애초에 로직이 작동 안 할 수도 있다. <Br>
이렇게만 말하면 작은 문제 같아 보이는데, 유저의 돈이 걸린 일이라면 결코 사소한 문제가 아니게 된다. <br> <br>

물론 클래스형 컴포넌트를 사용하면서도 이 문제를 해결할 수 있다.
1. 미리 데이터를 다른 곳에 저장해둔 다음 활용하거나
2. 클로저를 이용할 수도 있다.

하지만 1번 방법은, 조금만 로직이 복잡해져도 고려해야하는 부분이 너무나도 많아지고, <Br>
2번 방법을 위해 render 메서드 안에 함수를 선언한다면, 사실 클래스형을 쓸 필요가 없는 것이다. <br>

## 4. 함수 컴포넌트라면 바로 해결된다.
함수 컴포넌트는 render 될 때의 값들을 유지한다! <br>
아래와 같이 컴포넌트를 함수로 작성하면 모든 문제가 해결된다.

```javascript
function ProfilePage({ user }) {
  const showMessage = () => {
    alert('Followed ' + props.user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return (
    <button onClick={handleClick}>Follow</button>
  );
}
```

이렇게 작성만 해주면 render될 때의 값들이 유지되므로 아무리 빠르게 화면을 바꾸어도! 아무런 문제 없이 작동한다. <br>

이런 문제가 너무 싫어서 항상 함수 컴포넌트로바꾸는 것을 원했었다. <Br>
덕분에 정말 다양한 장점을 누릴 수 있게 되었다.

1. 리랜더링 되더라도, 값들이 변하지 않는다! 
2. 다양한 훅을 사용하면서 개발이 편해진다. 리덕스 사용도 편해지고, 커스텀 훅 사용이 가능하다. 
3. 코드를 작성하기도 편해진다. render함수, constructor 등등을 만들지 않아도 됨. 
4. 참고할 만한 자료가 정말 많다 <br> 최신 자료들이나 도서들의 대부분은 함수 컴포넌트로 작성되어 있다. 



## Reference
- https://overreacted.io/ko/how-are-function-components-different-from-classes/
