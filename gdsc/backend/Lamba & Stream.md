# 1. Lambda Expression
## 1.1 람다 도입 배경
람다의 도입으로 **자바는 더 이상 예전의 자바가 아니게 되었다고 한다.** <br>
자바는 람다식의 도입으로 인해, **객체지향언어인 동시에 함수형 언어가 되었다.** 람다식은 왜 도입되었을까?

1. 빅데이터의 중요성 증대
2. 병렬화 기술의 중요성 증대
3. 자바 8에서는 병렬화를 위한 **컬렉션을 강화**함.
4. 컬렉션을 더 효율적으로 사용하기 위해 **스트림이 강화**됨.
5. 이 스트림을 더 효율적으로 사용하기 위해 **함수형 프로그래밍이 도입**되었고, **함수형 프로그래밍을 위해 람다**가 도입됨.
7. 람다를 위해 인터페이스의 변화가 수반됨. 이를 함수형 인터페이스라고 부름


람다식은 위와 같은 배경으로 등장하였다. 

## 1.2 람?다
**람다식은 메서드를 <U>하나의 식으로</U> 표현한 것이다.** **람다란 코드 블록이다.** <br> 람다식을 적용하면 메서드의 **이름과 반환값이 없어진다.** 그래서 람다를 익명함수라고도 부르는 것이다. 람다는 아래와 같은 구조를 갖는다.

```java
(인자 목록) -> { 로직 }
```

그 예시는 아래와 같다.
```java
int max(int a, int b) {
  return a > b ? a : b;
}
```
위와 같은 메서드를 람다를 통해 아래와 같이 나타낼 수가 있다.
```java
(int a, int b) -> {
  return a > b ? a : n;
}
```
로직이 한 줄이고, 반환값이 있는 메서드이므로 아래와 같이 return과 중괄호를 한번에 없앨 수 있다.
```java
(int a, int b) ->  a > b ? a: n
```
return을 남기는 경우 중괄호를 없앨 수 없다.
<br>
연산결과가 자동으로 반환값이 된다. 문장이 아니라, 식이므로, 끝에 `;`이 붙지 않는다. <br>
여기서 또 있다. 매개변수 타입이 추론 가능하다면, 아래와 같은 생략도 가능하다.
```java
(a, b) ->  a > b ? a: n
```

매개변수가 하나이면 이런 것도 가능하다
```java
(a) -> a * a

a -> a * a
```
배리에이션을 자세히 아는게 중요해 보이지는 않는다. 어차피 필요할 때 구글링 하거나, 인텔리제이에서 알아서 도와줄 것이기 때문이다. 쓰다 보면 손에 익을 것이다. <br> <br>

기존의 메서드는 클래스에 포함되어야 하기 때문에, 여러 귀찮은 제약들이 많았다. 정의하려머느 클래스도 만들어야 하고, static이 아닌 경우 객체도 만들어야 호출 가능하고, 정말 귀찮았다! 이런 귀찮음을 해결해 주는 것이 바로 람다식! <br> 게다가, 람다식은 매개변수로 전달 되는 것도 가능하고, 결과로 반환될 수도 있다. 이로인해 마치, **메서드를 변수처럼 다루는 것이 가능해진 것이다.**

## 1.3 함수형 인터페이스
람다식은 내부적으로 어떻게 작동하는 것일까? 기존의 탄탄한 자바 세계에 큰 영향을 미치지 않고, 어떻게 람다식을 도입했을까? <br>

람다식은 일종의 메서드처럼 표현했고, 나도 그렇게 생각했다. 람다식의 실체는 메서드가 아닌, **익명 클래스의 객체이다.**

```java
(int a, int b) -> a > b ? a : b;
```
위와 같은 람다식은 실제로는 아래와 같다.
```java
new Objcet() {
  int max(int a, int b) {
    return a > b ? a : b;
  }
}
```
max는 그냥 붙인 이름이다. 람다식은 익명 클래스의 객체이다. <br>
#### 직접 함수형 인터페이스 선언해보겠다!
인터페이스에 단 하나의 추상 메서드만을 갖도록 만들면 된다. 인터페이스 위에 `@FunctionalInterface`를 붙이면, 올바르게 함수형 인터페이스를 정의하였는지 체크해준다.
```java
@FunctionalInterface
public interface TestFunctionalInterface {
    public abstract int max(int a, int b);
}
```
**람다식은 익명 클래스의 객체**이므로, 아래 두 표현은 같은 표현이다.
```java
MyFunctionalInterface test = new MyFunctionalInterface() {
  @Override
  public int max(int a, int b) {
    return a > b ? a : b;
  }
};
MyFunctionalInterface test1 = (int a, int b) -> a > b ? a : b;
```

람다는 이런 식으로 만들어졌다. 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다. 이렇게 자바는 기존의 것들에 최대한 적은 영향을 주면서 람다식을 구현해냈다. <br> <br>

