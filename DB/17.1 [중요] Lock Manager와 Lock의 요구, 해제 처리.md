# 17.1 Two-Phase lock, 직렬 가능성, 복구 가능성
### 충돌과 `충돌 동등`
두 액션이 동일한 데이터 객체를 접근하고, 그들 중 하나의 액션이 `WRITE`라면, 두 액션은 충돌한다. <Br>
스케줄의 결과는 충돌 연산들의 순서에만 종속된다. <Br>

충돌하지 않는 연산의 쌍은 서로 교환해도 된다. <br>

충돌 동등이란 무엇일까? <Br>

1. 동일한 트랜잭션들의 동일한 연산으로 이루어지고,
2. 두 완료된 트랜잭션의 충돌 연산이 두 스케줄에서 동일한 순서로 나타난다면

**두 스케줄은 충돌 동등(conflict equivalent)이라고 한다.** <Br>

두 스케줄이 충돌 동등하다면, 데이터베이스에 동일한 영향을 끼치게 된다. <br>

스케줄이 직렬 스케줄과 충돌 동등이면, 충돌 직렬가능이라고 한다. <Br>

## 엄격한 락
모든 2PL은 충돌 직렬 가능 스케줄만을 허용한다. <Br>
어떤 스케줄에서 트랜잭션 T가 `WRITE`한 값이 T가 철회되거나 완료될 때까지 다른 트랜잭션들에 의해 읽기 또는 쓰기가 되지 않는다면 그 스케줄은 `엄격`하다고 한다. <Br>
Strict 2PL은 트랜잭션이 끝날 때 락을 반환한다. <Br>
**엄격한 스케줄은 복구 가능하고, 연쇄 철회를 요구하지 않고, 트랜잭션들의 액션들은 수정된 객체의 원래 값을 재 저장함으로써 undo될 수 있다.** <Br>
트랜잭션이 놔줄 때까지, 다른 어떤 트랜잭션도 이 객체를 보거나 쓸 수 없기 때문에 가능하다. (또 끝날때 되서야 놔주니까..) <br>

# 17.2 Lock Manager
DBMS가 트랜잭션들에게 준 잠금은 Lock Manager가 기록하고 관리한다. 잠금 관리기는 **잠금 테이블(lock table)을 가지고 있는데, 이 테이블은 데이터 객체를 key로 갖는 hash table이다** <br>

잠금 테이블의 데이터 객체 엔트리는 아래와 같은 정보들을 포함하고 있다.

1. 데이터 객체에 대해 Lock을 소유하고 있는 트랜잭션의 갯수
2. Lock의 종류 (Shared, Exclusive)
3. Lock 요구 큐를 가리키는 포인터


그리고 트랜잭션 정보를 저장하는 **트랜잭션 테이블(transaction table)을 가지고 있다.** 그리고 이 안에 트랜잭션이 소유하고 있는 잠금들의 리스트를 가리키는 포인터를 포함하고 있다. <br>

이 리스트는 트랜잭션이 동일한 잠금을 두 번 요구하는지를 확인하기 위해, 트랜잭션의 잠금 요구 전에 검사된다. <Br>

## 17.2.1 잠금 요구와 잠금 해제 요구 구현
Strict 2PL 프로토콜에 따르면 어떤 트랜잭션이 `READ`나 `WRITE`를 하기 전엔, Shared Lock이나, Exclusive Lock을 얻어야 한다. <br>
그리고 트랜잭션이 끝날 때까지 Lock을 소유하고 있어야 한다. <Br>
**트랜잭션은 어떤 객체의 Lock을 필요로 할 때 Lock Manager에게 Lock을 요구한다.** <Br>

잠금이 요구되는 3가지 상황을 살펴보자.

### 1. Shared Lock이 요구되는 경우 :star:
1. Shared Lock이 요구됨
2. 해당 데이터 객체에 대한 Lock 요구 큐가 비어있음
3. 데이터 객체가 Exclusive Lock 모드로 잠금 되어 있지 않음 

위 3가지 조건이 만족되는 경우 Lock Manager는 Shared Lock을 허락해준다. <br>
그리고 해당 객체 데이터에 대한 Lock Table Entry를 갱신하는데, <br>
객체가 Shared Lock으로 잠금 되어있고, Lock을 소유중인 트랜잭션의 갯수를 1만큼 증가 시킨다. <br>


### 2. Exclusive Lock이 요구되는 경우 :star:
1. Exclusive Lock이 요구됨
2. 해당 데이터 객체에 대한 Lock을 어떤 트랜잭션도 소유하고 있지 않음 (요구 Queue가 비어있다는 표현과 동치)

위 두가지 조건을 만족하는 경우, Lock Manager는 Exclusive Lock을 허용하고 Lock Table Entry를 갱신한다.

### 3. else -> 위 두 조건들이 모두 만족되지 않는 경우 :star:
Lock은 즉시 허용되지 않고, 해당 객체에 대한 Lock 요구 큐에 요청이 추가된다. <br>
**그리고 해당 Lock을 교수한 트랜잭션은 실행이 정지된다.**

<br>


## 17.2.2 Lock 반환과 새로운 Lock 요청 처리 
앞서 3가지 Lock 요구 상황을 살펴보았다. <Br>
어떤 트랜잭션이 철회 또는 완료될 때 트랜잭션이 가진 모든 Lock이 해제되는데, 객체에 Lock이 해제될 때 Lock Manager는 해당 객체에 대한 Lock Table Entry를 갱신하고, 해당 객체에 대한 큐의 헤드에 있는 Lock 요구를 확인한다. <Br>
확인한 요구가 허용된다면, 요구를 한 트랜잭션은 드디어! 마참내! 대기 상태에서 빠져 나와 Lock을 획득하게 되는 것이다. <br>

만약, 이 객체에 대한 다수의 Shared Lock 요청이 큐의 앞 부분에 있다면, 이 모든 요청들은 함께 허용될 수도 있따. <BR>

만약 현재 객체가 Shared Lock이 걸린 상태인데, Exclusive Lock이 하나 요구된다면 당연히 큐에 저장될 것이다. 이때 Shared Lock 하나가 더 요구되는 경우, 허용해주지 않고 큐에 저장한다. <Br>
그 이유는 Exclusive Lock을 요청한 트랜잭션이 starvation을 겪는 것을 방지하기 위해서이다.

### 17.2.3 Lock과 Lock 해제 원자성
Lock과 Lock 해제 연산은 원자적이여야 한다. <br> 
Lock Manager 코드에 대한 다수의 인스턴스가 동시에 수행될 떄, 위 연산들의 원자성을 보장하기 위해 **Lock Table의 접근은 세마포어와 같은 운영체제의 동기화 메커니즘을 사용해야 한다.** <Br>

요구의 허용 검사, 잠금 테이블 갱신 등의 잠금 요구 액션들 전체가 원자적 연산으로서 구현되어야 한다. <br>

## Reference
- Database Management Systems <Raghu Ramkrishnan 저>
