# 16.1 트랜잭션 ACID의 성질
"DB 트랜잭션의 4가지 기본 성질에 대해 알아보자."
트랜잭션은 DBMS의 입장에서 일련의 쓰기와 읽기 연산들로 이루어진 사용자 프로그램의 한 번의 실행이다.
연산들을 논리적으로 하나로 엮은 것.

ACID는 DBMS의 동시 접근성과 장애 복구시 일관성을 유지하기 위해 보장하는 성질들이다.
1. `Atomic` : 사용자는 각 트랜잭션의 수행을 `원자적`으로(Atomicity) 생각할 수 있어야 한다. 
원자적 실행은 각 트랜잭션의 모든 연산이 **실행되거나 or 실행되지 않아야 한다.** 
트랜잭션이 원자적이라면 사용자는 시스템 장애 등의 상황에서 완료되지 않은 트랜잭션의 영향에 대해 걱정하지 않아도 된다.
2. `Consistency` : DBMS는 각 트랜잭션의 단독 수행이 데이터베이스의 `일관성`을 보장한다고 가정한다. 
다른 트랜잭션들과 동시에 수행되지 않는 각 트랜잭션은 DB의 일관성을 유지해야 한다. 즉, 일관성 있는 DB에 트랜잭션을 수행할 때, 수행 이후에도 DB는 일관성이 있는 상태가 되는 것을 보장해야 한다. 예를 들어 사용자간에 돈을 거래하더라도 은행 계좌 잔액의 총합은 변하지 않아야 한다. 이 성질을 보장하는 것은 사용자의 책임이다.
3. `Isolation` : 사용자는 동시 수행중인 다른 트랜잭션들의 영향을 고려하지 않으면서, 트랜잭션의 수행 결과를 이해할 수 있어야 한다. 즉, 여러 트랜잭션들의 액션들이 인터리브 된다고 할 때, 순수한 효과는 직렬 순서로 트랜잭션들을 수행한 것과 동일함을 보장해야 한다는 것이다. 
트랜잭션 T1과 T2가 있을 때, T1 -> T2 순서로 진행되던, T2 -> T1 순서로 진행되던, 둘이 동시에 진행되던지 간에, 결과적으론 같은 상태의 DB가 되어야 한다는 것이다. 이런 트랜잭션의 성질을 `고립성`이라고 한다. 각 트랜잭션은 동시에 스케줄링된 다른 트랜잭션들의 영향으로 부터 고립되거나, 보호된다.
4. `Durability` : 트랜잭션은 `영속성`을 보장해야 한다. 사용자에게 트랜잭션이 완료되었다는 것이 '통보된다면' 그것이 디스크에 반영되기 전에 시스템 장애가 발생한다 하더라도 지속적으로 남아 있어야한다.


### DB 일관성
데이터베이스 일관성은 모든 트랜잭션들이 일관성 있는 DB 인스턴스를 보는 성질이다.
DB 일관성은 트랜잭션 원자성, 고립성, 일관성으로 부터 얻어진다!

TODO : 여기까지 전공서의 설명이다.
Consistency 부분은 좀 와닿지 않고, 설명이 많이 복잡하니까 다른 책을 추가적으로 찾아보는게 좋겠다.


## 원자성과 영속성의 보장
트랜잭션은 아래와 같은 3가지 이유로 완료되지 않을 수도 있다
1. 한 트랜잭션 수행동안 '어떤 이상'이 발생해 DBMS에 의해 트랜잭션이 철회되거나, 성공적으로 종료되지 않을 수도 있다.
내부적인 이유로 DBMS에 의해 트랜잭션이 철회된다면, 그 트랜잭션은 자동으로 재시작되어 새로 수행됨.
2. 트랜잭션이 수행중 시스템에 장애가 발생할 수 있다. 
3. 트랜잭션이 예상하지 못한 일이 발생할 수도 있다. 예기치 않은 데이터 값을 읽거나 디스크 접근이 불가능하면 수행을 중지하고 철회한다.

사용자는 트랜잭션을 원자적인 것으로 생각하기 때문에 수행 중 인터럽트를 받은 트랜잭션은 DB가 일관성이 없는 상태로 그대로 남겨 놓을 수도 있다. 이러한 이유로 DBMS는 DB로부터 부분적으로 수행된 **트랜잭션들의 영향을 제거하는 방법을 찾아야 한다.** 트랜잭션의 모든 액션이 수행되든지 전혀 안되든지 하는 트랜잭션 원자성을 보장해야 한다. <br>
**DBMS는 완료되지 않은 트랜잭션의 액션들을 undo 함으로써 원자성을 보장한다.** <br>
덕분에 사용자는 완료하지 않은 트랜잭션을 무시할 수 있다. <br>

DBMS는 이런 수행을 위해 모든 DB 쓰기에 대해 log라는 레코드를 유지한다. 로그는 영속성 보장을 위해 사용되고, 앞서 언급한 것과 같이 디스크에 변화가 반영되기 전에 장애가 발생한다면, 재시작시 로그에 기록된 변경들을 사용해 시스템을 복구한다. <Br>
이러한 원자성과 영속성을 보장하는 DBMS의 컴포넌트를 `recovery manager - 복구 관리기`라고 부른다. (16.7절)

# 16.2 트랜잭션과 스케줄

용어 정리 <br>
객체 O가 있을 때
1. 읽기 작업 : R_T(O) -> O를 읽는 트랜잭션
2. 쓰기 작업 : W_T(O)
3. 완료 액션 : Commit_T
4. 철회 액션 : Abort_T

완료 액션과 철회 액션은 각 트랜잭션의 최종 액션으로써 명시 되어야 한다. <br>


### Schedule


스케줄은 트랜잭션들의 집합에서 온 4가지 액션들의 리스트로, **실질적인 혹은 잠정적인 액션들의 실행순서(Execution Sequence)를 표현한다.** <br>
트랜잭션의 두 액션의 순서는 스케줄에서도 동일한 순서로 나타난다. <br>
각 트랜잭션에 대한 철회나 완료 연산이 포함된 스케줄을 완전 스케줄이라고 부르고, 트랜잭션들이 시작부터 끝까지 하나의 순서로 실행되는 스케줄을 직렬 스케줄이라고 부른다. <br>


# 16.3 트랜잭션들의 동시수행
DBMS는 성능 향상을 위해 서로 다른 트랜잭션들의 액션들이 인터리브(끼워 넣기) 되게 한다. <br>
스케줄은 트랜잭션들의 인터리브된 실행을 편리하게 기술하도록 돕는다. <br>
모든 인터리브가 허용되는 것은 아닌데, 어떤 인터리빙 또는 스케줄이 허용되는지 알아보자.

## 16.3.1 동시수행 동기
여러 트랜잭션들이 동시에 수행되면서 고립성을 보장하는 것은 어렵다. <br>
무조건 동시에 한가지 트랜잭션만 일어난다면 고립성의 보장이야 쉽다. 하지만, 성능을 높히기 위해선 동시 수행이 필수적이다. <br>

1. `I/O 연산과 CPU 연산 인터리브` : 컴퓨터에서 I/O 연산과 CPU 연산은 동시 수행이 가능하므로, **한 트랜잭션이 디스크에서 한 페이지를 읽기 위해 기다릴 떄, CPU는 다른 트랜잭션을 처리할 수 있다.** 이는 프로세서의 쉬는 시간을 줄여, 시간당 시스템 처리량 (throughput)을 증가시킨다.
2. 짧은 트랜잭션이 긴 트랜잭션 수행이 끝나는 것을 기다리지 않고, 인터리브 되도록 실행한다. 


## 16.3.2 직렬 가능성
주어진 스케줄을 실행한 결과의 DB 인스턴스는 직렬순서로 트랜잭션을 실행한 결과의 DB 인스턴스와 동일하다. <Br>
완료된 트랜잭션의 집합 S의 직렬 가능한 스케줄이 DB에 끼친 영향은 S의 직렬 스케줄이 끼친 영향과 동일하다. <br>
트랜잭션 T1, T2가 T1 -> T2 순서로 요청됐다면, T1이 먼저 시작한 인터리빙 직렬 스케줄 T1;T2의 결과와 동일하고 <br>
T2 -> T1 순서라면 T2가 먼저 시작한 인터리빙 직렬 스케줄 T2;T1의 결과와 동일하다.


## 16.3.3 트랜잭션 동시 수행으로 인한 이상현상 
### (인터리브된 실행에 의한 이상 현상)
두 트랜잭션을 포함하는 스케줄이 일관성 있는 DB상에서 실행될 때, 일관성이 없는 상태의 DB를 산출할 수도 있다. <br>
동일한 데이터 객체상의 두 액션은 **그들 중 적어도 하나가 쓰기인 경우 conflict한다.**
3가지 이상 현상을 T1, T2의 충돌로 기술할 수 있다. 

1. 쓰기-읽기 충돌 (WR 충돌)
2. 읽기-쓰기 충돌 (RW 충돌)
3. 쓰기-쓰기 충돌 (WW 충돌)


## Dirty Read - WR 충돌
Dirty Read가 바로 쓰기-읽기 충돌이다. 
1. 트랜잭션 T1이 객체 A에 쓰기 작업 진행
2. 트랜잭션 T1은 완료되지 않음
3. 트랜잭션 T2가 객체 A를 읽음

그러니까 완료되지 않은 트랜잭션이 변경한 데이터를 읽은 상황 <br>
이런 경우 당연히 일관성이 어긋난다. <br>
예를 들어 T1은 회원 1의 100만원을 회원 2로 보내고, T2는 회원 1, 2의 돈을 6% 증가시킨다고 하자. <br>
T1은 회원 1의 100만원을 뺀 다음, 회원 2에게 100만원을 더해줄 것이다. <br>
만약 100만원이 빠지자 마자 T2가 진행되어 잔액의 6%가 오르게 된다면 일관성이 깨진다. <br>
트랜잭션이 수행중일 때에는 일관성이 깨질 수도 있다.


## Unrepeatable Read - RW 충돌
Unrepeatable Read가 읽기-쓰기 충돌이다.
1. T1이 물건의 재고 A를 읽음. 재고가 남아있음을 확인하여 다음 계산을 진행하려함
2. 이떄 T2가 값 A를 0으로 바꿈
3. T1은 나머지 연산을 처리하려 하는데 재고가 사라져 있음. 에러 발생

이런식의 진행은 당연히 직렬적 수행과는 아예 다른 결과를 가져오게 된다.

## Lost Update - WW 충돌
단순히 읽는 과정이 없더라도, 쓰기 충돌은 문제가 될 수 있다.
(값을 읽지 않는 무조건 쓰기 - Blind Read) <br>
1. 값 A와 B는 항상 동일해야 한다.
2. T1은 두 값을 1000으로 T2는 두 값을 2000으로 바꾼다
3. 인터리빙으로 트랜잭션 실행
4. T1이 A를 1000으로 바꿈
5. T2가 B의 값을 2000으로 바꿈
6. T1이 B의 값을 1000으로 바꿈
7. T2가 A의 값을 2000으로 바꿈

이 결과는 T1 -> T2, T2 -> T1 두 순서 직렬 진행 중 어느 경우와도 동일하지 않는다. <br>
문제는 Lost Update - 갱신 분실이 발생한다는 것이다. <br>
직렬 순서 T1;T2인데, T2의 갱신인 5번 - B값 변경이 분실되었다. 


## 16.3.4 철회된 트랜잭션을 포함하는 스케줄
직렬 가능한 스케줄 : 트랜잭션 집합 S의 직렬가능 스케줄이 일관성 있는 DB에 끼친 영향은
S에 있는 "완료된" 트랜잭션들 중 직렬 스케줄이 끼친 영향과 동일하다. <br>

직렬 가능성에 대한 정의는, 철회된 트랜잭션들이 완전히 undo 된다는 것에 의존한다. <br>
어떤 상황에서는 완전한 undo가 불가능하다.

T1과 T2 스케줄에서 T1 -> T2 -> T1 이런 식으로 진행될 때 T2가 완료된 다음 T1이 철회된다면 undo할 수 없다.
이러한 스케줄을 복구 불가능(unrecoverable) 스케줄이라고 한다. 복구 가능 스케줄에서 트랜잭션들은 그들이 읽은 모든 트랜잭션들이 완료된 다음 완료한다. 트랜잭션들이 완료한 트랜잭션만 읽는다면 그 스케줄은 복구 가능할 뿐만 아니라, 트랜잭션을 철회하는 것은 다른 트랜잭션들은 연쇄적으로 철회하지 않고 이루어지는데, 이러한 스케줄을 연쇄 철회 방지한다고 한다. <br>


## Reference
- Database Management Systems \<Raghu Ramkrishnan 저>

