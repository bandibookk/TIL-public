# 21.5 인터넷 응용 프로그램 보안
DBMS가 안전한 위치에서 접근되는 경우, 사용자를 인증하기 위해 간단한 암호 메카니즘에 의지할 수 있다. <br>
하지만 지금 Amazon에서 진호의 계정으로 주문 하려는 고객이 진짜 진호인지 어떻게 알까? <br>
진호의 입장에서는 Amazon으로 생각하고 주문하는 사이트가 진짜 Amazon인지, 아니면 사기를 위한 가짜 사이트인지.. 어떻게 판별해야 할까?

## 21.5.1 암호화
암호키(encryption key)와 decryption key를 사용하여 데이터에 암호화, 복호화 알고리즘을 적용하는 것이 기본 아이디어! <br>

1. symmetric encryption(대칭적 암호화): 암호화 키가 복호화 키로도 사용되고, 권한이 있는 모든 사용자에게 암호화 키를 알려주어야 하다보니, 매우 취약한 편이다. <br> ex) ANSI 데이터 암호화 표준 DES - 문자 치환과 순열을 사용
### 2. public-key encryption(공개키 암호화)   
사용자들은 **공개 암호화 키(public encryption key)와** 자신만 알고 있는 **비공개 복호화 키(private descryption eky)를** 각각 하나씩 가지고 있다. <br> 
공개키 암호화 알고리즘은 **단방향 함수(one-way function)의 존재에 의존한다.** 이는 계산적으로 그 역을 구하기가 대단히 어려운 함수를 일컫는다. <br>

**그 예시로는 RSA 알고리즘이 있다.**

## 21.5.2 RSA 알고리즘
암호화 될 데이터 정수 I가 있다. 암호화 해야 될 어떤 수 보다도 더 큰 정수 L을 고른다. **L의 값은 아주 큰 두개의 서로 다른 소수 p, q의 곱으로 만들어낸다.** <br>
그리고 암호화 키 e를 선택한 다음, e와 L을 기반으로 복호화 키 d를 계산한다. <br>
그리고 L과 e를 모두 공개하고 암호화 알고리즘에 사용한다. d는 숨긴다.
1. I가 있을 때,
2. 아주 큰 정수 L, 암호화 키 e를 선택
3. e와 L을 기반으로 복호화 키 d 계산

암호화 함수와 복호화 함수는 간단해 보이지만 매우 풀기 어렵다.
- 암호화 함수 S: `S = I^c % L`
- 복호화 함수 I: `I = S^d % L`

구성을 살펴보자. <br>

- **큰 정수 L:** L값은 두 개의 서로 다른 1024 bit 크기의 큰 소수 p, q의 곱으로 만든다. <br> `L = p * q`
- **암호화 키 e:** 암호화 키 e는 1과 L 사이의 임의로 선택한 숫자로써 (p-1)*(q-1)과 소수 관계이다.
- **복호화 키 d:** `d * e = 1 % ((p-1) * (q-1))`

**RSA의 핵심은 e, p, q가 주어졌을 때 d를 계산하는 것은 쉬운 대신, e와 L만으로는 d를 구하기가 아주 아주 어렵다는 점이다!** <br>

상대방이 L을 가지게 되어도 결국 d를 도저히 구해낼 수가 없는 것이다. L의 소인수(prime factor) 들을 구하기가 너무 어렵다.. <br> <br>

### 공개키와 비공개키 - public key, private key
암호화 키 e와 복호화 키 d는 서로 역할이 바뀔 수 있다. <br> 
```
I = decrypt(d, (encrypt(e, I))) 
= decrypt(e, (encrypt(d, I)))
```
이러한 성질 때문에, 단순히 공개키와 비공개키로 불러도 된다.

## 21.5.3 SSL 프로토콜
(한번 더 정리해보자.) <br>
진호가 Amazon의 공개키를 사용해서 주문을 암호화 한다음, 아마존에 보낸다. 그러면 Amazon은 비공개키를 활용해서 해독한다. <br>

Verisign과 같은 인증기관 (certification authority)들이 있는데, 아마존이 공개 암포화키 e와 비공개 복호화 키를 생성하고, 공개키를 Verisign에 보낸다. 그러면 Verisign은 아마존에 인증서를 보내준다. <br>
인증서: `<Verisign, Amazon, https://www.amazon.com, e_A>` <br>

이 인증서는 **Virisign의 비공개키를 사용해서 암호화 되었다.** <br>

진호가 Amazon에 방문해서 주문하려고 하면, **SSL을 사용하는 진호의 브라우저는 서버에 Verisign 인증서를 요청한다.** <br>

브라우저는 그 인증서를 Verisign의 공개키를 사용해 복호화 하고, 그 결과는 위에 보여준 인증서이다. **인증서에 포함된 URL과 현재 통신중인 서버의 URL이 일치한다면 인증서가 검증된다.** 인증서는 Verisign의 비공개키를 사용하여 암호화 했기 때문에 위조는 어렵다. <br>

브라우저는 이에, 임의의 세션키를 생성한다. 이 세션키를 이제 Amazon을 신뢰하기에 그 Amazon의 공개키를 이용해서 암호화한 다음 Amazon의 서버로 전송한다. <br>

이 때부터 아마존 서버와 브라우저는 세션키를 믿고 사용할 수 있게 된다. 
AES나 DES와 같은 대칭 암호화 프로토콜을 사용해서 메세지를 암호화 하여 교환한다. 
발송자가 암호화 한다. 중간에 탈취 당해도 세션키 없이는 해독이 불가능 (설명 가능해야 한다.) <br>

결국 브라우저는 Amazon의 공개키를 사용해서 암호화한 진호의 원래 요청을 갖게 된다. 
그리고 이 요청을 Amazon 서버에 안전하게 보낼 수 있게 된다. 세션키는 세션이 끝나면 버려진다. <br> <br>

**그렇다면, 이제 진호의 신원 확인은 어떻게 할까?** **당연히 로그인이다.** Amazon은 실제 접속자의 신원 확인이 필요할 때마다 세션키 설정을 위한 SSL 프로토콜 로그인을 요구한다. <br>

### SSL의 단점
ssl의 남아있는 단점은 Amazon이 진호의 신용카느 번호를 알게 된다는 점이다. **Secure Electronic Transaction Protocol은** 이러한 단점을 극복하고자 한다. 모든 고객은 자신의 공개키와 비공개키가 포함된 인증서를 획득해야 하고, 모든 트랜잭션에는 Amazon서버와 고객의 브라우저와 Visa Card와 같이 신뢰할 수 있는 제 3기관의 서버가 관여하게 된다. <br>

기본 아이디어는 브라우저가 신용카드 이외의 정보는 전부 Amazon 공개키를 통해 암호화 하고, 신용카드 정보는 Visa Card의 공개키를 사용해서 암호화 하는 것이다. <br>
이후 이들을 Amazon 서버에 보내면, Amazon 서버는 신용카드 정보를 Visa 서버에 전달한다. Visa 서버가 이를 승인해주면, 트랜잭션이 계속 진행되는 것이다..


## 21.5.4 디지털 서명
Amazon사의 여러 직원들이 서로 메시지를 주고 받을 때, 메시지 전달의 디지털 서명을 생성하는 데에 공개키 암호화가 쓰일 수 있다. <br>

단순히 메시지를 암호화 하는 것 뿐만 아니라, 정말 누구에게서 온건지도 확인할 수 있다! 무려 다른 사람의 계정을 사용해서 보낸다고 해도 말이다! <br>

1. 진호는 자신의 비공개키를 사용해서 메시지를 암호화 한다.
2. 그 결과를 동호의 공개키를 사용해서 다시 암호화 한다.
3. 동호가 메시지를 받으면 자신의 비공개키로 1차적으로 복호화 한다.
4. 이후, 진호의 공개키를 이용해서 복호화 하면, 본래의 메시지를 얻을 수 있다.


<br>

만약 메시지 내용을 숨기는 것이 중요하지 않다면, 서명 암호화 만으로 보안을 해결해도 된다. 서명의 크기는 작으므로, 암호화 비용을 대폭 줄일 수 있다.

## Reference
- Database Management Systems \<Raghu Ramkrishnan 저>
