# 18.6 시스템 장애 복구
시스템 장애 발생 후 재시작시 복구 관리기는
**ARIES(Algorithm for Recovery and Isolation Exploiting Semantics)에** 따라 3단계 과정을 통해 복구한다.

1. `분석 단계` : 버퍼 풀에서 Dirty Page들과 **장애시점에서 활동중인 트랜직션들을 식별**
2. `Redo 단계` : 로그 내의 '적당한 지점'에서 시작해 모든 액션들을 다시 적용. **DB의 상태를 장애시점의 상태로 복구**
3. `Undo 단계` : **DB에 완료된 트랜잭션들의 액션만이 반영될 수 있도록,** 완료되지 못한 트랜잭션들의 액션을 undo함

![image](https://github.com/binary-ho/spring-advanced/assets/71186266/93e2635c-ab1d-47e4-92e0-e31512f5a7a6)

<br>

`분석 단계`는 위 그림에서 LSN이 `C`로 표기된 `Most recent checkpoint` 지점, 가장 최근의 `begin_checkpoint` 레코드를 조사하는 것으로 시작해, 마지막 로그 레코드까지 로그를 조사한다. <br>
**`Redo 단계`에선 장애시점에서 Dirty였던 모든 페이지들의 변경을 redo한다.** 이러한 페이지 집합과 redo 시작점은 분석단계에서 결정되는데, 더티 페이지들 가운데 가장 적은 recLSN이 시작점으로 결정된다. (recovery LSN) <br>
recLSN은 페이지의 마지막으로 쓰인 로그 레코드를 가리키는 포인터이다. <br>


그리고 `Undo 단계`는 장애시점에서의 모든 활동 트랜잭션의 변경을 undo한다. <br> <br>

**활동 트랜잭션은 분석 단계에서 식별되고,** <br> 
**redo는 변경들이 원래 실행된 순서로 적용하며,** <br> 
**undo는 가장 최근 변경을 먼저 환원하며 변경들을 역순으로 환원한다.** <br>

이 재시작의 3단계를 좀 더 자세히 살펴보자.

## 18.6.1 분석단계
분석 단계는 아래 3가지 작업을 실행하며 진행된다.

1. redo를 시작할 로그 위치를 결정한다
2. 장애시점에서의 Dirty Page들을 결정한다. 이는 버퍼 풀에 있는 변경 페이지들을 확인한다.
3. 장애시점에서 활동상태인 트랜잭션을 식별하고, undo한다.

분석단계는 첫 번째로 가장 최근의 `begin_checkpoint` 로그 레코드를 조사하고, Dirty Page Table과 트랜잭션 테이블을 다음에 나오는 `end_checkpoint` 레코드에 있는 것들의 사본으로 초기화한다. <br>

결과적으로 Dirty Page Table과 Transaction Table은 체크포인트 시점의 상태로 초기화된다. <br>

만약 begin_checkpoint와 end_checkpoint 사이에 추가된 로그 레코드들이 있다면, 두 테이블은 추가 정보를 반영한다. <br>

## 18.6.1.1 로그 검토
분석단계는 로그의 끝에 도달할 때까지 로드를 검토한다. <Br>

### 1. end log record를 만났을 떄
`end 로그 레코드`를 만나면, 트랜잭션 T는 Transaction Table에서 제거된다. T는 이미 활동 상태가 아니기 때문이다.

### 2. end가 아닌 레코드들을 만났을 때
트랜잭션 T에 대한 레코드를 만났을 때, T에 대한 엔트리가 Transaction Table에 없다면 T를 Table에 추가한다. <Br>
트랜잭션 테이블에서 T에 대한 엔트리가 아래와 같이 수정된다.

1. lastLSN 필드를 이 로그 레코드의 LSN으로 변경
2. 로그 레코드가 commit 레코드라면 상태를 C로 변경하고, 아닌 경우 U로 변경한다. <br> **U는 undo 되어야 한다는 것을 의미한다.**

<br>

**즉, End 레코드가 아니고, Commit 레코드가 아니라면 해당 로그 레코드는 undo 되어야 한다.**

### 3. 페이지 변경 레코드

페이지 P에 영향을 끼친 **redo 가능한 로그 레코드를** 만났는데, 만약 P가 Dirty Page Table에 없다면, 하나의 엔트리를 추가한다. <br> 
이 엔트리는 페이지의 id인 P와 redo 가능한 레코드의 LSN을 recLSN으로 갖는다. <br>

**이 엔트리의 recLSN은 페이지 P에 영향을 끼친 가장 최초의 변경을 식별하게 해준다.** <br>


### 18.6.1.2 분석 단계의 결과
분석단계가 끝나면 Transaction Table은 장애시점에서 활동상태에 있는 모든 트랜잭션의 정확한 리스트를 갖게 된다! <br>
이것은 상태 `U`를 갖는 트랜잭션들의 집합으로, 상태 `U`는 undo 되어야 한다는 것을 의미한다. <Br> <br>

Dirty Page Table은 장애시점에서 Dirty였던 모든 페이지를 포함하게 된다. **조심해야 할 점은 이 Table은 이미 디스크에 쓴 페이지도 포함한다는 것이다!** <br> 

(`end_write` 라는 레코드로 페이지의 "쓰임" 여부를 구분하면 좀 더 정확하게 이미 쓰인 페이지를 구분할 수도 있겠지만, ARIES에서는 이 로그를 쓰는 오버해드가 더 크다고 판단한다.) 


## 18.6.2 Redo 단계
Redo 단계동안 ARIES는 
1. 모든 트랜잭션 갱신을 다시 적용한다. (완료 미완료 전부)
2. CLR들에 기록된 undo 액션들이 다시 적용된다. <br> 
이 Repeating history (반복 적용 히스토리) 패러다임은 ARIES의 특징이다. 이 반복 적용 히스토리는 데이터베이스가 장애시점에 있었던 동일한 상태로 복구되게 한다.   <br> <br>

Redo 단계는 분석 단계에서 만들어진 Dirty Page Table에서 가장 작은 recLSN 값을 찾아, 가장 오래된 갱신 로그 레코드를 알아낸다. <br>
redo는 이 레코드 부터 로그의 끝까지 검사된다. <br>
만나는 각 redo 가능 로그 레코드는 **액션이 redo 되어야 하는지 검사된다.** <br>

아래 3가지 조건들 중 하나라도 만족하지 않으면 redo 되어야 하는 액션이다. **3가지 조건을 전부 만족하면 redo할 필요가 없다.**

1. 액션에 영향을 받은 page가 Dirty Page Table에 존재하지 않는다. -> 쓰기 완료됨
2. 액션에 영향을 받은 page가 Dirty Page Table에 존재하지만, **해당 액션 이후에도 page가 수정되는 경우 -> 해당 엔트리가 가진 recLSN이 검사중인 로그 레코드의 LSN 보다 큰 경우**
3. 액션이 page에 주는 마지막 영향이 아닌 경우 -> **이미 쓰인 페이지에 저장된 pageLSN이 검사되고 있는 로그 레코드의 LSN보다 더 크거나 같음**

<br>

위처럼 보면 너무 헷갈리고 아래를 보자
1. 이미 쓰기 완료된 페이지 -> redo 안함
2. 쓰기 완료는 안 됐지만, 이후 또 다른 액션이 페이지를 수정함 -> redo 안함
3. 지금 액션이 page의 마지막 액션이 아님 -> redo 안함. 2번이랑 같은거 아닌가?


<br>

**1번 조건은** 해당 페이지의 모든 변경이 이미 디스크에 기록되었다는 것을 의미한다. <br>
**2번 조건은** 검사되고 있는 갱신이 디스크에 정말 전파되었다는 것을 의미한다. 왜냐하면 recLSN은 디스크에 기록되지 않은 이 패이지의 첫 갱신이기 때문이다. (갱신이 정말 전파되었다 부분 헷갈린다.) <br>
**pageLSN이 더 작다면, 검사중인 액션이 디스크에 쓰여지지 않았다는 것을 알 수 있으므로 액션이 다시 적용된다.** <br>

**3번 조건은** 페이지 검색을 요구하는데, 검사되는 갱신이 이미 디스크에 쓰인 것을 보장한다! 이 갱신 또는 이후의 갱신이 디스크에 쓰여졌으니까 확인 가능한 것이기 때문이다.

<br>

## 로그에 있는 액션이 redo 되어야 하는 경우
로그에 있는 액션이 redo 되어야 한다면
1. **로그된 액션이 다시 적용된다.**
2. **페이지의 pageLSN이 redo된 로그 레코드의 LSN으로 설정된다!** (이때 추가 로그가 발생하지 않는다.)

<br>

- 더티 페이지의 최소값 LSN이 첫 로그 레코드의 LSN이다 <br> 이전의 로그들은 분명 반영 되어 있다.

### 결론적으로, 시스템을 장애시점에 있었던 정확한 상태로 복구한다.

그리고 Redo 단계의 마지막에, 상태 `C`를 갖고, Transcation Table에서 제거된 모든 트랜잭션에 대해 end 타입 레코드가 로그에 쓰인다. ??? -> 책에서는 이렇게 쓰여 있지만 사실 여부를 확인해야함 

<br>

## 18.6.3 Undo 단계

**Undo 단계의 목적은 장애시점에서 활동 상태인 모든 트랜잭션들의 액션을 undo 하는 것이다.** <br>
다른 두 단계와 달리 undo 단계는 로그의 끝에서 앞으로 검사된다. <br>

**즉, 로그의 액션들을 사실상 철회하는 것이다!** 활동 트랜잭션들은 분석단계에서 만들어진 Transaction Table에서 식별할 수 있다.

### 18.6.3.1 undo 알고리즘
분석 단계에서 만들어진 트랜잭션 테이블은 각 활동 트랜잭션의 가장 최근 로그 레코드의 LSN인 `lastLSN`을 포함한다. <br>
이런 트랜잭션들을 **상태상실 트랜잭션이라고** 부르는데, 모든 상태상실 트랜잭션들의 액션은 undo되어야 한다. (undo 되어야 하는 트랜잭션이기 때문에 상태상실 트랜잭션이라고 부른다.) <br>
이러한 액션들은 로그에서 나타나는 순서의 역순으로 undo 된다.

 <br> <br>

모~든 상태상실 트랜잭션들의 lastLSN의 집합을 `ToUndo`라고 부른다. 마치 ToDO List.. <br>

**undo 과정은 `ToUndo`가 공집합이 될 때까지, 가장 최근의 로그 부터 반복적으로 처리한다.** -> 가장 큰 LSN 값을 반복적으로 선택해 처리한다. <br>
그 과정은 아래와 같다

1. 레코드가 갱신 레코드라면, CLR이 로그에 쓰여지고, 해당 액션이 undo 된다. 그리고 갱신 로그 레코드에 있는 prevLSN이 `ToUndo`에 추가된다. -> 역추적 해서 undo 하기 위해
2. 레코드가 CLR일떄, 
  - `undoNextLSN`이 null이 아닌 경우 : `undoNextLSN` 값이 `ToUndo`에 추가됨.
  - `undoNextLSN`이 null인 경우 : 트랜잭션이 완전히 undo 되었다는 의미이므로, 해당 트랜잭션에 대한 end 레코드가 쓰여지고 CLR이 제거된다.

<br> <br>

이러한 과정들이 끝나고 ToUndo가 공집합이 되면 Undo 단계가 완료된다. 재시작은 끝났고, 시스템은 정상적으로 연산을 진행할 수 있게 된다.

### 18.6.3.2 트랜잭션 철회
트랜잭션을 철회하는 것은 ~~트랜잭션의 집합이라기 보다는~~ 하나의 트랜잭션이 undo 되는 특별한 경우이다. <br> 


위 그림은 이 점을 잘 설명하고 있다. <br>
다음 절을 참고하라.

### 18.6.3.3 재시작 동안의 장애 상황

undo 알고리즘이 어떻게 반복되는 시스템 장애를 다루는가를 이해하는 것은 중요하다. <br>
갱신로그 레코드에 기록된 액션이 정확히 어떻게 undo 되는지의 예시와 함께 이해하자. <br>
이 예는 트랜잭션을 철회하는 것이 undo의 특별한 경우이고, CLR의 사용이 갱신로그 레코드의 undo 액션을 두번 적용하지 않도록 돕는다는 것을 알 수 있다. <br>

[마지막 예시는 그림을 직접 그려서 함께 자세하게 설명해보자]

## Reference
- Database Management Systems <Raghu Ramkrishnan 저>

