

# 18. 장애 복구
DBMS의 Recovery Manager는 트랜잭션의 원자성과 영속성에 대한 책임을 가지고 있다. <br>
완료되지 않는 트랜잭션들을 undo 함으로서 원자성을 보장하고, 완료된 트랜잭션들의 모든 액션이 시스템 장에와 미디어 고장(디스크 손상)에도 살아남아 있게 함으로서 영속성을 보장한다. <br>

# 18.1 ARIES
ARIES는 복구 알고리즘으로, steal, no-force 접근방법으로 작동하도록 설계된 복구 알고리즘이다. <Br>
아래 3 단계를 거쳐 진행된다.
1. `분석 단계` : 버퍼 풀에서 Dirty Page들과 장애시점에서 활동중인 트랜직션들을 식별함. (Dirty Page는 디스크에 쓰지 않은 변경사항을 가진 페이지)
2. `Redo 단계` : 로그 내의 '적당한 지점'에서 시작해 모든 액션들을 다시 적용하여 **DB의 상태를 장애시점의 상태로 복구함!** 
3. `Undo 단계` : DB에 완료된 트랜잭션들의 액션만이 반영될 수 있도록, 완료되지 못한 트랜잭션들의 액션을 undo함

간단하게 말 하자면 **완료된 트랜잭션은 모두 반영해주고, 완료되지 못한 트랜잭션은 (활동중인 트랜잭션)은 Undo 한다. <Br> 그런데 활동중인 트랜잭션이 만들어낸 변화가 있다면 Redo 단계 동안에 히스토리에 있는 순서대로 되돌린다.**  <br>

<Br>


## ARIES 3원칙
ARIES 복구 알고리즘의 중요한 3가지 원칙이 있다.

1. `Write-Ahead Logging (쓰기 전 로딩)` : 데이터베이스 객체에서의 변경이 **일단 먼저 로그에 기록된다.** <br> 로그에 있는 레코드는 데이터베이스 객체에서의 변경이 디스크에 쓰여지기 전에 안정된 저장장치에 쓰여져야 한다.
2. `Redo 동안 히스토리 반복 적용 - Repeating History During Redo` : 장애 후 재시작할떄 ARIES는 장애 전의 DBMS의 모든 액션들을 거슬러 올라가 다시 적용해 시스템을 장애시점에 있었던 정확한 상태로 되돌려 놓는다. 그 후에 장애시점에서 여전히 활동상태인 트랜잭션들의 액션을 undo함으로써, 그들을 철회한다.
3. `Undo 동안 변경사항 로깅 - Logging Changes During Undo` : 트랜잭션을 Undo 하면서 이루어진 DB에서의 변경은 장애로 인한 되풀이되는 재시작이 있는 경우 액션이 반복되지 않도록 로그에 기록된다. 


Redo 동안 히스토리 반복 적용이 ARIES를 다른 복구 알고리즘과 구별되게 해준다. <Br>
더한 단순성과 융통성의 근거가 되게 해주는데 ARIES는 특히 더 미세한 레코드 수준의 잠금 단위의 잠금 등을 포함하는 동시성 제어를 지원한다. <br>
2번과 3번은 연산을 redo하고 undo하는 것이 서로 정확히 역이 아닌 연산들을 다루는데 중요하다. <Br>

## 18.2 Log
Trail 혹은 Journal로도 불리는 로그는 DBMS가 실행하는 액션들의 히스토리이다. <br>
**물리적으로 로그는 장애에도 견고한 안정된 저장장치에 저장되는 레코드들의 파일이다.** <br>
로그 레코드들의 영속성은 다른 디스크에 둘 또는 그 이상의 사본을 유지함으로써 달성된다. <br>
주기억장치에 저장되는 로그의 가장 최근 부분을 log tail이라고 부른다. 로그 레코드들과 데이터 레코드들이 동일한 잠금 단위로 디스크에 쓰인다. <br>

모든 로그 레코드는 id를 갖는데 Log Sequence Number(LSN)이라고 불린다. <br>
LSN이 주어지면 한번의 디스크 접근으로 로그 레코드를 찾을 수 있고, 단조 증가 순서로 할당된다 (Autoincrease 비슷한 개념인듯 한다.) <br> 
-> 이 속성들은 ARIES 복구 알고리즘에서 요구된다. <br>
**각 페이지는 자신의 변경을 기술하는 가장 최근 로그 레코드의 LSN를 가지고 있다.** <br>
**이를 pageLSN이라고 부르며, 복구를 위해서 존재한다.**

## 18.2.1 로그 레코드가 쓰이는 경우
로그 레코드들은 다음 액션들 각각에 대해 쓰여진다
1. `페이지 갱신` : 페이지 수정 후 update 타입의 레코드가 Log Tail에 추가된다. <Br> 이 페이지의 pageLSN이 갱신된다.
2. `Commit` : **트랜잭션이 완료를 결정할 때, 트랜잭션 id와 commit 타입의 로그 레코드를 강제 쓰기 한다.** <br> 로그 레코드는 로그에 추가되고, 해당 레코드까지의 Log Tail이 안정된 저장장치에 쓰인다. 트랜잭션은 commit 레코드가 안정된 저장장치에 쓰이는 순간 완료되었다고 판단한다. <br> Commit 로드 기록 이후 트랜잭션 테이블에서 트랜잭션 엔트리가 제거된다.
3. `Abort (철회)` : 트랜잭션이 철회될 때, abort 타입의 로그 레코드가 트랜잭션 id와 함께 로그에 추가된다. <br> 이후 이 트랜잭션에 대한 Undo 과정이 시작된다.
4. `End` : 트랜잭션이 Abort 또는 Commit 될 때 Abort or Commit 레코드를 기록한다. <br> 추가적인 액션 이후, 그 트랜잭션 id를 포함하는 end 타입 로그 레코드가 로그에 추가된다.
5. `갱신 Undo (Undoing an Update)` : 트랜잭션 Rollback시 - 트랜잭션이 철회되거나 장애로 부터 복구되는 동안 갱신이 undo된다. 갱신 로그 레코드가 기술한 액션이 undo 될 때 Compensation Log Record(CLR)가 기록된다.

<br>

모든 로그 레코드들은 prevLSN, transID, type 필드를 가지고 있다. <Br>
1. `prevLSN 리스트` : 주어진 트랜잭션에 대한 모든 로그 레코드들의 집합은 prevLSN을 사용해 거꾸로 추적하는 연결 리스트로 유지된다. <br>
2. `transID` : transID는 로그 레코드를 생성한 트랜잭션의 id이다.
3. `type` : 로그 레코드의 타입을 가리킨다.
4. `추가 필드` : 타입에 따라 다름

## 18.2.2 갱신 로그 레코드
갱신 로그에 포함된 레코드들은 아래와 같다
1. `pageID` : 수정된 페이지의 id
2. `이전 이미지 (before-image)` : 변경될 부분의 변경전 바이트 값
3. `이후 이미지 (after-image)` : 변경 후 바이트들의 값  

<Br>

- 이전 이미지와 이후 이미지를 모두 가진 갱신 로그 레코드는 변경된 것을 redo하거나, undo 하기 위해 사용될 수 있다. (undo나 redo 될 수 없는 경우도 있다.)
- **redo-only update 로그 레코드는 after image만 포함하고, undo-only update 레코드는 이전 이미지만을 포함한다.**

## 18.2.3 보상 로그 레코드 (Compenstation Log Record - CLR) 교재 554 page
**어떤 갱신이 undo 될 때 쓰인다.** <br>

보상 로그 레코드 CLR은 갱신 로그 레코드 U에 기록된 어떤 변경이 **undo되기 바로 전에 쓰여진다.** <br>
이 undo는 트랜잭션이 철회되거나, 정상 시스템 실행동안 또는 장애로 부터 복구되는 동안 발생할 수 있다. <br>
보상 로그 레코드 C는 해당 갱신 로그 레코드에 기록된 액션들을 **undo하기 위해 취해진 액션들을** 기술한다. (똑같이 Log Tail에 추가된다.) <br>

필드 `undoNextLSN`는 갱신 로그 레코드 `U`의 prevLSN 값으로, `U`를 기록한 트랜잭션을 undo하려는 다음 로그 레코드의 LSN이다 (이해 안 감) <Br> <br>

어떤 갱신이 undo될 때 CLR이 쓰이게 되는데, 갱신 레코드의 transID, pageID, 길이, offset, prevImage를 포함한다. <Br>

CLR은 영향을 받은 바이트들을 prevImage 값으로 undo하는 액션을 기록한다. <Br> <br>

CLR은 오직 undo하지 않을 액션만을 기술한다. <br>
결코 undo 액션을 undo하지 않는다. 이유는 갱신 로그 레코드는 정상수행동안 트랜잭션이 만들어낸 변경을 기술하고, 또 철회될 수 있다. <br>
반면 CLR은 철회 결정이 이미 내려진 트랜잭션을 롤백하기 위해 취해진 액션을 기술하므로, 적혀있는 액션들은 명백하게 실행되어야 한다. 

# 18.3 추가 Recovery 구조들

로그 외에도 복구에 있어 중요한 두 테이블이 있다.

### 18.3.1 Transaction Table
**하나의 활동 트랜잭션 당 하나의 엔트리를 보유하고 있다.** <br>
이 엔트리는 다른 정보들과 함께 아래와 같은 필드를 포함하고 있다.
- `트랜잭션 id`
- `트랜잭션 상태` : 진행중, 완료, 철회
- `lastLSN` : 트랜잭션에 대한 가장 최근 로그 레코드 (Last Log Sequence Number)


### 18.3.2 Dirty Page Table
**더티 페이지 테이블은 버퍼 풀에 있는 하나의 더티 페이지당 하나의 엔트리를 보유하고 있다.** <br>
이 엔트리는 `resLSN` 필드를 포함하고 있다.
`resLSN`은 **해당 페이지를 Dirty 하게 만든 (변경한) 첫 로그 레코드의 LSN이다.** <Br> 
-> 첫 변화가 어디인지 추적가능하다. 
resLSN은 장애로 부터 재시작 동안 이 페이지에 대해 redo될 첫 레코드 - 가장 오래된 로그 레코드를 식별한다. 

<br> <Br>

이러한 두 테이블은 각각 Transaction Manger와 Buffer Manager에 의해 유지되는데,
장애 후 재시작동안 이 테이블들은 재시작의 `분석 단계`에서 다시 재구성 된다.

# 18.4 WAL Log Protocol -> 설명 부실한 느낌
페이지를 디스크게 쓰기 전에, 페이지의 변경을 기술하는 모든 갱신 로그 레코드들은 안정된 저장장치에 강제 쓰기를 해야 한다. <Br>
이것은 그 페이지를 디스크에 쓰기 전에, 해당 페이지의 pageLSN과 동일한 LSN을 가진 레코드까지의 모든 레코드를 강제로 쓰면서 이루어진다. <br>
그러니까, 처음 부터 그 페이지의 마지막 수정 로그까지를 전부 강제로 쓴다는 것이다. <br> <br>

WAL은 Write Ahead Log로 매우 매우 매우 중요하다. <Br>
WAL이 각 DB 변경에 대한 로그 레코드가 장애로 부터 복구될 때 이용 가능하다는 것을 보장해준다. <Br>
Recoverability를 보장해주는 것이다. <br>
트랜잭션이 페이지의 변경을 완료했을 때, `no-force` 접근 방식은 뒤이은 장애발생 떄에 디스크에 기록되지 않을 수도 있다.
만약 장애의 원인이 되는 변경들을 기록하지 않았다면, 완료된 트랜잭션이 만든 변경을 장애로부터 보존하는 것을 보장하는 방법은 없다. <br> 

완료된 트랜잭션의 정의는 그의 모든 로그 레코드가 안정된 저장장치에 기록되었다는 것을 의미한다.  <Br>

`no-force` 방식을 사용하더라도, 트랜잭션이 완료될 때, Log Tail은 안정된 저장장치에 강제쓰기 해야한다. <Br>

반면에 force 방식이 사용된다면, 해당 트랜잭션이 수정한 모든 페이지는 트랜잭션 완료시 디스크에 강제 쓰기가 되어 있어야 한다. <br>
변경 페이지 집합은 일반적으로 Log Tail보다 훨씬 크다. 보통 갱신 로그 레코드는 변경된 바이트의 2배에 가깝고, 이 변경 부분은 당연히 페이지보다 매우 작기 때문이다. <br>
로그의 모든 쓰기는 순차 쓰기이다. Log Tail을 강제로 쓰는 비용은 모든 변경된 페이지를 디스크에 쓰는 비용보다 훨씬 작다.

# 18.5 체크포인팅
**체크포인트는 DBMS의 스냅샷과 같다.** <Br>
ARIES에서 체크포인팅은 3단계를 거친다.
1. 체크포인팅 시작시 `begin_checkpoint` 레코드가 로그에 기록됨
2. **`end_checkpoint` 레코드가 만들어지고, 트랜잭션 테이블과 Dirty Page 테이블을 레코드에 포함하고, 로그에 추가한다.**
3. `end_checkpoint` 레코드가 안정된 저장장치에 기록된 후 실행된다.


<br>

`begin_checkpoint` 로그 레코드의 LSN을 가진 master 레코드가 안정된 저장장치에 기록된다. <Br>
**이러한 종류의 체크포인트를 fuzzy checkpoint 라고 부른다.** 다른 형태의 체크포인팅과 달리, 시스템 정지나 버퍼 풀에 있는 페이지를 DB에 쓰는것을 요구하지 않아 비용이 저렴하다. <Br> <br>
시스템은 처음 시작할 때 균일성을 위해 빈 트랜잭션 테이블과 빈 Dirty Table을 갖는 체크포인트를 함으로써, 정상 실행을 시작한다. <br>
그리고 시스템이 장애 발생 이후 다시 작동될 때, 재시작 프로세스는 가장 최근의 체크포인트 레코드를 찾는다. <br>

# 18.6 시스템 장애 복구
시스템 장애 발생 후 재시작시 복구 관리기는
**ARIES(Algorithm for Recovery and Isolation Exploiting Semantics)에** 따라 3단계 과정을 통해 복구한다.

1. `분석 단계` : 버퍼 풀에서 Dirty Page들과 **장애시점에서 활동중인 트랜직션들을 식별**
2. `Redo 단계` : 로그 내의 '적당한 지점'에서 시작해 모든 액션들을 다시 적용. **DB의 상태를 장애시점의 상태로 복구**
3. `Undo 단계` : **DB에 완료된 트랜잭션들의 액션만이 반영될 수 있도록,** 완료되지 못한 트랜잭션들의 액션을 undo함

![image](https://github.com/binary-ho/spring-advanced/assets/71186266/93e2635c-ab1d-47e4-92e0-e31512f5a7a6)

<br>

`분석 단계`는 위 그림에서 LSN이 `C`로 표기된 `Most recent checkpoint` 지점, 가장 최근의 `begin_checkpoint` 레코드를 조사하는 것으로 시작해, 마지막 로그 레코드까지 로그를 조사한다. <br>
**`Redo 단계`에선 장애시점에서 Dirty였던 모든 페이지들의 변경을 redo한다.** 이러한 페이지 집합과 redo 시작점은 분석단계에서 결정되는데, 더티 페이지들 가운데 가장 적은 recLSN이 시작점으로 결정된다. (recovery LSN) <br>
~~recLSN은 페이지의 마지막으로 쓰인 로그 레코드를 가리키는 포인터이다.~~ <br> 
recLSN은 REDO 단계에서 식별된 더티 페이지에 영향을 준 첫 로그 레코드이다. <br>


그리고 `Undo 단계`는 장애시점에서의 모든 활동 트랜잭션의 변경을 undo한다. <br> <br>

**활동 트랜잭션은 분석 단계에서 식별되고,** <br> 
**redo는 변경들이 원래 실행된 순서로 적용하며,** <br> 
**undo는 가장 최근 변경을 먼저 환원하며 변경들을 역순으로 환원한다.** <br>

이 재시작의 3단계를 좀 더 자세히 살펴보자.

## 18.6.1 분석단계
분석 단계는 아래 3가지 작업을 실행하며 진행된다.

1. redo를 시작할 로그 위치를 결정한다
2. 장애시점에서의 Dirty Page들을 결정한다. 이는 버퍼 풀에 있는 변경 페이지들을 확인한다.
3. 장애시점에서 활동상태인 트랜잭션을 식별하고, undo한다.

분석단계는 첫 번째로 가장 최근의 `begin_checkpoint` 로그 레코드를 조사하고, Dirty Page Table과 트랜잭션 테이블을 다음에 나오는 `end_checkpoint` 레코드에 있는 것들의 사본으로 초기화한다. <br>

결과적으로 Dirty Page Table과 Transaction Table은 체크포인트 시점의 상태로 초기화된다. <br>

만약 begin_checkpoint와 end_checkpoint 사이에 추가된 로그 레코드들이 있다면, 두 테이블은 추가 정보를 반영한다. <br>

## 18.6.1.1 로그 검토
분석단계는 로그의 끝에 도달할 때까지 로드를 검토한다. <Br>

### 1. end log record를 만났을 떄
`end 로그 레코드`를 만나면, 트랜잭션 T는 Transaction Table에서 제거된다. T는 이미 활동 상태가 아니기 때문이다.

### 2. end가 아닌 레코드들을 만났을 때
트랜잭션 T에 대한 레코드를 만났을 때, T에 대한 엔트리가 Transaction Table에 없다면 T를 Table에 추가한다. <Br>
트랜잭션 테이블에서 T에 대한 엔트리가 아래와 같이 수정된다.

1. lastLSN 필드를 이 로그 레코드의 LSN으로 변경
2. 로그 레코드가 commit 레코드라면 상태를 C로 변경하고, 아닌 경우 U로 변경한다. <br> **U는 undo 되어야 한다는 것을 의미한다.**

<br>

**즉, End 레코드가 아니고, Commit 레코드가 아니라면 해당 로그 레코드는 undo 되어야 한다.**

### 3. 페이지 변경 레코드

페이지 P에 영향을 끼친 **redo 가능한 로그 레코드를** 만났는데, 만약 P가 Dirty Page Table에 없다면, 하나의 엔트리를 추가한다. <br> 
이 엔트리는 페이지의 id인 P와 redo 가능한 레코드의 LSN을 recLSN으로 갖는다. <br>

**이 엔트리의 recLSN은 페이지 P에 영향을 끼친 가장 최초의 변경을 식별하게 해준다.** <br>


### 18.6.1.2 분석 단계의 결과
분석단계가 끝나면 Transaction Table은 장애시점에서 활동상태에 있는 모든 트랜잭션의 정확한 리스트를 갖게 된다! <br>
이것은 상태 `U`를 갖는 트랜잭션들의 집합으로, 상태 `U`는 undo 되어야 한다는 것을 의미한다. <Br> <br>

Dirty Page Table은 장애시점에서 Dirty였던 모든 페이지를 포함하게 된다. **조심해야 할 점은 이 Table은 이미 디스크에 쓴 페이지도 포함한다는 것이다!** <br> 

(`end_write` 라는 레코드로 페이지의 "쓰임" 여부를 구분하면 좀 더 정확하게 이미 쓰인 페이지를 구분할 수도 있겠지만, ARIES에서는 이 로그를 쓰는 오버해드가 더 크다고 판단한다.) 


## 18.6.2 Redo 단계
Redo 단계동안 ARIES는 
1. 모든 트랜잭션 갱신을 다시 적용한다. (완료 미완료 전부)
2. CLR들에 기록된 undo 액션들이 다시 적용된다. <br> 
이 Repeating history (반복 적용 히스토리) 패러다임은 ARIES의 특징이다. 이 반복 적용 히스토리는 데이터베이스가 장애시점에 있었던 동일한 상태로 복구되게 한다.   <br> <br>

Redo 단계는 분석 단계에서 만들어진 Dirty Page Table에서 가장 작은 recLSN 값을 찾아, 가장 오래된 갱신 로그 레코드를 알아낸다. <br>
redo는 이 레코드 부터 로그의 끝까지 검사된다. <br>
만나는 각 redo 가능 로그 레코드는 **액션이 redo 되어야 하는지 검사된다.** <br>

아래 3가지 조건들 중 하나라도 만족하지 않으면 redo 되어야 하는 액션이다. **3가지 조건을 전부 만족하면 redo할 필요가 없다.**

1. 액션에 영향을 받은 page가 Dirty Page Table에 존재하지 않는다. -> 쓰기 완료됨
2. 액션에 영향을 받은 page가 Dirty Page Table에 존재하지만, **해당 액션 이후에도 page가 수정되는 경우 -> 해당 엔트리가 가진 recLSN이 검사중인 로그 레코드의 LSN 보다 큰 경우**
3. 액션이 page에 주는 마지막 영향이 아닌 경우 -> **이미 쓰인 페이지에 저장된 pageLSN이 검사되고 있는 로그 레코드의 LSN보다 더 크거나 같음**

<br>

위처럼 보면 너무 헷갈리고 아래를 보자
1. 이미 쓰기 완료된 페이지 -> redo 안함
2. 쓰기 완료는 안 됐지만, 이후 또 다른 액션이 페이지를 수정함 -> redo 안함
3. 지금 액션이 page의 마지막 액션이 아님 -> redo 안함. 2번이랑 같은거 아닌가?


<br>

**1번 조건은** 해당 페이지의 모든 변경이 이미 디스크에 기록되었다는 것을 의미한다. <br>
**2번 조건은** 검사되고 있는 갱신이 디스크에 정말 전파되었다는 것을 의미한다. 왜냐하면 recLSN은 디스크에 기록되지 않은 이 패이지의 첫 갱신이기 때문이다. (갱신이 정말 전파되었다 부분 헷갈린다.) <br>
**pageLSN이 더 작다면, 검사중인 액션이 디스크에 쓰여지지 않았다는 것을 알 수 있으므로 액션이 다시 적용된다.** <br>

**3번 조건은** 페이지 검색을 요구하는데, 검사되는 갱신이 이미 디스크에 쓰인 것을 보장한다! 이 갱신 또는 이후의 갱신이 디스크에 쓰여졌으니까 확인 가능한 것이기 때문이다.

<br>

## 로그에 있는 액션이 redo 되어야 하는 경우
로그에 있는 액션이 redo 되어야 한다면
1. **로그된 액션이 다시 적용된다.**
2. **페이지의 pageLSN이 redo된 로그 레코드의 LSN으로 설정된다!** (이때 추가 로그가 발생하지 않는다.)

<br>

- 더티 페이지의 최소값 LSN이 첫 로그 레코드의 LSN이다 <br> 이전의 로그들은 분명 반영 되어 있다.

### 결론적으로, 시스템을 장애시점에 있었던 정확한 상태로 복구한다.

그리고 Redo 단계의 마지막에, 상태 `C`를 갖고, Transcation Table에서 제거된 모든 트랜잭션에 대해 end 타입 레코드가 로그에 쓰인다. ??? -> 책에서는 이렇게 쓰여 있지만 사실 여부를 확인해야함 

<br>

## 18.6.3 Undo 단계

**Undo 단계의 목적은 장애시점에서 활동 상태인 모든 트랜잭션들의 액션을 undo 하는 것이다.** <br>
다른 두 단계와 달리 undo 단계는 로그의 끝에서 앞으로 검사된다. <br>

**즉, 로그의 액션들을 사실상 철회하는 것이다!** 활동 트랜잭션들은 분석단계에서 만들어진 Transaction Table에서 식별할 수 있다.

### 18.6.3.1 undo 알고리즘
분석 단계에서 만들어진 트랜잭션 테이블은 각 활동 트랜잭션의 가장 최근 로그 레코드의 LSN인 `lastLSN`을 포함한다. <br>
이런 트랜잭션들을 **상태상실 트랜잭션이라고** 부르는데, 모든 상태상실 트랜잭션들의 액션은 undo되어야 한다. (undo 되어야 하는 트랜잭션이기 때문에 상태상실 트랜잭션이라고 부른다.) <br>
이러한 액션들은 로그에서 나타나는 순서의 역순으로 undo 된다.

 <br> <br>

모~든 상태상실 트랜잭션들의 lastLSN의 집합을 `ToUndo`라고 부른다. 마치 ToDO List.. <br>

**undo 과정은 `ToUndo`가 공집합이 될 때까지, 가장 최근의 로그 부터 반복적으로 처리한다.** -> 가장 큰 LSN 값을 반복적으로 선택해 처리한다. <br>
그 과정은 아래와 같다

1. 레코드가 갱신 레코드라면, CLR이 로그에 쓰여지고, 해당 액션이 undo 된다. 그리고 갱신 로그 레코드에 있는 prevLSN이 `ToUndo`에 추가된다. -> 역추적 해서 undo 하기 위해
2. 레코드가 CLR일떄, 
  - `undoNextLSN`이 null이 아닌 경우 : `undoNextLSN` 값이 `ToUndo`에 추가됨.
  - `undoNextLSN`이 null인 경우 : 트랜잭션이 완전히 undo 되었다는 의미이므로, 해당 트랜잭션에 대한 end 레코드가 쓰여지고 CLR이 제거된다.

<br> <br>

이러한 과정들이 끝나고 ToUndo가 공집합이 되면 Undo 단계가 완료된다. 재시작은 끝났고, 시스템은 정상적으로 연산을 진행할 수 있게 된다.

### 18.6.3.2 트랜잭션 철회
트랜잭션을 철회하는 것은 ~~트랜잭션의 집합이라기 보다는~~ 하나의 트랜잭션이 undo 되는 특별한 경우이다. <br> 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/d9620b71-4590-4f7e-b097-d8710f31bfa2)

위 그림은 이 점을 잘 설명하고 있다. <br>
다음 절을 참고해보자.

### 18.6.3.3 재시작 동안의 장애 상황

undo 알고리즘이 어떻게 반복되는 시스템 장애를 다루는가를 이해하는 것은 중요하다. <br>
갱신로그 레코드에 기록된 액션이 정확히 어떻게 undo 되는지의 예시와 함께 이해하자. <br>
이 예는 트랜잭션을 철회하는 것이 undo의 특별한 경우이고, CLR의 사용이 갱신로그 레코드의 undo 액션을 두번 적용하지 않도록 돕는다는 것을 알 수 있다. <br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/d9620b71-4590-4f7e-b097-d8710f31bfa2)


<br>

1. 로그에서 LSN은 증가하는 순서로 있다. 
2. 한 트랜잭션에 대한 각 로그 레코드는 이전 로그 레코드를 가리키는 prevLSN 필드를 가지고 있다. 
3. (첫 로그 레코드의 prevLSN 필드의 null은 생략)
4. (콤마로 구분한건 두 로그를 합친 것이다.)


### Point 1. LSN 30번 로그 철회
LSN 30번 로그 레코드는 T1이 철회한다는 것을 가리킨다. `T1 abort` <br> 

이때 모든 액션들은 역순으로 undo 되어야 하는데, T1의 액션은 `10번 update` 뿐이다. <Br>

그래서 40번을 보면 `Undo T1 LSN 10` 이라고 적혀 있다. <br>
이후 `45번 T1 종료`가 진행되었다.




### Point 2. 첫 장애 (첫 X)

첫 장애가 발생하면, 분석단계가 시작된다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/7853f999-c6f0-4b69-b9db-06e494eb0fec)


**[분석 단계]**
1. `더티 테이블 식별` : 빨간 네모들이 `update` 작업들인데 P1, P3, P5를 더티 페이지로 식별한다. <br> 각 페이지는 recLSN을 50번, 20번, 10번으로 갖는다. P5는 두 트랜잭션에 의해 두 번 수정되었는데, 첫 변화는 10번이므로, recLSN이 10번이다.
2. `트랜잭션 테이블 식별` : T1은 abort 되었으므로 **T2와 T3가 활동 트랜잭션으로 식별된다.** <br> T2는 lastLSN을 60번으로, T3는 lastLSN을 50번으로 갖는다.

**[Redo 단계]** <br>
Redo 단계는 맨 앞 레코드인 10번 로그 레코드를 들고 시작한다. <br> 
-> 왜냐하면, 10번이 더티 테이블에서 식별해낸 페이지 중 첫 recLSN이기 때문이다. <Br>
더티 테이블엔 현재 P1, P3, P5가 있는데 - P5가 recLSN이 10번으로 가장 처음 등장한다. <br>

18.6.2 절의 Redo 알고리즘에 따라 갱신과 CLR 레코드들에 대한 액션들이 다시 적용된다.


**[Undo 단계]** <br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/65e21384-002b-475b-8abb-ae6fe6a90fa2)


ToUndo 집합은 `T2 - LSN 60번`과 `T3 - LSN 50`으로 이루어져 있다. <br>
ToUndo 집합에서 Undo를 위해 가장 큰 LSN을 찾는데, `T2의 60번 로그 레코드`이므로, Undo한다 **이렇게 70번 CLR이 쓰이게 된다.** <br>



![image](https://github.com/binary-ho/TIL-public/assets/71186266/1b76bbe9-b555-4b27-a94d-8c58266a2218)

<br>

**로그 레코드 60이 prevLSN으로 20번 레코드를 갖으므로, 70번 CLR은 undoNextLSN의 값으로 20번 레코드를 갖는다.** LSN 20번 레코드는 트랜잭션 **T2에 대해 undo되는 다음 액션이다.** <br> <Br> <br>

이제 ToUndo 집합에 남아있는 LSN은 50번이다. <br> 
50번 로그 레코드 또한 Undo되고 LSN 80번을 가진 CLR이 기록된다. 이때, 트랜잭션 T3은 더이상 Undo할 액션이 없으므로, **undoNextLSN 필드는 Null이 된다.** T3은 완전히 undo되고, end 레코드가 로그에 쓰이게 된다. <br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/1f299a12-adfa-4b93-ae44-c384d01f0c48)

로그 레코드 70, 80, 85는 시스템이 두 번째 장애가 발생하기 전에 안정된 저장장치에 쓰여진다. **물론, 로그 레코드만 기록되었다는 이야기이지, 이 로그들이 나타내는 변화 자체는 디스크에 쓰여지지 않았을 수도 있다.** <br>


### Point 3. 두 번째 장애 발생
두 번째 장애 발생 이후 다시 복구 과정이 처음 부터 재개된다. <br>
단, 활동 트랜잭션 테이블엔 T3가 끝남으로써 제외됐다.

**[분석 단계]** <br>
1. `더티 페이지 테이블` : 이전과 동일하다.  
2. `활동 트랜잭션 테이블` : 유일한 활동 트랜잭션은 T2이다. T3은 이전 과정에서 완전히 Undo되었기 때문이다.

<br>

**[Redo 단계]** <br>
**Redo 단계는 LSN 10 부터 85 사이 레코드를 전부 다시 처리한다.** <br> 
**단, 이전의 Redo 동안 디스크에 쓰인 변경이 있다면 다시 쓰는 것을 피하는데, 이때 pageLSN을 활용한다.** <br> <br>

**[Undo 단계]**

<br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/e7418150-a9e8-4b5a-87ef-bc4afe779630)


ToUndo 집합의 유일한 LSN인 70을 고려해 undoNextLSN 값 20을 더해 90번으로 Undo를 처리한다. <br>
남은 Undo는 LSN 20번이 준 `T2 updaate P3`이다. 이 변화를 Undo하고 CLR을 LSN 90번으로 로그에 쓰여진다. <br>
LSN 20은 T2의 첫 로그 레코드이고, 첫 레코드가 Undo 되었으니, 90번 CLR의 undoNextLSN은 Null이다. <br>
이제 T2도 end 레코드가 쓰이게 된다. (LSN 95번) <br> <br>

**이제 ToUndo 집합이 공집합이 되어 undo가 끝나게 된다.** 이제 복구가 완료되었고, 체크포인트 레코드를 로그에 쓰고, 정상 실행을 재개할 수 있다! <br>

### Undo 단계 외의 단계에서 장애가 발생하는 경우
위 예시는 undo 단계에서 장애가 발생하는 경우에 대한 예시였다. 다른 단계에서 장애가 발생한다면 어떻게 처리될까? <br>

1. 분석 단계 : 이루어진 모든 분석이 상실된다. 
2. Redo 단계 : Redo동안 일어난 몇몇 변경이 장애 전에 디스크에 이미 쓰여질 수 있다. 첫 번째 재시작 떄 redo된 몇몇 갱신 로그 레코드들의 LSN이 pageLSN과 동일하다면 두번째 재시작시 Redo되지 않는다. 


장애가 발생하는 경우 반복되는 작업을 최소화 하기 위해 재시작동안 체크포인팅도 할 수 있다. (논의하지 않음)

## Reference
- Database Management Systems <Raghu Ramkrishnan 저>
