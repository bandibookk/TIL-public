# 11. 해시 기반 인덱싱
해시 기반 인덱싱은 등호 셀렉션에 우수하고, 범위 셀렉션에 약하다. <br>
범위 내의 모든 값들이 각자 해싱 되어버리니.. 사실상 범위 내의 값들을 하나 하나 또 해싱해서 가져와야한다. 이렇게 범위 탐색에 취약한 덕분에, 대부분의 상용 DBMS에서는 B+Tree 기반 인덱싱을 선호한다. <br>
그래도 해시 기반 인덱싱은 조인과 같은 관계형 연산을 구현하는데 아주 효과적인 것으로 판명 되었다. <br> <br>

인덱싱을 해싱을 통해 나타내는 방식 중 3가지 방식을 살펴보자. <br>
기본 해싱인 **정적 해싱은** 부터, 정적 해싱이 가지는 긴 오버 플로우 페이지 문제를 해결하기 위한 **확장성 해싱** 기법과, 확장성 해싱에서의 디렉토리 구조를 사용하지 않고도 구현될 수 있는 **선형 해싱** 기법을 살펴보자. 선형 해싱은 디렉토리가 없어도 되는 대신에 길어봐야 2정도의 오버플로우 체인을 허용한다.


## 11.1 정적 해싱
![정적 해싱](https://user-images.githubusercontent.com/71186266/205926293-021922de-61eb-41c8-ac57-53654f4458f8.png)


정적해싱은 평범한 해싱 기법이다. <br>
한 버켓당 하나의 기본 페이지를 갖는다. key값을 해싱하여 버켓을 식별하고, 그 버켓을 탐색해서 엔트리를 찾는다. <br>
새로운 엔트리를 넣을 때, 어떤 버켓에 공간이 없다면, 오버플로우 페이지를 할당하고, 그 안에 엔트리를 삽입한다. 이후 오버플로우 체인을 연결해준다. <br>
우리가 평소에 생각하는 해싱과 동일한 방법인 것이다. <br> <br>

**정적 해싱의 가장 큰 문제점은 버켓의 수가 고정되어 있으면서 발생한다.** 이로 인해, 파일이 축소되면 축소되는 대로 많은 공간이 낭비되게 되고, 확장되면 확장되는 대로 **긴 오버플로우 체인이 형성되어 성능이 저하될 수 있다.** <br>
이러한 정적 해싱의 문제점에 대한 대안으로 주기적으로 파일을 다시 해싱하는 것이 있다. 그러나 이런 식으로 구현하면 당연히 다시 해싱하는 시간 소요도 문제고, **진행되는 동안 인덱스를 이용할 수 없다.** <br> <br>

이런 문제점들을 해결하기 위해, **동적 해싱 기법들이 제안된다.** <Br>
바로 **확장성 해싱과, 선형 해싱이다.**


## 11.2 확장성 해싱

![확1](https://user-images.githubusercontent.com/71186266/205926296-3cd74d91-b440-428e-a5dc-37bfc6b0ca11.png)


확장성 해싱은 버켓을 가리키는 포인터를 가진 자료구조 **Directory를 사용한다.** 이 디렉토리는 각각의 버켓을 가리키고 있고, 버켓에 데이터가 채워지게 된다. <br>

현재 그림과 같이 버켓은 하위 2비트를 통해 버킷을 인식한다. 디렉토리에 있는 이 변수를 Global Depth - 전역 깊이라고 하고, 각 버켓들에 할당된 변수를 Local Depth - 지역 깊이라고 한다. 이 depth 값을 통해 각 key값들은 해싱 이후 자신이 들어갈 위치를 찾아낸다. <br> <br>

### 버켓이 꽉차게 된 경우

![확2](https://user-images.githubusercontent.com/71186266/205926301-d189e333-0c3c-4171-9460-4e3eeb08fe7a.png)

만약 버켓이 꽉차게 된 경우! **디렉토리 크기를 2배 늘리고, 버켓 페이지 하나를 더 할당하여 꽉찬 버킷을 2개로 분할해준다!!** <br>
디렉토리가 2배 늘어난 만큼 **Global Depth의 값은 1 늘어난다. 이제 하위 2비트를 처리하던 디렉토리는 3비트를 처리할 수 있음을 표시한 것이다.** <br>


그림을 보면 분할된 버켓 외에는 분할되지 않았고, **분할되지 않은 버켓들은 디렉토리의 2개의 포인터가 가리킨다.** <br> 그리고 잘 보면 분할된 버켓들은 local depth가 늘어 글로벌 depth와 같은 값을 가지게 되었지만, 분할되지 않은 값들은 local depth가 그대로이다. <br>
이는 여전히 **하위 2 비트로 식별됨을 가리킨다.** <br>
실제로 계산하면서 생각해보자. 분할된 000과 100은 0과 4로, 8로 나누었을 때 나머지가 0인 것은 000에, 4인 것은 100에 들어가게 되었다. <br>
그리고 분할되지 않은 버켓들은 여전히 해싱 과정에서 8이 아닌 4로 키를 나눈다. **굳이 나눠질 필요 없이 이렇게 아름답게 구현이 가능하다.** <br> <Br>

**모든 버킷 분할에 대해 디렉토리가 2배가 되는 것은 아니다!** 그 기준은 어떻게 될까. <br>
**분할되는 버킷의 Local Depth가 Global Depth와 같을 때만, 추가적으로 디렉토리가 2배 늘어난다.** **자연스럽게 글로벌 딥스와 로컬 딥스도 1 늘어나게 된다.** 굳이 그림으로 따지자면, 포인터 1개만이 가리키고 있는 버킷이 분할될 때, 디렉토리가 늘어난다. 여유 포인터가 있는 경우 굳이 디렉토리를 늘려줄 필요는 없다. <br>
이는 직접 생각해보면 너무나 타당하다. <br> <br>

확상성 해싱은 위와 같이 해시 함수 h를 적용한 결과를 이진수로 취급하고, 그것의 마지막 d 비트를 (depth) 디렉토리의 오프셋으로 해석한다. <br> <br>



## 11.3 선형 해싱
교재나 인터넷의 설명들이 불친절해서 이해가 너무 어려웠다. <br>
선형 해싱은 디렉토리 없이도 구현되는 동적 해싱으로, 대신에 어느 정도의 오버플로우 체인을 감수한다. (버켓 분할 시기를 조금 여유롭게 잡는다.) <br>
단점으로는 데이터가 많이 편중된 경우 오버플로우 체인으로 인해 확장성 해싱보다 조금 성능이 떨어질 수 있다. 단점은 이 정도만 알고 있자 <br> <br>


### 해싱 함수군
선형 해싱은 해싱 함수군 h0, h1, h2 ... 을 사용한다. 만약 hi가 M개의 버킷 중 하나로 데이터를 매핑시킨다면, hi+1은 2*M개의 버킷 중 하나에 데이터 엔트리를 매핑시킨다. <br>
말이 어려운데 예시를 보면 쉽다. h2가 결과를 2로 나눈 값의 나머지를 해싱값으로 갖는다고 하면, h3은 그냥 4로 나눈 것이다. <br>
위의 디렉토리 확장 과정을 보고 왔으면 내가 풀어 설명한 부분이 그리 어렵지 않을 것이다. 그냥 이진수 mod 해싱에 대해 *2를 계~속 해주면서 hi, hi+1 ... 이렇게 나아간다는 것이다. <br> <br>


### 기본 아이디어

기본 아이디어는 여러 라운드에 거친 분할이라고 생각하면 가장 잘 이해가 간다고 한다. (아니다.) <br>
Level 번째 라운드 동안 해시함수 h_level과 h_(level+1)이 사용된다고 한다. 라운드의 시작에서 버켓들은 첫 버켓 부터 마지막 버켓까지 차례대로 분할되어 결국 버켓의 수가 2배가 된다. 결국 그림과 같이 한 라운드의 어느 시점에서 보면 이미 분할된 버켓, 분할될 버켓, 이번 라운드 분할에 의해 생긴 버켓들이 존재하게 된다. (-책에서 발췌한 설명을 풀어 씀) <br> <Br>

![선형 1](https://user-images.githubusercontent.com/71186266/205926286-8bbcfaef-a6ff-4a2f-9fc5-80275eef83b2.png)

너무 말을 어렵게 해 놓았는데, 최대한 쉽게 설명해보겠다. <br>
일단 첫 버켓 부터 마지막 버켓까지 분할된다는 말을 생각해보자. 간단히 생각해보기 위해 그림의 왼쪽 부분을 보자. <br>
4개의 버킷에 대해, 분할이 필요할 경우 정말 물리적으로 **위에서 부터 순서대로 하나씩 분리해낸다.** 그러니까 **어떤 버켓이 꽉차든지 간에** 이번 라운드 에서는 00 부터 분할하고, 또 분할이 필요하면 01, 또 필요하면 10, 다음엔 11 이렇게 분할하자는 것이 **`첫 버켓 부터 마지막 버켓까지 차례대로 분할한다`는 말의 의미이다.** <Br>
왜 이렇게 분할하는지 잘 안 와닿을 것이다. 분할이 필요한 버켓을 분할하는게 아니라, **그냥 현재 분할될 순서인 버킷이 분할된다.** 이는 아직 설명이 안 되어서 이다. 차차 설명하겠다. <br>
어찌됐든 이런 분할을 00 부터 11까지 전부 마치게 되면, 버킷은 당연히 8개가 될 것이다. 이것이 위에서 말한 **`한 라운드의 분할이 끝나면 버켓이 2배가 된다`는 말의 의미이다.** <Br>
그러면 한 라운드의 중간을 생각해보자. 예를 들어 00을 분할하고, 01을 분할한 상황을 생각해보자. 그러면 마지막 문장 `한 라운드의 어느 시점에서 보면 이미 분할된 버켓, 분할될 버켓, 이번 라운드 분할에 의해 생긴 버켓들이 존재하게 된다.`의 의미가 이해가 된다. 
마지막 문장은 이렇게 생각하면 된다. <br> 
그런데 조금 이상하다. 분할 기준이 얼마나 꽉찼느냐가 아니고, 단순히 '순서대로' **라운드 로빈** 방식이라면, 그냥 별로 차지도 않은 버켓을 분할하고 그런다는 것이지 않나? <br>
맞다. 그럼 **분할이 필요한 경우는 어떻게 정하나?** 오히려 선형 해싱에서는 마음대로 설정할 수 있다. 오버플로우 페이지가 추가 될 때, 공간 활용도가 일정 퍼센테이지를 넘어갈 때 등 마음대로 설정이 가능하다. <br>


### 어떻게 분할이 이루어 진다는 거야
어떻게 분할이 이루어 진다는 걸까.. <br>
그저 순서대로 분할 되는 것이 나빠 보일 수 있다. 하지만 00, 01, 10, 11의 경우를 생각해보자... 그림의 예시는 왼쪽 그림에서 엔트리 43*이 추가되는 상황이다 <br>

당연히 오버플로우 페이지는 4로 나눈 값의 나머지인 11 버켓에 할당된다. <br>
하지만, Next로 표시된 분할 될 차례인 버킷은 0번이기 때문에, 0번을 분할한다. <br>
**이 때, 앞에서 부터 차례대로 버킷을 분할하는 것과 같이 차례대로 뒤에 버킷이 늘어난다.** 무슨 말이냐면 분할 전 마지막 버켓은 해싱값 11에 대응된다. 그 다음 숫자는 무엇인가? 100이다. **그러니까 다음 버켓은 100에 대응되도록 만들어 준다.** <br> 
**그럼 자연스럽게 가장 처음으로 나눠질 00을 나눌 수 있다. 왜냐하면 둘 다 4의 mod 연산에 대해 나머지가 0이기 때문이다. 이제 다음 해시 함수인 8 mod를 써서, 나머지가 0인 경우 그대로 000에, 4인 경우 100에 넣어줌으로써 아름답게 분할되는 것이다!!** <br> <br>

이제 순서대로 분할되는게 그리 나쁘지 않은 것을 알 수 있을 것이다. **순서대로 분할되어도, 그리 많은 오버플로우 페이지가 생성되지 않는다.** <br>


이런 식으로 분할되기 때문에, 많은 편중이 있을 경우 성능이 확장 해싱 보다는 떨어질 수 있다는 것이다. <br>
분할되는 예시를 360p에서 더 살펴보면 좋을 것 같다.


## 11.4 확장성 해싱, 선형 해싱 비교
둘은 해시 함수의 선택에서 매우 비슷하다. 선형 해싱에서 h가 2배씩 커지는 것은 디렉토리가 2배 늘어날 떄의 상황과 동일하다. <br>
확장형 해싱과 다른 점이 무엇일까? <br> 
선형 해싱에서 제시된 근본적인 새로운 아이디어는, **분할할 버켓을 '잘' 선택하면, 디렉토리라는 자료구조가 필요 없다는 것이다!** <br>
반면에 **확장성 해싱은 항상 적합한 버켓을 분할하므로! <U>분할 횟수를 줄이고,</U> <U>버켓의 적재율을 높일 수 있다!</U>** <br> <Br>

성능적인 측면에서는 <Br> 
**균등한 분포의 경우 선형 해싱이 디렉토리가 없어서 평균 비용이 낮고,** <br> 
**편중된 경우 높은 적재율을 가진 확상성 해싱이 나은 성능을 보인다!**


## Reference
- Fundamentals of Data Structures in C++ \<HOROWITZ, SAHNI, MEHTA 저>
- [UHCL 36a Graduate Database Course - Linear Hashing - Part 1](https://www.youtube.com/watch?v=Yw1ts57uL7c)
