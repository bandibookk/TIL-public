# DBMS는 어떻게 트랜잭션을 관리할까?
# 1. 트랜잭션이란?

**트랜잭션은 하나의 논리적 작업 단위를 구성하는 연산들의 집합이다.** <br>
트랜잭션은 ACID 성질로 설명될 수 있다.
- `Atomicity` : atomicity는 쉽게 'all or nothing' 특성으로 설명된다. 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.
- `Consistency` : 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 
- `Isolation` : 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. isolation 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다. Isolation 성질을 보장할 수 있는 가장 쉬운 방법은 모든 트랜잭션을 순차적으로 수행하는 것이지만, 요즘 같은 세상에 얼마나 손해인가. 병렬적 수행의 장점을 얻기 위해서 DBMS는 병렬적으로 수행하면서도 serial한 수행과 같은 결과를 보장할 수 있는 방식을 제공한다.
- `Durability` : 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.


<br>

# 2. 트랜잭션 관리를 위한 DBMS의 전략
DBMS는 보통 비휘발성 저장 장치인 디스크에 데이터를 저장한다. <br>
전체 DB의 일부분을 메인 메모리에 유지한다. <br> 
데이터를 고정 길이 Page로 저장하고, 디스크에서 읽거나 쓸 때 페이지 단위로 입출력이 이루어진다. <br>
메인 메모리에 유지하는 페이지들을 관리하는 모듈을 보통 Page Buffer, 관리지, 버퍼 관리자 등으로 부른다. <br>


## 2.1 UNDO는 왜 필요할까?
아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있기 때문에, <br>
만약 해당 트랜잭션이 비정상적으로 종료되면 트랜잭션이 변경한 페이지들은 원상 복구 되어야 한다. <br>
이러한 복구를 UNDO라고 한다. <br>
만약 트랜잭션 종료 전 수정된 페이지를 디스크에 쓰지 않는다면 UNDO는 메모리 버퍼에만 해주면 되는데... <br>
그렇지 않죠? 왜냐면 `STEAL` 정책을 사용중이기 때문이다.

- `STEAL` : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책 
- `NOT STEAL` : 수정된 페이지들을 최소한 트랜잭션 종료 시점 (EOT, End of Transaction)까지는 버퍼에 유지하는 정책

**STEAL은 언제든 디스크에 Drity Page가 쓰일 수 있으니까 필연적으로 로깅과 복구를 수반한다.** <br>

## 2.2 REDO는 왜 필요할까?
**Durabilty! 커밋한 트랜잭션의 수정은 어떤 경우에도 유지되어야 한다.** <br>
이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업을 REDO 복구라고 하는데.. <br>

트랜잭션이 종료되는 시점에, 해당 트랜잭션이 수정한 페이지들을 디스크에 쓸 것인가 여부로 두 가지 정책이 있고, <Br>
정책에 따라 REDO 복구의 필요성이 결정된다.

- `FORCE` : 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책
- `¬FORCE` : 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책


`FORCE` 정책을 따르면, 트랜잭션이 커밋되면 Dirty Page들이 디스크상의 DB에 반영되었으므로, REDO가 필요없다. <br> 
`NO FORCE`를 따르면 트랜잭션이 커밋됐다고 해서 내용이 DB상 반영되어 있지 않을 수 있으므로 REDO 복구가 필요하다. <br> 

(사실 FORCE 정책을 따르더라도 media(미디어) 복구시엔 REDO 복구가 요구된다.)


## 결론! REDO, UNDO 왜 필요한가?

`STEAL`, `NO FORCE`라서 <br>
Dirty Page가 언제든 디스크에 쓰일 수 있는 `STEAL` 정책과 <br>
Dirty Page를 트랜잭션 커밋 시점이 아닐때 디스크에 반영하는 `NO FORCE` 정책을 사용하기 떄문 <br>


# 3. 트랜잭션 관리 - 로그
로그는 stable storage에 기록된다. <br>
실제로는 없어서 뭐 여러 벌의 로그를 유지하는 등 한다. <Br>
보통은 성능상의 이유로 하나의 로그를 유지한다. <br>

로그는 덧붙이는 방식으로 기록되고 Log Sequence Number (LSN)이라는 고유 식별자를 갖는다. <br>
기록할 오브젝트의 타입에 따라 물리적/논리적 로깅으로 분류되고, <br>
DB의 상태 또는 변화를 야기한 전이를 기록하느냐에 따라 분류할 수 있다.

- 논리적 로깅 : `Transition - 액션(DML문, DDL문)`
- 물리적 로깅 : `State - 이전 이미지, 이후 이미지`, `Transition XOR 차이`
## 3.1 물리적 상태 로깅 (physical state logging)

- UNDO : 이전 이미지로 현재 이미지를 대체
- REDO : 이후 이미지를 반영

물리적 상태 로깅은 때로는 페이지 수준(예를 들어, 인덱스나 데이터 파일의 헤더 페이지의 변경 로깅)에서 이루어지기도 하고, 레코드 수준에서 이루어지기도 한다. <br>

물리적 상태 로깅은 페이지 수준, (인덱스나 데이터 파일의 헤더 페이지 변경 로직) 혹은 레코드 수준에서 이뤄지기도 한다.

## 3.2 물리적인 전이 로깅(physical transition logging)
**이전 및 이후 이미지를 모두 기록하기 보다는 <br> XOR 차이점을 기록하는 방식으로 이루어진다.** <Br>
복구 시점에서 로그 레코드에 기록된 XOR 이미지와 레코드 이미지를 이용하여 UNDO 복구와 REDO 복구를 수행하게 된다

## 3.3 논리적인 전이 로깅(logical transition logging)
논리적인 로깅은 어떤 일이 일어났는지 기록하는 것이다. <br>
예를 들어, `a = a + 1`과 같은 연산을 로깅할 때 `a = a + 1` 이라는 연산 그 자체를 기록할 수 있다. <br>

REDO를 위해 로그 레코드에 기록된 오퍼레이션을 재수행하거나, <br>
UNDO를 위해 역 오퍼레이션을 수행하는 방식으로 이루어진다. <br>
논리적 전이 로깅은 로그 레코드의 크기를 크게 줄여주소, 물리적으로 복구하기 쉽지 않은 자료 구조의 로깅을 쉽게 해준다. <Br>
어려운 인덱스 구조인 B+-Tree나 B-tree는 Split, Merge와 같은 SMO(Structure Modification Operation)을 통해 레코드의 위치가 계쏙 변하는데, <br>
로깅 시점과 복구 시점의 데이터의 물리적 위치가 같다는 것이 보장되지 않는다. 페이지 내의 위치가 다를 수도 있고, 아예 다른 페이지에 위치할 수도 있다. <br>
이런 이유로 물리적 로그를 통해 복구하기가 쉽지 않고, **논리적인 로그를 사용하면 아주 쉽다!** <br>
예를 들어 엔트리의 삽입 연산에 대해 REDO는 다시 삽입하고, UNDO는 제거하면 그만이다. <br>


## 3.4 DBMS 제품은 이 중 어떤 방법을 택했을까
하나만을 선택하여 사용하지 않고, 적절하게 혼용하여 사용한다. <br>


## 3.5 UNDO 복구와, REDO 복구의 멱등성

로그를 통한 UNDO 복구, REDO 복구는 멱등성(idempotent)을 가져야 한다. <br> 
멱등성은 여러 번 수행하더라도 한 번 수행한 결과와 같아야 한다는 것을 의미하는데, 예를 들어 어떤 숫자에 계속 1을 곱하거나, 절댓값 연산을 한다면 계속해서 같은 결과가 나오게 된다. <br>

물리적인 로그야 멱등성을 가지기 쉽다. 그냥 이미지를 대체하는 것이니까? <br>
논리적인 로그는 다르다. 상태를 바꾸기 위해 연산을 수행하기 때문에, 정확하지 않게 복구될 수도 있다. 그러므로 한번 수행된 복구 연산은 또 다시 수행되지 않도록 항상 주의해야 한다. <br>
그 방법은.. 더 아래 나온다고 한다.


## 4. 로그는 어떻게 쓸까?
로그의 타입에 관계없이 아래의 규칙에 의해 쓰인다.


1. **업데이트가 DB에 써지기 전에 먼저 UNDO 정보가 로그에 써져야 한다.** 이를 WAL(Write Aheda Logging) 이라고 한다. 그래야 UNDO하지 ㅇㅇ
2. **REDO 로그는 적어도 커밋 시점에는 써져야 한다.** <br> 트랜잭션이 정상적으로 종료 처리되기 위해선, **먼저 REDO 정보가 로그에 써져야 한다.** 그래야 장애 상황에서 트랜잭션을 재현하지.


## 4.1 로그 버퍼
DBMS는 로그 레코드를 위해 로그 버퍼를 유지한다. <br>
성능릉 위해 로그 버퍼에 로그 레코드를 모았다가 블록 단위로 로그 파일에 출력한다. <br> <Br>

로그 버퍼에 유지된 로그 레코드는 아래의 4가지 경우에 로그 파일에 출력된다.

1. 어떤 트랜잭션이 커밋을 요청한 경우 
2. WAL을 해야 하는 경우 (Update가 DB에 써지기 전)
3. 로그 버퍼가 다 소진된 경우
4. `체크 포인트(checkpoint) 연산`이나 `로그 관리 연산`에 의해 DBMS가 내부적으로 로그 파일에 쓸 것을 필요로 하는 경우


<br>

대부분의 경우 1, 2번 케이스로 인해 로그가 써진다. <br>
로그 버퍼는 대개 수MB에서 수십MB 수준으로 상대적으로 작기 때문에, 긴 트랜잭션이 수행중인 경우엔 3번과 같이 로그 버퍼가 소진될 때도 있다. <br>
1번 케이스인 어떤 트랜잭션이 커밋을 요청한 경우, 어떤 트랜잭션이 커밋을 요청한다면, 해당 트랜잭션의 마지막 로그 레코드까지 출력된다.


## 4.2 로그를 쓰는 일은 왜 느린가?
로그 레코드의 손실은 DB를 완전히 복구될 수 없게 만들기 때문에, 로그 레코드를 안전하게 쓰는 것은 정말 중요하다. <br>
DBMS는 최대한 안전하게 로그를 쓰기 위해, Write 함수 호출 외에도 리눅스 `fsync` 함수를 호출하는데, `fsync`는 변경 내용을 하드 디스크에 저장되도록 요청하는 역할을 한다. <br>
문제는 `fsync`가 디스크에 물리적으로 써지는 것을 보장하지는 않는다. (대부분의 OS에서) <br> 

`fsync`는 느리고, 커밋을 위해서는 일단 해당 트랜잭션의 로그가 로그 파일에 쓰기긴 해야하니까, **결국 커밋을 하려는 트랜잭션은 `fsync`의 종료를 기다려야만 한다.** <br>

로그 헤더 정보??
대충 순서도 뒤죽박죽이고 순서의 정확성을 위해 `fsync`를 여러번 호출해야 한다는 이야기 (로깅을 위해 여러번의 디스크 출력 필요)


## 4.3 로그 쓰기 작업의 (커밋 오퍼레이션) 성능을 높일 방법
### 4.3.1 그룹 커밋
쌓아놓고 커밋해서 디스크 출력 횟수를 줄임. <Br>
트랜잭션 응답시간은(response time)은 약간 희생해도 전체 처리량(throughput) <br>
한계 시점 이전까지는 동시 커밋 요구가 많을 수록 그 효율이 높아진다. 때문에 적절한 커밋 대기 시간을 정하는 것이 중요 <br>
보통 몇 밀리초에서 수백 밀리초

### 4.3.2 성능을 위해서 지속성을 살짝 포기
커밋 성능을 극대화 하기 위해 지속성을 일부 포기할 수도 있다. <Br>
`InnoDB`는 `innodb_flush_log_at_trx_commit` 파라미터의 설정을 통해 좀 더 느슨하게 로그를 쓰는 옵션도 제공한다. <br> <Br>

그리고 시스템이나 앱에 따라 `비동기 커밋 (asynchronous commit)`을 사용하기도 하는데, **로그 버퍼에 로그 레코드를 쓰고 곧바로 커밋을 완료하는 방법이다.** <br>
로그 파일에 로그가 써질 떄까지 대기하지 않고 그냥 커밋해버린다 ㅇㅇ <br>
로그 레코드는 로그 Write 쓰레드가 이후에 비동기적으로 Write하게 된다. (대개는 매우 짧은 시간 내 곧바로) <br>
만약 트랜잭션의 로그가 미처 써지기 전에 시스템 장애가 발생한다면 커밋은 완료됐지만 손실될 수도 있다. <br>
이는 트랜잭션이 변경한 데이터의 loss가 된다. <br> 
이 때에도 데이터의 일관성은 보장되는데, <br>
**사실상 최근 몇 트랜잭션의 커밋 로그가 loss 된 것이니, 복구 시점에 DBMS는 마치 해당 트랜잭션이 커밋을 하지 않은 것으로 간주하고 Rollback 해버린다.**  <br>


철회를 위한 UNDO 로그는 이미 트랜잭션 중 WAL에 의해 쓰여있기 때문에, 커밋되지 않은 데이터가 DB에 반영되지는 않는다. <br>
**비동기 커밋은 성능 향상 효과가 크다. 그대신 loss가 발생할 수 있으므로 데이터의 정확성 보다 성능이 중요한 경우 좋지 못한 선택일 수 있다.** <br>

# 5. 로그 복구가 이루어지는 방법

복구에는 두 가지 종류가 있는데, 
1. 사용자의 요청 or 오류 발생 등으로 인해 시스템이 트랜잭션을 철회하는 경우
2. 소프트웨어 문제나 하드웨어 문제 등으로 인해서 장애가 발생하고, <br> 데이터베이스 시스템이 Restart Recovery(재시작 복구) 하는 경우

## 5.1 트랜잭션 철회 Rollback
시스템 자체는 정상적으로 수행되고 있고, 특정 트랜잭션만 철회되는 경우 <br>
1. 로그를 역방향으로 탐색하며 해당 트랜잭션의 UNDO 복구가 필요한 로그를 찾아 UNDO
2. UNDO 수행 이후 CLR (Compensation Log Record)를 쓴다. <br> **이 CLR는 REDO 전용 로그이다.** <br> CLR은 이전 로그 레코드 위치를 UNDO 로그 이전 로그를 가리키도록 함으로써, **한번 UNDO된 로그를 다시 접근해 UNDO 하지 않게 돕는다.** 
3. 트랜잭션의 시작 로그까지 도달하면 철회 복구가 완료됨


## 5.2 장애로 인해 재시작 Rollback
장애 발생 이후의 재시작 복구는 3단계로 나누어져 있다.

## 5.2.1 장애로 인한 재시작 복구 3단계
## 1단계 : 로그 분석 단계
1단계는 로그 분석 단계이다. <Br>
마지막 체크 포인트 시점부터 최근 로그 (End Of Log, EOL)까지 로그를 탐색하며, 어디서 부터 시스템이 복구를 시작해야 하는지, 또 어느 트랜잭션들을 복구해야 하는지 등등을 알아내는 단계이다. <br>
DB책에서 봤던 내용인데, Dirty Table과 활동 트랜잭션을 확인하는 부분

## 2단계 : REDO 복구 단계
REDO 복구 단계는 Repeating History 작업을 하는 단계로, **이전 상황을 그대로 재현해 복원한다.** <br>

복구를 시작해야 하는 시점부터 ~~ 장애 발생 직전 시점까지 REDO가 필요한 모든 로그를 REDO 복구하는 단계 <Br>
**이 단계에서는 실패한 트랜잭션도 REDO하는데, 이후 복구 단계를 매우 간단하게 하는 효과를 준다.** (언뜻 보면 불필요한 것으로 보일 수 있다.) <br>
이 단계에서는 모든 트랜잭션에 대해 REDO 복구만 한다. <br>
**결과적으로 REDO 복구가 완료된 시점의 DB 상태는 장애 발생 시점의 상태와 같아진다.**


## 3단계 : UNDO 복구 단계
로그를 최신 시점부터 다시 역방향으로 탐색하며 UNDO 복구가 필요한 로그들에 대해 UNDO 복구를 수행한다. <br>
이전 단계로 DB상태를 장애 시점까지 복원했고, UNDO 복구를 여러 트랜잭션의 철회로 간단하게 해결할 수 있다. <br>
5.1의 개별 트랜잭션의 UNDO와 구분해 `Global UNDO`라고 부른다. (여기선 여러개가 철회될 수 있으니까)

## 5.2.2 복구의 필요성을 판단하는 기준
UNDO나 REDO 로그의 필요성을 판단하는 기준이 있을까? **pageLSN을 이용하자.** <br>
데이터베이스의 모든 페이지는 pageLSN이 있는데, 이는 **각 페이지를 마지막으로 수정시킨 로그의 LSN을 저장한 것이다.** <br>

그러니까 페이지가 갱신되는 경우 해당 로그의 LSN으로 갱신된다. <br>
1. `pageLSN이 어떤 로그의 LSN 보다 예전 것인 경우` : **아직 반영되지 않았다는 이야기!!** <br> **해당 페이지는 해당 로그로 복구되어야함.**
2. `pageLSN이 어떤 로그의 LSN과 같거나 더 최신의 값을 가짐` : **더 뒤에도 변화가 있다는 이야기** 혹은 해당 로그가 마지막으로 반영된 로그라는 이야기. <br> **복구가 필요하지 않다는 것을 의미** (해당 로그보다 나중에 쓰인 로그로 이미 갱신됨)

<br> <br>

실제로 16KB 페이지를 사용하는 경우 실제 데이터가 저장되는 공간은 pageLSN을 위한 공간을 빼고 16376바이트가 된다. <br>


## 5.3 백업을 이용한 미디어 복구
디스크 미디어 문제로 수행하는 미디어 복구는 **archive 복구라고도 부른다.** <br>
이는 백업으로 부터 복구하는 것을 의미한다. <br>
백업 기법에는 여러가지가 있는데, **보통 현재 snapshot을 그대로 복사하는 fuzzy 백업을 수행한다.** <br>
**fuzzy 백업은 수행도중 트랜잭션들의 수행을 방해하지 않는다.** (fuzzy : 보송보송, 흐릿.. 어렴풋.. 곱슬곱슬) <br> <br>

트랜잭션이 수행되고 있는 도중의 스냅샷을 찍는 것이기 떄문에, 커밋되지 않은 트랜잭션의 이미지나 트랜잭션 데이터가 아직 반영되지 못한 채로 복사 될 수도 있다. <br>
따라서, 복원시 로그가 중요하게 된다. <br>
미디어 복구시에는 DB 백업과 백업에 포함된 로그, 장애시점 로그까지 활용해 복구한다. <Br>
결국 장애로 인한 복구와 똑가티 **로그를 읽어 바영 안된 커밋과 트랜잭션을 REDO해주고, 결국 커밋 레코드가 포함되지 않은 트랜잭션들은 UNDO 해주면 된다!** <br>
이러한 미디어 복구 시점의 재시작 복구를 **roll-forward 복구라고 부른다.** <br>

백업 이후의 모든 로그가 남아있다면 손실없이 DB 복구가 가능하다. <br>
roll-forward 과정을 특정 지점까지만 수행하면, 미디어 복구를 이용해 특점 지정까지만 DB를 복원할 수도 있다.


## Reference
- [DBMS는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)
