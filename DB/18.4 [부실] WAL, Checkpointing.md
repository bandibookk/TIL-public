# 18.4 WAL Log Protocol -> 설명 부실한 느낌
페이지를 디스크게 쓰기 전에, 페이지의 변경을 기술하는 모든 갱신 로그 레코드들은 안정된 저장장치에 강제 쓰기를 해야 한다. <Br>
이것은 그 페이지를 디스크에 쓰기 전에, 해당 페이지의 pageLSN과 동일한 LSN을 가진 레코드까지의 모든 레코드를 강제로 쓰면서 이루어진다. <br>
그러니까, 처음 부터 그 페이지의 마지막 수정 로그까지를 전부 강제로 쓴다는 것이다. <br> <br>

WAL은 Write Ahead Log로 매우 매우 매우 중요하다. <Br>
WAL이 각 DB 변경에 대한 로그 레코드가 장애로 부터 복구될 때 이용 가능하다는 것을 보장해준다. <Br>
Recoverability를 보장해주는 것이다. <br>
트랜잭션이 페이지의 변경을 완료했을 때, `no-force` 접근 방식은 뒤이은 장애발생 떄에 디스크에 기록되지 않을 수도 있다.
만약 장애의 원인이 되는 변경들을 기록하지 않았다면, 완료된 트랜잭션이 만든 변경을 장애로부터 보존하는 것을 보장하는 방법은 없다. <br> 

완료된 트랜잭션의 정의는 그의 모든 로그 레코드가 안정된 저장장치에 기록되었다는 것을 의미한다.  <Br>

`no-force` 방식을 사용하더라도, 트랜잭션이 완료될 때, Log Tail은 안정된 저장장치에 강제쓰기 해야한다. <Br>

반면에 force 방식이 사용된다면, 해당 트랜잭션이 수정한 모든 페이지는 트랜잭션 완료시 디스크에 강제 쓰기가 되어 있어야 한다. <br>
변경 페이지 집합은 일반적으로 Log Tail보다 훨씬 크다. 보통 갱신 로그 레코드는 변경된 바이트의 2배에 가깝고, 이 변경 부분은 당연히 페이지보다 매우 작기 때문이다. <br>
로그의 모든 쓰기는 순차 쓰기이다. Log Tail을 강제로 쓰는 비용은 모든 변경된 페이지를 디스크에 쓰는 비용보다 훨씬 작다.

# 18.5 체크포인팅
**체크포인트는 DBMS의 스냅샷과 같다.** <Br>
ARIES에서 체크포인팅은 3단계를 거친다.
1. 체크포인팅 시작시 `begin_checkpoint` 레코드가 로그에 기록됨
2. **`end_checkpoint` 레코드가 만들어지고, 트랜잭션 테이블과 Dirty Page 테이블을 레코드에 포함하고, 로그에 추가한다.**
3. `end_checkpoint` 레코드가 안정된 저장장치에 기록된 후 실행된다.


<br>

`begin_checkpoint` 로그 레코드의 LSN을 가진 master 레코드가 안정된 저장장치에 기록된다. <Br>
**이러한 종류의 체크포인트를 fuzzy checkpoint 라고 부른다.** 다른 형태의 체크포인팅과 달리, 시스템 정지나 버퍼 풀에 있는 페이지를 DB에 쓰는것을 요구하지 않아 비용이 저렴하다. <Br> <br>
시스템은 처음 시작할 때 균일성을 위해 빈 트랜잭션 테이블과 빈 Dirty Table을 갖는 체크포인트를 함으로써, 정상 실행을 시작한다. <br>
그리고 시스템이 장애 발생 이후 다시 작동될 때, 재시작 프로세스는 가장 최근의 체크포인트 레코드를 찾는다. <br>

## Reference
- Database Management Systems <Raghu Ramkrishnan 저>




