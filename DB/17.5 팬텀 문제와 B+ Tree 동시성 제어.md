# 17.5 전문화된 Lock 기법들

1. 팬텀 문제 해결
2. 트리구조 인덱스 Lock
3. 객체 사이의 포함관계를 갖는 객체 모임 잠금

# 17.5.1 동적 데이터베이스와 팬텀 문제
삽입과 삭제가 일어나는 상황에선 팬텀 문제가 발생할 수 있다. <br>

팬텀 문제의 원인은 Strict 2PL에 있지 않다. 

오히려 특정 조건을 만족하는 모든 레코드들의 집합을 잠금했다는 가정에 있다. 조건에 맞는 모든 레코드를 포함하는 페이지들을 식별하고, 잠금한다고 하더라도, Lock이 걸려있지 않은 페이지에 새로운 팬텀 레코드가 추가되는 것을 막을 수는 없다. <br>
새로운 항목이 DB에 추가된다면 충돌직렬성은 직렬성을 보장하지 못한다. <Br>

1. 인덱스가 없다면, 트랜잭션은 존재하는 모든 페이지를 잠금하고, 어떠한 새로운 페이지가 추가되지 않도록 해야 한다.
2. 타겟이 되는 필드에 대한 인덱스가 있다면, 트랜잭션은 인덱스 페이지에 대한 잠금을 얻을 수 있다. 조건에 맞는 데이터 엔트리를 포함하는 페이지 수준에서 물리적 잠금이 이루어졌다고 가정할 때, **조건에 맞는 데이터 엔트리를 포함하게 될 페이지는 그러한 레코드가 삽입되는 것을 방지하기 위해 잠금된다.** <br> 조건에 맞는 레코드를 삽입하려는 트랜잭션들은 새로운 레코드를 가리키는 데이터 엔트리를 인덱스 페이지에 삽입해야 하는데 잠금에 의해 Block될 것이다. <Br> 이러한 기법을 **인덱스 잠금이라고 부른다.(index locking)**


두 기법은 효율적으로 조건에 맞는 레코드들의 집합게 점금을 허용한다. <Br>
이미 조건에 맞는 레코드들은 변경으로 부터 보호되고, 추가적으로 조건에 맞는 레코드는 삽입되지 않는다. <Br>
조건에 "맞을" 인덱스 페이지는 어떻게 식별하고 잠금해야 할까? B+ 트리 동시성 제어법을 알아보자. <Br>

# 17.5.2 B+ 트리 동시성 제어
B+ 트리와 ISAM 인덱스에 대한 동시성 제어의 가장 쉬운 방법은 그냥 인덱스 구조를 무시해버리는 것이다. <br>
구조를 무시하고 각 페이지에 대해 2PL을 사용하는 것이다. 트리 탐색은 루트에서 부터 특정 경로를 따라 리프 노드로 진행하기 때문에 이러한 전략은 트리의 상위 레벨에서 높은 잠금 경쟁이 일어난다. <Br>

당연하지만, 이런 전략보다 트리 인덱스의 계층 구조를 이용하는 것이 훨씬 더 효율적이다. 더 나은 직렬성과 복구가능성을 보장해주며, Lock 비용을 줄여준다. <br>
이러한 접근 방법들엔 두 가지 관찰 결과가 활용된다.

1. SEARCH : 트리의 상위 레벨들은 탐색 방향을 지시한다. 모든 실제 데이터들은 리프 노드에 있다.
2. INSERT : 삽입에 대해, 수정된 단말로부터 분할이 전파되는 노드는 Exclusive Lock 되어야 한다


두 관찰 결과는 아래와 같이 해석될 수 있다. <br>

#### 1. `SEARCH` : 트리의 상위 레벨들은 탐색 방향을 지시한다. 모든 실제 데이터들은 리프 노드에 있다.

탐색은 루트에서 시작해 원하는 단말로 가는 경로에 있는 노드들에 대한 Shared Lock을 얻어야 한다. <br>
탐색은 트리의 위에서 부터 아래로 진행되기 떄문에 특정 노드에 대한 Lock 그 자식 노드에 대한 Lock이 얻어지면 해제될 수 있다. 이게 무슨 말이냐면, 어차피 가장 아래에 있는 페이지에 Lock을 거는게 목표이고 탐색은 위에서 부터 아래로 이루어지니까, 아래쪽에 있는 노드에 락이 걸린다면 위쪽에 있는 노드는 Lock을 풀어줘도 문제가 없다는 것이다. <br>

#### 2. `INSERT` : 삽입에 대해, 수정된 단말로부터 분할이 전파되는 노드는 Exclusive Lock 되어야 한다


삽입을 위한 보수적인 전략은 루트로 부터 수정될 단말까지의 경로에 있는 모든 노드에 Exclusive Lock을 거는 것일 것이다. (물론 비효율 적일 것이다.) <Br>

이는 분할이 단말에서 부터 루트까지 전파될 가능성 때문이다. 그런데 사실, 분할이 되지 않을거라면, 상위 노드에 Lock을 걸 필요가 없다. <br> 
만약 어떤 노드가 꽉차있지 않다면, 사실 상위노드까지 분할이 전파되지 않을 것이다. <br>
**그러므로, 자식노드가 꽉 차있지 않다면 부모 노드의 잠금은 해제될 수 있다.** <Br>
자식노드를 잠금하고, 가능한 경우 부모노드에 대한 잠금을 해제하는 기법을 잠금 연결 (lock-coupling) 또는 게걸음(crabbing)이라고 한다. <Br>

![1  b+tree](https://github.com/binary-ho/TIL-public/assets/71186266/b636fe18-4408-418b-87a9-fe53db07cd1d)

<br>

위 그림에 데이터를 탐색-삽입하는 3가지 예시를 살펴보자.

#### 예시 1 - 데이터 엔트리 *38탐색
데이터 엔트리 *38를 탐색할 때 트랜잭션 T1은
1. 노드 A에 대해 S Lock 획득 + 내용 읽음
2. 노드 B 조사 결정. B에 대한 S Lock 획득 + 내용 읽음
3. **A에 대한 잠금 해제**
4. 노드 C에 대한 S Lock **획득 B에 대한 잠금 해제**
5. **D에 대한 S Lock 얻음, C에 대한 Lock 해제**

이런식으로 경로상의 한 노드에 대한 Lock을 항상 가지고 있다. 한칸씩 슬금슬금 움직여서 게가 움직이는 것만 같아 crabbing이라고 부른다. <br>
만약 이 상태에서 다른 트랜잭션 T2가 *38 삭제 시도를 했다면, 또 루트에서 D까지 이동할텐데, T2는 T1이 완료될 때까지 D 바로 전에서 기다린다.

### 예시 2 - 데이터 엔트리 45* 삽입
데이터 엔트리 45*를 삽입하려면, 트랜잭션은 
1. 노드 A에 대해 S Lock 획득
2. 노드 B에 대해 S Lock 획득, 노드 A S Lock 해제 
3. **노드 C에 대해 S Lock 획득, 노드 B S Lock 유지! -> C가 꽉차있기 때문에 분할이 전파될 수도 있다.** 
4. **노드 D에 대해선 X 잠금을 얻는다. 이후 C에 대한 Lock과 B에 대한 Lock을 해제한다.**
5. 노드 E는 새로운 엔트리가 삽입될 수 있는 공간이 있으므로, E노드가 수정되며 삽입이 완료된다.


### 예시 3 - 데이터 엔트리 25* 삽입
예시 2에서와 같이 쭉쭉 진행하면서 
1. 노드 H에 대한 X Lock 획득
2. **노드 H는 꽉 차있기 떄문에, 분할 되어야 한다. 따라서, F에 대한 S Lock을 X Lock으로 강화해야 한다.**
3. 다른 트랜잭션에 F에 대한 S Lock을 소유하고 있지 않다면, Lock Upgrade는 허용된다.

# 17.5.3 다단계 잠금


## Reference
- Database Management Systems <Raghu Ramkrishnan 저>
