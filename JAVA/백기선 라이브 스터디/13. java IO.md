# Java I/O
## 스트림이란?
어느 한 쪽에서 다른 쪽으로 데이터를 운반하려면 연결 통로가 필요하다. <br>
이러한 데이터 단방향 운반 연결 통로를 stream이라고 부른다. <Br>
stream은 연속적으로 데이터를 주고 받으며, 단방향이기 때문에 입력 스트림과 출력 스트림의 두 개의 스트림이 필요하다. <br>


## 바이트 기반 스트림 - InputStream, OutputStream
스트림은 바이트 단위로 데이터를 전송하며, 입출력 **대상에 따라** 분류될 수 있다. <br> 
[입출력 대상] 
1. File : 파일 
2. ByteArray : 메모리 (byte 배열) 
3. Piped : 프로세스 (프로세스간 통신) 
4. Audio : 오디오 장치 

이들은 각각 추상 클래스 InputStream과 OutputStream을 구현한 버전이 존재한다. <Br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/c915296d-6011-4890-a81b-475545874c03)

위의 그림에서 InputStream의 구현체들을 보면, 입출력 대상에 따라 아주 다양한 클래스가 있는 것을 확인할 수 있다. <br>



## 보조 스트림
보조 스트림은 스트림의 기능을 보완하기 위한 기능으로, 실제로 데이터를 주고 받지 않으며, <Br>
보조적이기 때문에 보조스트림만으로는 입출력을 처리할 수 없다. <Br>
스트림을 먼저 생성한 다음에 이를 이용해 보조 스트림을 생성해야 한다. <Br>
보조 스트림 또한, Input/Output Stream을 상속했기 때문에, 사용법은 똑같다. <br>

아래는 InputStream의 입력 성능을 향상 시키기 위해 Buffered Input Stream을 사용한 예시이다. <br>

```java
FileInputStream fis = new FileInputStream("test.txt");

// 위의 기반 스트림을 이용해 보조 스트림을 생성한다.
BufferedInputStream bis = new BufferedInputSTream(fis);

// 보조 스트림에서 읽기 호출 (수행은 기반 스트림이 수행).
bis.read();
```

보조 스트림에서 read를 호출하지만, 실제로는 기반 스트림이 수행한다. <br>
보조스트림은 버퍼만 제공해준다. <Br>
버퍼를 사용한 입출력과 사용하지 않은 입출력간의 성능 차이는 상당하다. <br> 
예를 들어 버퍼 없이 순수하게 10MB 파일을 읽는 경우, 윈도우 기준 약 2500ms의 시간이 소요될 수도 있다 <br>
대부분의 경우에 버퍼를 이용한 보조 스트림을 사용하는 것이 좋다. <Br>

이러한 보조 스트림들은 전부 `FilterInput/OutputStream`을 조상으로 둔다.

## 문자 기반 스트림 - Reader, Writer
문자-문자열 기반의 스트림을 읽기 위해선, Reader와 Writer 클래스를 이용하면 된다. (java.io.Reader) <br>


![image](https://github.com/binary-ho/TIL-public/assets/71186266/52143e58-60b7-489a-a869-b1bc1173f2b8)

예를 들어 File의 경우 바이트 기반에선 FileInput/Output Stream를 사용했다면, FileReader/Writer를 사용하면 된다. <br>
앞서 보았던 Stream과 같이 입력 대상에 따라 다양한 구현체가 있다. <br> 
내부적으로 byte 배열 대신 char 배열을 사용한다는 것 외에는 기존과 똑같다. <br>

## NIO 
NIO는 New IO의 줄임 말로, JDK 1.4에서 추가 되었다. <br>
기존 IO의 느린 성능을 개선하기 위해 추가 되었다. <br>
기존의 IO를 이용한 파일 읽는 과정은 아래와 같은 순서로 진행되었다.
1. 파일을 읽기 실행
2. 메서드가 OS의 커널에게 파일을 읽어 달라고 요청
3. 커널은 하드 디스크로 부터 파일을 읽어 자신의 커널에 있는 버퍼에 복사 (DMA에서 수행)
4. 자바에서는 커널 버퍼에 접근하기 어려우니, JVM으로 데이터 전달
5. JVM에서 메서드에 있는 스트림 관리 클래스 사용해 데이터 처리

<br> 

이 과정에서 3번, 4번 작업은 대기시간이 발생할 수 밖에 없는 작업이다. <br>
이 3번 작업을 자바에서 직접 통제하여 시간을 더 단축할 수 있게 도와주는 것이 NIO다. <br>
앞서 버퍼 없이 IO를 하는 경우 10MB 기준 2500ms까지도 소요될 수 있다고 언급했는데, NIO는 버퍼와 함께 IO 작업을 진행한다. <br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/b7cb8116-cbc5-43d5-b3a2-6ed90d7fd481)

이때 버퍼에는 접근 가능하므로, 필요한 부분만 읽거나 쓸 수 있다. <br>
그리고 스트림 대신 "채널"이라는 개념이 도입되었는데, 채널은 스트림과 달리 양방향 입출력이 가능하다. <br>
그래서 따로 입력, 출력 별로 채널을 만들 필요가 없다. <Br>
이러한 채널들을 하나의 스레드에서 Selector라는 채널 관리 클래스를 통해 관리할 수 있다. <br>

<br>

또한 Non-Blocking 작업을 지원하게 되었는데, IO작업 자체의 가장 큰 문제점이 느리다는 것인데, NIO를 통해 넌 블로킹 작업이 가능해진다. <br> 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/88e89a38-725e-426b-a9dd-b5b2d781bb95)

기존 IO 패키지를 이용한 방식은 왼쪽 그림과 같이 작업이 진행 됐다면, <br>
NIO를 사용하면 오른쪽 그림과 같이 사용할 수 있다.

<br>

이러한 장점들 덕분에, NIO를 사용한다면, 다수의 연결들을 넌 블로킹으로 처리할 수 있다. <br>
그래서 요청 대상이 많아도 여러 스레드가 점거당하는 일이 줄어든다. 클라이언트가 많은 상황에서 유리하다. <Br>
스레드를 재사용하고, 기본적으로 버퍼를 사용하기 때문에 동작 시간도 줄어든다. <br>
단, 요청 횟수 혹은 클라이언트가 적고 && 대용량이면서 && 순차 데이터를 처리하는 경우 <br>
그냥 IO를 쓰는 것이 더 낫다. <br>
NIO는 버퍼를 기본적으로 사용하기 때문에 사전 작업에 소요되는 비용이 적지 않다. <br>
IO는 버퍼 없이 (보조 스트림을 안 쓴다면) 처리하므로, 오히려 버퍼가 끊어서 관리하기 힘든 대용량 파일에, 연결 클라이언트가 적어 점거되는 스레드가 적은 경우 더 유리할 수 있다. <br> <br>

## NIO2
JDK 1.7에 도입된 NIO2는 이런 NIO를 개선한 `java.nio.file` 패키지를 추가했다. <br>
NIO2는 비동기 Non-blocking IO를 가능하게 해주는 기능이 있는 채널 `AsynchroniousFileChannel` 등 다양한 채널을 도입하고,
기존 NIO가 FILE을 다룰 때 부족한 점을을 채우기 위한 다양한 클래스들을 file 패키지에 추가해 주었다. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/99bf40ff-06f1-45dd-989a-f703573b5f05)


예를 들어 파일의 경로를 다루기 위한 심볼릭 링크를 다루는 기능이 없었고, 파일의 속성이나 권한 등에 대한 기능이 없었다. <br> 
NIO2는 이러한 기능들을 전부 제공해주고, 파일 변화 여부를 더 쉽게 확인할 수 있는 메서드를 제공해준다. <br>

1. Path 클래스 : 파일과 경로에 대한 정보를 가지는 인터페이스로, 파일의 경로를 비교하거나, 경로간의 비교 등을 쉽게 다룰 수 있게 해준다.
2. Files 클래스 : 앞서 언급한 부족한 기존 File 클래스를 보완한 클래스이다. 복사, 이동, 파일 생성과 삭제, 하위 파일 및 폴더를 탐색 메서드 `walk()` 그리고, 상태를 확인하는 다양한 메서드를 추가해줬다.
3. FileSystems 클래스 : OS에 따른 "파일 시스템"에 대한 처리를 돕는 다양한 메서드를 제공한다. 여기서 시스템 정보를 갖고 있는 객체를 얻을 수 있다.
4. FileStore 클래스 : 파일이 저장되는 디바이스나 볼륨과 관련된 정보를 확인하는 것을 돕는다.
5. 기타 API : 네트워크 소캣을 다루기 위한 `networkchannel`, 멀티캐스트를 위한 네트워크 채널 `Multicastchannel`, 앞서 언급한 비동기 작업을 위한 `AsynchronousFileChannel` 등이 추가됨


![image](https://github.com/binary-ho/TIL-public/assets/71186266/558c0741-cbbc-4f28-8db1-360d7564bf31)


NIO2의 `AsynchronousFileChannel`를 이용하면 위 그림과 같이, 비동기 채널을 통해 IO를 처리할 수 있다. <br> <br>

참고 : 이런 비동기 채널을 이용한 방식이 버퍼를 사용한 방식 보다 읽어오는 속도가 빠른 것은 아니다. <br>
물론 비동기를 사용하는 목적이 빠른 작업 속도는 아니지만, 그냥 참고하라고 적어 보았다. <br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/363a366e-b0a4-46ec-9531-a0437661bfe0)


