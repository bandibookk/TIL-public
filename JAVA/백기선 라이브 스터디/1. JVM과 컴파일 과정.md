# 1\. JVM이란 무엇인가

![image](https://github.com/binary-ho/TIL-public/assets/71186266/8fdc3d36-4616-4926-ae7f-75a7b6b74008)

JVM은 Java Virtual Machine으로,  
OS에 종속되지 않고 프로그램을 실행시킬 수 있도록 돕기 위해 존재하는 가상 머신이다.   
기존의 프로그래밍 언어들은 기계어로 변환할 때 각 CPU나 OS에 맞는 방식으로 변환해줘야 했는데,  
JVM이 중간에 끼어서 알아서 각 OS에 맞는 방식으로 변환해준다.

그러니까 초벌 구이처럼 한번 살짝 익혀서 (컴파일해서) JVM에게 주면

각 CPU나 OS의 상황에 맞게 기계어로 바꾸어 주는 것이다.

이러한 특성은 Write Once, Run Antwhere이라고 부른다.

한번만 딱 쓰고 어디서든 쓰자~ 라는 뜻. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/5a1629c9-d7ad-4439-bcff-095dbc03c0d8)

이런 이미지를 머리에 넣으면 좋다.

기존 프로그램은 하드웨어 위에 OS가 있고, 그 위에 프로그램이 돌아가는 구조이다.

하지만, JVM의 경우 '가상' 머신으로써 Java Program이 어떤 OS에서도 돌아갈 수 있도록

그 사이에 낑겨 들어간다.

JVM을 앱과 OS에 싸서 드셔보세요.

### 1.1 JVM 스펙

여기까지는 흔하게 볼 수 있는 말이고, 그 기본 스펙을 한번 살펴보자.

  
JVM의 스펙에 따르면,

JVM은 바이트 코드를 실행할 수 있는 (OS에 맞게 변환시킬 수 있는)

추상적인 형태의 스택 기반 해석 머신이라고 한다. 

스택 기반이라는 말의 의미는 뒤에서 나중에 알아보자.

어떤 딱 정해진 하나의 JVM이 있는게 아니라,

오라클에서 정해 놓은 스펙에만 맞으면 나머지 부분은 어떻게 구현해도 된다는 것이다.

오히려 오라클에선 창작자의 상상력을 위해 구체적인 구현을 제시하지 않았다고 한다.

얼마나 자유롭냐면..

하드웨어여도 상관 없고, 꼭 컴파일 이전 언어가 java 언어가 아니여도, 바이트 코드를 해석해낼 수만 있으면 상관 없다.

실제로 요즘 유행하는 코틀린도 JVM위에서 동작한다. 

스펙에는 JVM에서 중요하게 여겨지는 주제인 JIT이나, GC에 관한 스펙도 상세히 기술되어 있지 않다고 한다.

그러다보니, 다양한 회사에서 구현체를 만들었고, OpenJDK, 오라클 자바, 줄루 등 다양한 기업의 다양한 구현체들이 있다. 

기본적으로 JVM이 제공해야 하는 가장 중요한 서비스는 코드 실행과 메모리 관리이다.

내부적으로 인터프리터라는 런타임시 한줄 한줄 코드를 읽어내는 해석기로 바이트 코드를 실행한다. 

이는 컴파일 방식에 비해 느릴 수 밖에 없다.

컴파일 방식은 한번의 컴파일로 전체 소스를 기계어로 바꾼 다음 그걸 계속 사용하는데,

인터프리터는 한줄 한줄 바이트 코드를 기계어로 해석해준다.  
  
이를 해결하기 위해 반복되는 코드들을 컴파일하는 JIT 컴파일러를 내부적으로 도입하기도 하였는데, 더 자세한 사항은 뒤에서 언급히겠다.

### 1.2 JVM과 운영체제

이런 JVM은 OS와 앱에 사이에 낑겨 일종의 '인터페이스'를 제공해준다.

이는 native 메서드로 구현되는데, 네이티브 메서드란 Java 언어가 아닌 다른 언어들로 쓰인 메서드들을 말한다.

(나중에 JVM 메모리 구조를 보면 이 native 메서들이 위치하는 곳을 알 수 있다.)

자바 네이티브 인터페이스 JNI를 통해 이런 native 메서드들을 자바 메서드들처럼 편하게 사용할 수 있다.

OS나 CPU에 독립적인 JVM은 이런 JNI를 통해 **'OS에 의존적인'** C, C++ 메서드를 호출해 준다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/755f50d4-b3c3-4d55-afa8-1328289abf8e)


# 2\. Java의 컴파일

JAVA에서의 '컴파일'이란 일반적으로 자바 언어를

JVM이 이해할 수 있는 바이트 코드로 변환하는 과정을 가리킨다. 

아까 말한 초벌 구이에 해당한다.

다른 언어의 경우 프로그래밍 언어로 작성한 코드를 기계가 이해할 수 있도록   
어셈블리 언어와 기계어 코드로 변환시키는 것을 컴파일이라고 부른다. 

나만의 생각이지만 JVM 자체도 일종의 '머신' '기계'이므로,

JVM이 이해할 수 있는 코드로 바꾸는 과정을 컴파일이라고 부르는 것 같다. 

기존 언어에서의 컴파일과 Java에서의 컴파일은 똑같이 변환 과정에서 코드 최적화를 진행한다.

그리고 기존 언어에서의 컴파일과 Java에서의 컴파일의 다른 점은 링크 단계가 없다는 점이다. 

보통은 컴파일 과정에서 링커가 기계어 코드와 라이브러리들을 엮어 내는 링크 과정이 필요하다.

단순히 작성된 코드들 뿐만 아니라,

코드들이 사용한 라이브러리들도 프로그램에 포함 되어야 이용할 수 있지 않겠는가?

이러한 과정을 링크라고 부른다.

Java에서의 컴파일은 굳이 링크를 진행하지 않는데,

배짱을 부리는 것이 아니라, 어차피 링크 과정이 JVM 내에서 일어나므로,

Java에서의 컴파일시엔 링크 과정을 뺀 것이다. 

### 2.1 컴파일 과정

컴파일 과정은 단순하다.   
 '.java' 의 확장명을 가진 자바 소스 파일은   
**JDK에 속한 javac 컴파일러에 의해 \`.class\` 확장명을 가진 바이트 코드로 컴파일 된다.** (java + compiler = javac)   
   
  
컴파일은 세부적으로 아래와 같은 3가지 과정을 거친다.  
1. Lexical Analysis : 어휘 분석  
2. Syntax Analysis : 구문 분석  
3. Symantic Analysis : 의미 분석

PL 수업시간에 열심히 배운 내용들이다.

처음엔 Lexical Analyzer에 의해 모든 어휘소가 분석된다.   
이후 파서 (Syntax Analyzer)에 의해 파스 트리가 생성된다. 이 Syntax 분석 과정에서 문법상 오류가 발견된다.   
마지막으로 Symantic Analysis 과정에서 타입을 검사하고, 타입 변환 등을 수행한다.   
타입 관련 오류는 이때 발견된다.   
   
이런 과정을 열심히 거치면 중간 코드라고도 불리는 바이트 코드가 완성된다. 

### 2.2 중간 코드가 필요한 이유

이런 중간 코드를 만드는 이유는, JVM이 각 OS나 CPU에 맞게 기계어로 처리를 해주는 과정을 좀 더 쉽게 수행하기 위해서이다. 

이렇게 단계를 나눠준 이유는 JVM은 중간 언어를 받고, 최종적으로 중간 언어만 기계어로 바꿔주는 전략이,

소스 파일을 처음 부터 각 OS나 CPU에 맞는 기계어로 바꾸는 것보다 유리하기 때문이다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/2703422d-ff30-4504-a3aa-dda6ac44aba8)


상급 언어를 저급 언어로 변환하는 과정에서 코드를 좀 더 효율적으로 실행할 수 있도록 최적화 하는 optimizer가 필요하다. Java 언어를 바이트 코드로 컴파일 할때도 똑같이 최적화가 적용된다.

이러한 옵티마이저와, 코드 생성기가 상황의 갯수 만큼 필요하다. 

예를 들어 4개 언어를 3개 CPU 혹은 OS에 컴파일 할 때,

각 상황에 맞는 옵티마이저와, 코드 제너레이터가 필요하므로,

총 4 \* 3개씩 필요하다.

하지만 오른쪽 그림처럼 중간 언어가 있다면, 좀 더 적은 갯수의 옵티마이저와 코드 생성기가 있어도 문제 없다.

바이트코드로의 변환은 모두 목적지가 같고, 중간 언어에서 각 타깃에 맞게만 바꿔 주면 되기 때문이다.

언어 수준에서 힘들게 여러 타겟의 기계어에 대한 고려를 하지 않아도 된다.

## Reference
- 자바 최적화 <벤저민 J. 에번스, 제임스 고프, 크리스 뉴랜드>
- [자바 컴파일에서 실행까지](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/)
- [김김의 JVM Specification](https://www.youtube.com/watch?v=6reapO0gLPs&t=309s)
