## 3 . 자바 클래스 vs 인터페이스

위에서 자바의 클래스와 인터페이스의 개념적 차이를 알아보았다.

이제 코드를 구현하면서 고려해야 하는 차이에 대해 알아보자.

### 3.1 추상 클래스 vs 인터페이스

추상클래스와 인터페이스는 꽤나 비슷해 보인다.

특히 Java 8에 추가된 인터페이스 default method 덕분에, 맘만 먹으면 거의 비슷한 역할을 수행하도록 만들 수 있다.

이 때문에 둘 중 어떤 것을 사용해야 할지 헷갈린다.

이럴때 중요한게 바로 "용도"이다.

용도를 정확하게 알면, 언제 어떤걸 사용할지가 명확해진다.

### 3.1.1 추상적 개념의 추상화! - Blueprint  

일단 추상클래스는 말 그대로 "클래스"이다. 

어떤 개념을 추상화하고, 상위 개념과 하위 개념을 나누고,

A라는 것이 B의 한 종류임을 나타내기 위한 것 - is a kind of - 이 클래스이다.

만약 이 역할을 하는 "무언가"를 만들 것이라면 인터페이스 대신 추상 클래스를 이용하면 된다.

추상 클래스는 추상 메서드가 하나라도 있는 클래스를 추상 클래스라고 부른다.

이런 추상 클래스는 일종의 "설계도"로써 "추상적 개념의 추상화"에 매우 유용하다.

예를 들어보자.

포유류 클래스가 있고, 이를 상속받은 동물 클래스들이 있다.

예를 들어 포유류인 향유고래와 고양이는 자손을 만들때 "새끼를 낳는다"

조류 클래스의 하위 클래스인 독수리와 비둘기는 "알을 낳는다"

**그렇다면 이들의 공통 조상 클래스인 "동물 클래스"는 자손을 어떻게 만드는가?**

모른다;

동물이라는 개념 자체는 자손을 만드는 방식이 딱 정해져 있지 않고 다양한다.

밥은 어떻게 먹는가? 울음은 어떻게 내는가?

"개념"은 행동을 정의할 수 없고, 행동할 수도 없다.

즉, 어떤 행동을 한다는 것을 정할 수는 있지만 "어떻게"할지는 바로 정할 수가 없고,

개념 자체의 행동 가능한 개체를 만들 수도 없다.

즉

1\. 인스턴스가 만들어 져서는 안됨

2\. 메서드가 호출되면 안됨 (행동 불가능)

3\. 하위 클래스에서 오버로딩을 강제해야함 (자손을 "어떻게" 만들지 무조건 정해야 한다)

4\. 상위 클래스의 객체 참조 변수로 만든 인스턴스가 해당 메서드를 호출할 수 있어야 함 (동물 참조변수가 가리키는 향유고래는 자식을 낳을 수가 있음)

이런식으로 어떤 추상적인 "개념"을 추상화 할 때 유용한 것이 바로 추상 클래스이다.

추상클래스는 일종의 설계도로써 추상 메서드를 이용해 위와 같은 4가지 조건을 충족시켜준다.

이런 용도로 사용할 경우 추상 클래스를 사용해야 하는 것이다.

아닌 경우, 타입을 정의하는 용도 혹은 어떤 행동이 가능하다는 것을 정의할 용도로 사용할 때는 인터페이스로 만들어야 한다. java 8dml default method의 등장으로 인해 헷갈릴 때는 용도를 정확히 따져보자.

###  3.1.2 추상 클래스 보다 인터페이스를 우선해야 하는 이유

바로 앞에서 용도의 차이와 관계의 차이에 대해 알아봤다.

앞에선 용도의 차이에 집중했고, 이번엔 관계 차이에 집중하자.

추상클래스의 하위 클래스는 반드시 추상 클래스의 하위 클래스가 된다.

그리고 인터페이스의 구현체들은 다른 어떤 클래스를 상속했던 간에 구현한 인터페이스와 같은 타입으로 취급된다. (인터페이스의 규약만 잘 지킨다면)

추상클래스 대신 인터페이스를 우선하면 얻게되는 장점을 알아보자. (이펙티브 자바 아이템 20)

1, 기존 클래스에 새로운 인터페이스를 추가하기 쉽다.

2\. 믹스인 정의에 안성맞춤이다.

3\. 계층구조 없는 타입을 만들 때 편리하다.

추상 클래스는 하위 모든 개념들의 상위 개념으로써 존재해야 한다. 따라서, 어떤 클래스 위에 새로운 추상 클래스를 넣게 된다면, 기존의 클래스를 상속 받는 모든 클래스들의 공통 조상이 되어 주어야 한다. 그리고 모든 자손은 그 영향을 그대로 받게 된다. 이는 말만 들어도 너무 어려운 일임을 알 수 있다. 때로는 적절하지 못한 영향을 미칠 수 있다.

반면, 새로운 인터페이스를 추가하기는 너무나도 쉽다.

단지 새로운 기능을 섞고 싶은 클래스를 찾아가, 해당 인터페이스를 구현하기만 하면 된다.

너무나도 간단하며, 영향이 작다.

이런 mixin을 추상 클래스로 구현 할때는 일이 복잡해진다. 클래스는 단일 상속만이 가능하기 떄문이다. 

또한 계층을 엄격하게 구분하기 어려운 개념의 표현이 용이해진다.

예를 들어 가수 클래스와 작곡가 클래스가 있다고 생각해보자.
![image](https://github.com/binary-ho/TIL-public/assets/71186266/369e71f2-f39e-48ac-b7ae-2bc3437e5d50)


에드 시런을 코드로 작성할 것인데, 에드 시런은 조금 불쾌할 것이다.

저는 노래도 하고 작곡도 제가 하는데요?

이런 상황을 클래스로 표현하려면 머리가 아파진다.

클래스는 단일 상속만이 가능하기 때문이다.

하지만, 인터페이스로 표현하면 너무 간단하다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/b380fd49-fc4d-405d-a5d7-bf23341cb4e0)

에드시런 클래스가 두 인터페이스를 구현하기만 해도 된다.

혹은 두 인터페이스를 확장한 새로운 인터페이스를 만들면 그만이다.

**이런 인터페이스를 사용하는 이점들과 용도, 관계를 잘 생각하면 추상 클래스와 인터페이스 중 어떤 것을 고를지 더욱 명확해질 것이다.**

### 3.2 extends class method vs default method

만약 상위 클래스에서 정의한 메서드와 default method가 겹치면 어떻게 될까? 

\-> **상위 클래스의 메서드가 상속된다. 그리고 default method는 무시된다.**

![image](https://github.com/binary-ho/TIL-public/assets/71186266/8c0154cb-76fc-4aba-b430-671edceb6996)
![image](https://github.com/binary-ho/TIL-public/assets/71186266/34d4f39d-dd70-48f1-a600-49a1082cc9ac)

위 그림과 같이 이름이 똑같은 메서드 두 개를 선언한 다음

출력문을 다르게 설정 해주었다!

![image](https://github.com/binary-ho/TIL-public/assets/71186266/d0142df3-6a2b-4b8c-a356-e2d6a690d92c)

그림과 같이 클래스 최고가 호출 되었다!

그렇다면 interface끼리 default method의 이름이 겹치는 경우 어떻게 처리 될까?

\-> **개정의를 강요한다** 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/b9f479c6-146f-45a8-8546-eeaf3d10a774)
![image](https://github.com/binary-ho/TIL-public/assets/71186266/8b46d8e1-9c15-45a7-a02c-bc4399cf5741)

이렇게 default method의 이름이 겹치는 인터페이스 3개를 정의해 보았다

![image](https://github.com/binary-ho/TIL-public/assets/71186266/31ada88d-9a38-4b57-8823-649cf49c6f2d)

구현을 강요한다!

### 3.3 클래스는 풍성하게, 인터페이스는 작게

객체지향적으로 클래스와 인터페이스를 작성할 때는 LSP와 ISP를 준수해야 한다.

상위 클래스는 풍성할 수록 좋고, 인터페이스는 작을 수록 좋다는 이야기와 관련된 원칙들이다.  

단일 책임을 갖는 다는 원칙 하에, 상위 클래스는 풍성할 수록 좋다. 

LSP는 리스코프 치환 원칙으로 **"서브 타입은 언제나 자신의 base type으로 교체할 수 있어야 한다**"는 원칙이다.

좀 더 구체적인 지침을 말 하자면,

1\. **하위 클래스 is a kind of 상위 클래스**이여야 하고

2\. **구현 클래스 is able to 인터페이스**여야 한다.

하위 클래스를 작성하거나, 인터페이스를 클래스에서 구현할 때 이 두가지 지침을 지켜야 한다.

2번은 어렵지 않으나,  1번이 어려울 수 있다.

내가 추가중인 기능이 하위 클래스에 모두 적용되어도 개념적으로, 문제가 없는가?

내가 어떤 기능을 추가하더라도, 상위 개념으로 표현할 수 있는가?

말만 들으면 당연하지만, 클래스 상속 개념을 확장이 아닌, 정말 가계도상 상속으로 이해하고 있다면 논리적으로 흠이 생긴다.

예를 들어 딸은 아버지의 자식이다. 아버지 참조 변수로 딸 인스턴스를 가리키는 상황은 자연스러운가?

이는 클래스의 상속을 is a kind of 관계가 아닌 계층도 형식으로 상속을 이해했을 때 발생한다.

그러니까 하위 클래스 인스턴스는 상위 클래스로 선언한 객체 참조 변수에 대입해서 사용하는데 문제가 없어야 한다.

하위 클래스가 공통적으로 가지는 특성들을 가진 풍성한 상위 클래스를 짜려고 노력해야 한다. (물론 단일 책임 하에)

반대로 인터페이스는 작을 수록 좋다.

인터페이스를 작성할 때는 ISP - 인터페이스 분리 원칙을 지켜야 하는데, 인터페이스가 최소 메서드만을 제공해야 한다는 원칙이다.

SRP와 비슷한 개념으로, 인터페이스는 자기 이름 및 역할에 맞는 최소한의 기능만 가지고 있어야 더 사용성이 높다.

정말 극단적인 예를 들면, "식당을 관리할 수 있다"라는 인터페이스가 있다고 가정해보자.

식당을 관리할 때는 가게도 청소해야 하고, 홀도 봐야하고, 재고도 관리해야 하는 등 여러 업무가 가능해야 한다.

이 경우 위 인터페이스를 구현하는 클래스는 위 역할들을 모두 할 줄 알아야한다.

식당이 커져 분업을 해야한다면, 위 인터페이스만으로는 무리이다.

차라리 "청소할 수 있음", "손님 관리가 가능함", "재고 관리할 수 있음" 등으로 나뉘어 있다면,

각각을 직원 한명 한명에게 구현해 줄 때도 용이하고, 위 3가지 역할 중 2가지만 할 수 있는 사람, 3가지 전부 할 수 있는 사람 모두를 표현하기가 너무 용이하다.

그래서 상위 클래스를 작성할 때와 달리 인터페이스는 자신의 역할에 맞는 최소한의 기능만을 갖는 것이 유리하다고 할 수 있다.

기본적으로 SRP를 지키면서, 클래스와 인터페이스를 작성할 LSP와 ISP를 고려하며 작성해야 한다. 

## 4\. 인터페이스의 품질을 높히는 방법

어떤 인터페이스가 좋은 인터페이스일까?

인터페이스의 품질을 높히는 방법들을 구체적인 코드 작성 지침들과 함께 만나보자.

지금 이 글이 너무 길어져 다른 글에 적겠다.

\-> \[바로가기\] 

### Reference

\- 자바의 정석 <남궁성>

\- 스프링 입문을 위한 자바 객체지향의 원리와 이해 <김종민>

\- 이펙티브 자바 - 아이템 18 ~ 22, 64 <조슈아 블로크>

\- 오브젝트 <조영호>

\- Oracle - Chapter 9. Interfaces

 - [https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan](https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan)

 [Java8: Why is it forbidden to define a default method for a method from java.lang.Object

Default methods are a nice new tool in our Java toolbox. However, I tried to write an interface that defines a default version of the toString method. Java tells me that this is forbidden, since me...

stackoverflow.com](https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan)
