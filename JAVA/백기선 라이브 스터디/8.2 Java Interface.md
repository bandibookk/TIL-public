## 2\. 자바 interface

### 2.1 기본 맴버 규칙

자바 인터페이스의 멤버 변수와 메서드는 **기본적으로** 아래와 같은 규칙을 갖는다.

1\. **모든 맴버 변수는 public static final 이다.**

2\. **모든 메서드는 public abstract 이다.**

우리는 아래와 같이 인터페이스를 사용했지만,

![image](https://github.com/binary-ho/TIL-public/assets/71186266/f73b74e7-4b91-49df-a073-6595018646a5)

사실은 아래와 같이

필드의 경우 \`**public static final**\`을

메서드의 경우 **public abstract**를 숨기고 있었다.

(인텔리제이는 적으나 마나 영향을 주지 않는 요소를 회색으로 표시한다.)

![image](https://github.com/binary-ho/TIL-public/assets/71186266/25bef52c-d0dc-4b78-8e51-16cde644b962)

그래서 필드를 외부에서 호출 가능하고, 값을 초기화 하지 않는 경우 컴파일 에러가 발생한다. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/7ebe0516-346d-4333-93cc-d9816185468c)

![image](https://github.com/binary-ho/TIL-public/assets/71186266/9dd8ba4f-5905-4da4-a267-99f381518a45)

### 2.2 기본 맴버 규칙 예외들과 주의할 점 -  default, static, private 메서드

java 8에 도입된 default 메서드와 static method, 그리고 java 9의 private 메서드는 기본 맴버 규칙을 따르지 않는다.

더 정확히는 따르지 않아도 되게 해준다!

interface의 default 메서드는 java 8에 도입된 기능으로 몸체를 가질 수 있다.

abstract가 아니다!

![image](https://github.com/binary-ho/TIL-public/assets/71186266/bb2c4e95-f8aa-4c56-9689-d7b3bceebd5b)

어떤 메서드의 구현 방법이 너무 명백하다면, default 메서드를 제공해줄 수 있다.

default 메서드를 사용하는 입장에서, 맴버 변수가 다 public 상수이거나, private 메서드를 선언할 수 없다는 점은 메서드를 구현하는데 불편함을 줄 수 있다. **이런 불편을 해소하기 위해 java 9에서 private 메서드가 추가되었다.** 이제 인터페이스 안에서도 private 메서드를 구현 가능하다. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/1551a7ab-7fa0-4e47-8e00-617a3ded1253)

첫 메서드와 같이 private 메서드를 사용할 수 있다.

단, private 메서드는 body가 필요한데, 용도상 인터페이스 내에서 쓰려고 선언하는 것인데, body가 없을 거면 사실 필요도 없기 때문인 것 같다.

### default method 사용시 주의할 점!!

default method를 사용할 때 주의해야 할 점이 있다.

이러한 default 메서드는 단순히 구현 편의를 제공할 뿐만 아니라, 

해당 인터페이스를 구현한 모든 클래스에 메서드를 "끼워 넣을 수 있다"

인터페이스에서 기존에 없던 default 메서드를 추가했다고 생각해보자.

인터페이스를 구현한 클래스들은 손 놓고 가만히만 있어도 새로운 메서드를 사용할 수 있게 된다.

자바 8 부터는 구현 클래스도 모르는 새로운 식구가 우리집에 숨어 들어올 수 있게 된 것이다.

이는 자바 8에 새로 도입된 람다를 활용하기 위해서라고 한다.

물론 자바 라이브러리에서 만든 만큼 잘 만들었지만,

"모든" 상황에서 이전의 "모든" 구현들과 문제를 일으키지 않을 것이라고 확신할 수 있는가?

예를 들어 자바 8 이전에 구현된 아파치 커먼즈 라이브러리의 SynchronizedCollection은 클라이언트가 제공한 객체로 락을 건다. 모든 메서드에서 주어진 락 객체로 동기화를 진행한 다음, 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스인데, 자바 8에서 Collection 인터페이스에 추가된 removeIf를 바로 구현하고 있지는 않다.

어떤 클래스를 이용중인 클래스들은 이런 새로운 메서드의 등장에 바로바로 대응하지 못 할테고, 대응하는 동안 문제가 발생할 수도 있다.

같은 이유로 Object의 equals와 hashCode를 default로 안 된다. 

이펙티브 자바 아이템 20에서 짧게 이유는 언급하지 않는 문제인데, 아래 아티클을 참고해보자.

[https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan](https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan)

 [Java8: Why is it forbidden to define a default method for a method from java.lang.Object

Default methods are a nice new tool in our Java toolbox. However, I tried to write an interface that defines a default version of the toString method. Java tells me that this is forbidden, since me...

stackoverflow.com](https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan)

equals나 hashCode는 두 객체가 같은 객체인지 확인하기 위해 쓰인다.

단순히 같은지 비교할 때나, Set, Map 같은 유일 Key자료구조에서 "다름"을 확인하기 위해 쓰인다.

만약 어떤 인터페이스에 내 마음대로 equals나 hashCode를 default method로 구현한다면 어떤 일이 생길까?

내 인터페이스를 구현해서 사용하던 사람들은 기본적인 Object의 equals나 hashCode의 동작을 기대하면서

다양한 로직을 짤 수 있다. 혹은 이미 그렇게 작성했다.

더는 설명하지 않아도 될 것이다.

우리가 default method로 위의 메서드들을 구현하는 순간 마음대로 "대체" 하게 된다.

이후 사용자는 그냥 가만히 있는데, 코드가 원하는대로 동작하지 않는다.

이런 논리적 오류는 당연히 찾아내기 쉽지 않고, 많은 문제로 이어질 수 있다.

그래서 디폴트 메서드를 작성할 때는 인터페이스를 구현하거나 상속하는 다른 인터페이스들을 위해 문서화를 해주는 것이 중요하다! (이펙티브 자바 Item 21)

그리고 Object의 equals와 hashCode를 default로 구현하면 안 된다. (이펙티브 자바 아이템 20)

**가장 중요한건 웬만하면 진짜 디폴트 메서드의 추가가 필요한지 고민해 보는 것이 되겠다.**  

#### java 8 interface static method

static 메서드는 인스턴스와 독립적이기 때문에 사실 인터페이스에 추가되지 못할 이유는 없었다.

추가하지 않은 이유는 자바의 학습을 좀 더 쉽게 하기 위해서라고 한다.

위에서 언급했듯이 자바 인터페이스는 기본적으로 abstract 메서드만을 갖는데, 이 규칙을 지키기 위해서 구현이 꼭 필요한 static method를 허용하지 않았다고 한다.

그래서 등장한 것이 Collections라고 한다.

원래는 인터페이스에는 abstract 메서드만이 가능하기 때문에,

아래와 같이 Collection을 위한 static 메서드들은 Collections에 구현했다고 한다.  

![image](https://github.com/binary-ho/TIL-public/assets/71186266/7d46e727-5f16-4f65-912e-58c9b1c49372)

자바 8 부터는 static 메서드의 선언이 가능해졌고, body를 가질 수 있다 (필요하다)

![image](https://github.com/binary-ho/TIL-public/assets/71186266/66c9c7ca-d8f2-4474-b28b-f16f932e38a1)
![image](https://github.com/binary-ho/TIL-public/assets/71186266/dfca8498-1cb7-45e9-a680-4d3033ee8ab6)


### 2.3 상속과 구현

자바의 클래스는 C++의 클래스와 달리 다이아몬드 상속 문제로 인해 단일 상속만을 지원한다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/353f363f-3851-4795-a197-cd07d3d2325d)


위 그림과 같이 여러 클래스를 extends 할 수 없다.

한 클래스는 여러 인터페이스를 구현할 수 있다!

![image](https://github.com/binary-ho/TIL-public/assets/71186266/a42108dc-b86e-427b-b666-a629852cd967)

인터페이스가 꼭 이 문제를 해결하기 위해 도입된 것이라는 말이 있지만 그건 오해다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/f5c0793f-cc40-4373-a537-742fee930795)

그리고 한 인터페이스는 여러 인터페이스를 확장(상속) 할 수 있다.

### 2.4 Object 메서드는 interface가 상속하는가 구현체가 상속하는가?

예시로 사용한 GreedyInterface의 구현체인 GreedyInterfaceImpl 클래스를 구현했다.

그리고 아래와 같이 참조변수 greedyInterface는 Object 클래스의 메서드를 호출할 수 있다.
![image](https://github.com/binary-ho/TIL-public/assets/71186266/58dec6e9-4d2d-4c28-ad2c-fe4110a0efe1)

모든 클래스의 최상위 클래스는 Object이다.

그럼 클래스인 GreedyInterfaceImpl 덕분에 메서드의 사용이 가능한걸까?

아니다, 이는 최상위 인터페이스인 GreedyInterface가 암묵적으로 Object의 public 메서드를 선언하기 때문이다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/28bf46e5-ef3c-4776-800b-4c5e41f5de4b)

위 글을 보면, 직접적인 superinterface가 없는 인터페이스 즉, 최상위 인터페이스는 Object에서 선언된 public 인스턴스 메서드를 암묵적으로 선언한다고 되어 있다.

그리고 Object에서 final로 선언된 메서드를 인터페이스가 선언하면 컴파일 에러가 발생한다고 적혀 있다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/3b8e1991-6492-498a-a90d-f9af6becd9e7)

Object에서 final로 선언되지 않은 hashCode나 equals는 문제 없지만,

나머지 메서드들은 위와 같이 에러가 발생한다.


## Reference
- 자바의 정석 <남궁성>
- 스프링 입문을 위한 자바 객체지향의 원리와 이해 <김종민>
- 이펙티브 자바 <조슈아 블로크>
- 오브젝트 <조영호>
- Oracle - Chapter 9. Interfaces
- https://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan
