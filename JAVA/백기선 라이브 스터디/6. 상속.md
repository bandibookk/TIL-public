
# 1. 자바에서의 상속

## 1.1 부모 자식 사이
흔히 자바의 상속을 설명할 때 가계도를 열심히 그려 보여준다. <br>
'상속'이라는 단어는 꽤나 그럴듯 하다. 상위 클래스를 부모로 두고, 하위 클래스를 자식으로 생각하게 만들고, 부모가 자식에게 무언가 물려 받는다는 인상을 준다. <br> 
이해하기도 쉽고, 설명해주기도 편하니까 많은 곳에서 이렇게 설명되고 있다. <br>
이런 비유는 객체지향성의 이해를 떨어뜨리는데에 큰 공헌을 해주었다. <br> <br>

## 1.2 클래스
클래스란 무엇일까? 객체지향은 현실의 모든 물리적 추상적 개념들을 '객체'로 바라보는 패러다임이다. <br>

이러한 객체를 실제 코드로 구현할 때 우리는 '클래스'를 통해 표현할 수 있다. <br>
클래스는 직역하면 '분류'로 아리스토텔레스의 `classification`에서 나왔다. 어떤 객체는 추상적인 분류가 있다. 예를 들어 내가 지금 앉아있는 `퍼시스 CH2811 의자 제품번호 x번`은 '의자'라는 개념으로 분류할 수 있겠다. 혹은 제품명인 `퍼시스 CH2811`로 분류될 수도 있겠다. <br>

![image](https://github.com/java-live-study/live-study/assets/71186266/34cfcd18-2f25-4674-adbf-3f2ad461b3e5)


내가 앉아있는 이 물체는 `의자`, `퍼시스 CH2811` 중 하나인 물건이다. <br>

객체지향 패러다임에서 `의자`는 클래스이고, 내가 앉아있는 물체가 인스턴스가 된다. <Br> <br>

## 1.3 extends
자바에서 상위 클래스를 하위 클래스가 '상속'하려 할 때 `extends`라는 키워드를 사용한다. <Br>
그렇다. 자바는 애초에 이걸 `확장`이라고 부르기로 했다. <br>

그래서 우리는 단순히 `자식이 무언가를 물려 받음`과 같이 생각하는 것 보다, `재사용과 확장`의 개념으로 이해하는 것이 적절하다. <Br>
말이 어려운데, 그냥 가계도가 아니라 `동물 분류도`를 보면 된다.

![image](https://github.com/java-live-study/live-study/assets/71186266/92dde248-8166-488a-9a3b-966f3d3dc490)

<br>

양서류는 변온척추동물의 자식인가? -> No <Br>
양서류는 척추동물의 자식인가? -> No <br>
**단순히 개념의 세분화와 일반화의 관계로 봐야한다.** <br>

**객체지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 그대로 받는 것 뿐만 아니라 필요한 특성을 `extends`, 추가-확장해서 사용하는 것이다.** <Br>

상위 클래스로 갈 수록 상위 개념이므로 `추상화`, `일반화` 되어가고, 하위 클래스로 갈 수록 하위 개념이므로 `구체화`, `특수화` 되어야 한다. <br>

## 1.4 하위 클래스는 상위 클래스이다.
상위 클래스와 하위 클래스간의 관계를 한 문장으로 표현하자면, `하위 클래스는 상위 클래스이다`라고 할 수 있다. <br>
내가 앉아있는 이 물체

![image](https://github.com/java-live-study/live-study/assets/71186266/34cfcd18-2f25-4674-adbf-3f2ad461b3e5)

이 친구는 `퍼시스 CH2811` 라는 제품을 공장에서 설계대로 찍어낸 결과물 하나이다. <br>
우리는 아래와 같이 말해도 문제 없다 

#### 퍼시스 CH2811은 의자이다.
문제가 있는가? 없다. <br>
틀린 말인가? 맞는 말이다. <br>
양서류의 예시로 돌아가자

- 양서류는 변온척추동물의 자식인가? -> No
- 양서류는 척추동물의 자식인가? -> No
- 변온척추동물은 척추동물의 자식인가? -> No

그리고, <Br>

- 양서류는 변온척추동물인가? -> Yes
- 양서류는 척추동물인가? -> Yes
- 변온척추동물은 척추동물인가? -> Yes

전혀 문제 없다. <Br>
결론은 **하위 클래스는 상위 클래스이다.** <br>
라고 표현할 수 있다는 것이다. <br>
이런 관계를 `is a kind of 관계`라고 부른다. <br>
하위 클래스 B는 상위 클래스 A의 한 종류인 것이다. <br>
`B is a kind of A!` 이는 우리가 평소에 쓰는 `Class-분류` 라는 표현과도 아주 잘 맞아 떨어진다. <br>

마지막으로 위에서 의자를 예시로 들을 때 `내가 앉아있는 이 물체`라고 불렀는데, `이 의자는 물체이다.` 라고 표현해도 문제는 없다. <br> 아름답다. Java의 모든 클래스의 최상위 클래스의 이름은 다름 아닌 `Object`이다. 세상 모든 것을 Object로 바라보자는 객체지향 패러다임에 아주 걸맞는 표현이다.  

<br>

이 하위 클래스는 상위 클래스이다 라는 표현은 매우 중요하다. 이는 코드에서도 나타난다.

## 1.5 상위 클래스 참조변수

하위 클래스의 인스턴스는 상위 클래스 참조 변수가 가리킬 수 있다. <br>
예를 들어 `Animal`과 이를 상속 받은 `Dog`가 있다고 생각해보자. <br>
이 때 아래와 같은 표현 둘 다 문제 없다.

```java
Dog dog1 = new Dog();
Animal dog2 = new Dog();
```

왜냐하면 `하위 클래스는 상위 클래스`이기 떄문이다. <Br>
강아지는 동물이다. 그러므로 동물 참조 변수로 강아지 인스턴스를 가리킬 수 있다. <Br>

## 1.6 상하위 상하위 상하위

하위 클래스가 상위 클래스에 접근할 때는 `super`를 통해 접근할 수 있다. <br>
그리고 `super()` 메서드를 통해 부모 클래스의 생성자를 호출할 수 있다. <br>
참고로 바로 상위의 클래스를 참조하는 것이고, `super.super`와 같은 접근은 불가능하다. <br>

그리고 상속 자체를 막아버릴 수도 있는데, <Br>
상수를 정의할 떄 사용하는 `final`키워드를 통해 상속 불가능한 클래스를 만들 수 있다. <Br>
메서드 또한 `final`을 붙이면 오버라이딩이 불가능하다.



# 2. 다형성
상속은 재사용과 확장의 개념이라고 말했다. <Br>
기존의 상위 분류가 가진것을 재사용하고, 확장할 수도 있다. <br>
만약 위의 예시에서 `Bird` 클래스가 추가 되었다고 생각해보자. <Br>
개와 새는 둘 다 동물이지만, 하나 부터 열까지 다른 점이 너무나도 많다. <br>
같은 동물이지만 상황에 따라, 맥락에 따라 다르게 행동하는데, 이런 개념을 `다형성`이라고 부른다. <Br>

## 자바의 다형성

자바에서의 다형성은 오버로딩과 오버라이딩을 통해 구현된다. <br>

1. 오버로딩 : 적재하는 물건을 과적재한다는 의미로, 같은 메서드를 매개변수의 타입이나 갯수에 따라 다른 동작을 할 수 있게 만들어준다. <br>
2. 오버라이딩 : 올라탄다는 의미로, 상위 클래스에서 정의된 함수에 올라타는 느낌.. "재정의"이다. 만약에 뒤에서 본다면 원래 있던 것은 아래에 깔려 보이지 않을 것이다. -> 하위 클래스가 오버라이딩한 메서드가 있을 때, 하위 클래스 인스턴스를 가진 참조 변수에서 해당 메서드를 호출한다면 하위 클래스의 메서드가 호출된다.


<br>

예를 들어 
```java
  Animal ani = new Animal();
  ani.call();

  Animal ani2 = new Dog();
  ani2.call();
  
  Dog ani3 = new Dog();
  ani3.call();
```
`call()` 이라는 메서드를 Dog가 오버라이딩 했을 떄, ani2의 호출은 Dog에서 재정의한 메서드가 호출된다. <br>

주의해야 할 점은 그렇다고 해서 ani2가 Dog만이 가진 메서드를 호출할 수 있다는 것은 아니다. <br>
Animal엔 없고, Dog에만 있는 메서드가 있다면, ani2에선 호출이 불가능하다. <br>

이런 동작들을 가능하게 하기 위해, 힙 영역에 인스턴스가 만들어질 때, 상위 클래스의 인스턴스들과 함께 만들어진다. 다만, ani2의 경우 참조 변수가 만들어진 인스턴스 중 Animal 클래스의 인스턴스를 가리킨다. <br>
ani3의 경우 힙 영역에 Animal과 Dog가 만들어지고, Dog를 가리키게 되는 것이다. <br>

이렇게 상황에 따라 어떤 메서드가 호출될지 다르다. 자바는 컴파일시에 객체 타입에 대한 정보를 가지고 있고, 런타임시 실제로 인스턴스를 생성해낸다. <br>
그래서 참조변수가 상위 클래스로 되어있는 경우, 실제로 어떤 인스턴스를 가리킬지는 런타임에 결정되야 된다. <br>

이렇게 동적으로 런타임에서 어떤 메서드를 호출할지 결정되는 상황에서 `동적 메서드 디스패치`가 발생하고, 컴파일 시점에서 결정되는 경우를 `정적 메서드 디스패치`라고 부른다. <Br>


## 3. 추상 클래스

추상 메서드는 메서드 선언부는 있는데, 구현부가 없는 형태의 메서드이다. <br>
이러한 추상 메서드를 하나라도 갖고 있는 클래스는 추상클래스로 선언 되어야 한다. <br>

일종의 설계도인데, 필요한 상황이 정해져 있다.

- 인스턴스가 만들어 져서는 안 됨
- 메서드가 호출되면 안 됨
- 하위 클래스에서 해당 메서드의 오버로딩을 강제해야함
- 상위 클래스의 객체 참조 변수로 만든 인스턴스가 해당 메서드를 호출할 수 있어야 함.

예를 들면 이해가 쉬운데, 위에서 다형성의 예시를 들을 때 Dog와 Bird는 이동 방식이 다름을 이야기 했다. <Br>
문제는 더 상위 개념인 Animal은 어떻게 움직이는가? <br>

이런 '개념'은 행동을 정의하기가 어려울 수 있다. <br>
동물이라는 개념 그 자체는 행동을 할 수 없다. <Br>
그 하위 개념인 강아지 고양이가 가능할 뿐이다. <Br>
이런 경우 추상 메서드가 굉장히 적절하다.
