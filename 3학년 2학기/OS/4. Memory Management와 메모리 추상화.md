# 4. Memory Management

프로그래머들이 이상적으로 바라는 메모리는 이래야한다.
- 크고,
- 빠르고,
- 지워지지마! (nonvolatile)

이러한 메모리의 목표를 달성하기 위한 다양한 방법을을 배우는 단원이다.


## 3.1.1 Memory hierachy
메모리는 다음 세 계층을 가지고 있다.
1. Cache
2. Memory
3. Disk

**캐시는** 주로 자주 사용하는 데이터를 임시 보관해 두는 곳이다. **용량이 매우 작고, 속도가 매우 빠르며, 아주 비싸다!** <br>
**메모리는** 우리가 아는 RAM 같은 저장소가 메모리이다. 캐시 보다는 느리지만, 용량이 더 크고 가격이 조금 더 싸다 (그래도 비싸다.) 우리가 **주 메모리라고 부르는 것이 바로 이 메모리이다.** 캐시는 주로 이 메모리의 버퍼 역할을 한다. <br>
디스크는 우리들이 데이터를 저장하는 주 디스크이다. 비휘발적이고, 용량이 매우 크고, 싸다. 대신에 느리다. 

## 3.1.2 Memory Manager
메모리 매니저는 다음과 같은 역할을 한다
1. **OS의 한 부분으로서,** 메모리 계층을 관리하는 역할. 
2. 메모리의 어떤 부분이 사용중이고, 사용중이지 않은지 추적하는 역할
3. 프로세스에게 메모리를 할당하고, 회수하는 역할
4. 메모리와 디스크의 Swapping을 관리하는 역할


## 3.1.3 Multiprogramming with Fixed Partitions

1. **Multi input Queue** <br>
Fixed Memory Paritions라는 이름 그대로, 메모리에 영역을 나누어, 각 파티션별로 Job들을 받을 Queue를 달아줍니다. 위에서 부터 아래로 점점 더 작은 job들을 위한 공간이 할당되며, 가장 아래에는 OS가 있습니다. <br> **프로세스들은 본인의 job을 받아들일 수 있는 파티션 중 가장 작은 곳, 즉 가장 아래쪽에 위치한 파티션의 큐에 들어갑니다.** <br> 이런 방식에는 어떤 문제가 있을까요? 작은 job들만 모이게 된다면, 다른 메모리는 놀고 있는데도 분산되지 않고, 아랫단에 모든 job들이 몰리게 됩니다. <br> 이는 분명히 비효율적인 방식입니다.

![11](https://user-images.githubusercontent.com/71186266/198308712-8d715fa9-ae40-4b88-9a65-b21f933aafaf.png)

# 3.2 메모리 추상화: 주소 공간
프로세스가 주소 공간을 추상화 하지 않고 사용하는 것은 단점이 있다.
1. **프로그램이 물리 메모리의 모든 주소에 접근 가능하다.** <BR> 
프로그램이 물리 메모리의 모든 주소에 접근한다면 무슨 일이 일어날까? 프로그램이 실수로! 혹은 의도적으로 **운영체제를 파괴할 수 있다.** 이는 시스템을 중단 시킬 수도 있다.

2. **여러 프로그램을 동시에 작동시키는 것이 어려워진다.** <BR> 
메모리 추상화가 없는 시스템에서는 한 순간에 여러 프로그램들이 동시다발 적으로 실행되거나, 클릭 한번으로 아주 빠르고 간단하게 프로그램 제어를 넘기는 것의 구현이 어렵다. 


## 3.2.1 주소 공간 개념 - Relocation and Protection

**여러 프로그램들을 동시에 메모리에 적재하고, 서로 간섭 없이 실행하기 위해 Relocation과 Protection이 도입되었다.**

1. **Relocation:** 주소공간을 재배치한다. 절대적인 주소에 프로그램을 저장한다면 무슨 일이 일어날까? <br> **프로그램은 자유롭게 메모리 어느 주소에서든지 실행될 수 있어야한다.** 예를 들어 아파트 203호에 이진호가 살기로 되어있는데, 장동호도 꼭 203호에만 살 수 있다고 한다면? 예시가 적절한지는 모르겠지만, 이진호가 사는 동안엔 장동호가 살 집이 없어진다. <br> 반면 상대적인 주소를 갖는다면 이야기는 쉬워진다. **이진호나 장동호나 8평만 있으면 몇 호에 살던지 상관 없다면,** 이진호가 203호에 사는 동안에는 장동호는 빈 방을 찾아 206호에 살아도 되고, 장동호가 203호에 사는 동안에는 이진호는 8평짜리 방 아무 곳이나 찾아서 살면 되는 것이다. <br> **따라서 프로그램 안의 코드나 프로시저 등의 내용물들이 시작 주소로 부터 상대적인 주소를 갖는다면, 프로그램은 어느 위치에서 시작되는 상관 없게 되는 것이다.** 
2. **Protection:** 만약에 한 프로그램이 자신의 영역 밖에 접근하는 일이 있다면 무슨 일이 벌어질까. 말 할 것도 없이 다른 프로그램에 막대한 피해를 끼칠 수도 있고, 본인 프로그램도 요상하게 작동 할 수가 있다. 아예 메모리로 있지도 않은 위치를 건들일 수도 있는 등 여러 문제가 발생한다. Protection은 이런 주소 공간 보호 방식에 대한 이야기이다.

## 3.2.1 정책들 - Use Base And Limit Register

1. 기존 정책
- Relocation: 프로그램 로딩시 시작 주소를 얻어, resource 주소들에 더해줌으로서, 절대 주소를 얻는다.
- Protection: IBM 360의 방식으로, 메모리를 다 2KB 크기의 블록으로 자른 다음, 이 블록들을 나누어 준다. 4bit짜리 보호 키를 CPU 내부 PSW와 블록에 저장한다. 이후, protection key의 대조를 통해 key값이 일치할 때만 접근을 허용한다.


### 2. Use Base And Limit Register

기존의 정책과 변수-프로시저 주소가 상대적인건 동일하다. 이 정책에서는 **Base 레지스터와 Limit 레지스터를 도입했다.** 
- **Base Register:** 베이스 레지스터는 **프로그램 시작 주소를 저장한다.** 이후, 일종의 Bias값이 되어 **메모리에 access시마다 매번 Base + 상대주소를 계산하여 실제 주소를 찾아낸다.**
- **Limit Register:** **현재 프로세스의 크기가 저장된다.** 이 레지스터를 통해 프로세스가 참조하려는 주소가 limit 레지스터 보다 큰지 확인할 수 있다. 클 경우 참조를 중단하고 결함(fault)를 발생시킨다.

<br>

이 방법은 기존 연산에 비해 시간이 오래걸린다! 매 연산시마다 레지스터 값을 더해주어야 하기 때문이다. 하지만 기존 정책에서는 2KB씩 블록을 나누는 바람에 쓸대없이 낭비되는 메모리들이 많았다. 이 Base Register와 Limit Register를 통해 메모리를 더 아낄 수 있게 되었다. 이는 메모리-타임 트레이드 오프라고 할 수있다. 최근의 PC들은 후자를 더 많이 사용한다.

 ## Reference
 - 운영체제론 <ANDRWE S. TANENBAUM 저>
