# 3.2 File Implementation
파일 구현의 가장 큰 쟁점은 **어느 블록이 어느 파일에 속하는지 추적하고 관리하는 것이다.** 이를 위한 다양한 기법을 살펴보자.

## 2.1 Contiguous Allocation - 연속 할당
![4 3 연속 할당](https://user-images.githubusercontent.com/71186266/203041799-d10d97a6-349d-40c7-91c9-2b446ed1cfb3.png)

말 그대로 **연속된 디스크 블록에 저장하는 것이다.** 연속대로 저장하는 만큼, 애매한 크기가 차지중일 경우 어느 정도의 메모리 낭비는 있다. 두 개의 장점을 지닌다.
1. 구현이 쉽다. 숫자 단 두개, **시작 블록과 블록의 갯수만** 알면 된다.
2. 읽기 성능이 뛰어나다. 한번의 동작으로 전체 파일을 디스크에서 읽을 수 있기 때문이다. 첫 번째 블록으로의 탐색 동작 이후에는 더 이상의 탐색 없이 디스크 최대 대역폭으로 읽어 버릴 수가 있다. 간단하면서 높은 성능을 제공한다.

불행하게도.. 연속할당에는 심각한 단점들이 있다. <br>

**시간이 흐를 수록 디스크 공간이 조각난다** -> 파일들이 삭제되면서 구멍이 나는데, 이 구멍을 매우기 위한 복사나 통합의 코스트가 너무나도 커서 그대로 냅두게 된다. 이에 버려지는 공간이 너무 많아진다. <br> **결국, 파일의 크기가 얼마가 되는지 미리 알아야 가능한 구현..** <br>

이 단점이 너무 크지만, 연속 할당이 적용 가능한 경우 아주 유용하게 쓰인다! 바로 CD-ROM이나 DVD, 한 번만 쓰기가 가능한 광미디어 등에 사용할 때 아주 유용하다! 이들의 출현으로 연속 할당은 다시 좋은 아이디어로 조명 받았다.

## 2.2 Linked List Allocation - 연결 리스트 할당
연결리스트의 형태로 할당한다. **각 블록의 첫 번재 워드는 다음 블록을 가리키는 포인터로 사용하고, 나머지 공간에는 데이터를 저장하는 방식.** <br>
1. 당연히도, 모든 디스크 블록을 알차게 쓸 수 있다! 디스크 단편화로 인한 낭비가 사라진 것~ <br>
2. 또한 디렉터리 엔트리에는 파일의 첫 번째 디스크 블록의 주소만 저장하면 되서 너무 간단하다~ <br> <br>

그리고 단점 ㅠㅠ <br>
1. 링크드 리스트 답게 **탐색 속도가 너무 느리다.** 
2. 블록에서 수 바이트 정도가 포인트 저장에 쓰여서, 블록 데이터 양이 2의 제곱이 아니게 된다. 큰 문제는 아닌데 다소 비효율적이다.
3. 블록 단위로 읽으려면 블록을 복사하고 붙이는 약간의 오버해드가 발생한다.


## 2.3 FAT - 연결 리스트 할당  
**메모리에 존재하는 파일 할당 테이블 FAT를 이용한 연결 리스트 할당.** **-> 파일 할당 테이블 File Allocation Table** <br>

![4 3 링크드](https://user-images.githubusercontent.com/71186266/203041808-a38cb6cb-9fe7-4b95-8b61-227b5ba163de.png)
![4 3 fat](https://user-images.githubusercontent.com/71186266/203041802-e5cc935e-aa18-4bac-bc56-b3dc64fefe47.png)

위에서 언급한 연결 리스트 할당의 단점 2개를 메모리에 존재하는 테이블을 이용함으로서 해결하려는 시도. 
1. **블록을 가르키는 포인터를 FAT에 저장! 체인을 따라가며 블록을 탐색한다.** -1은 체인의 끝을 의미한다. <br> 이러한 사용으로 한 블록 전체를 데이터 저장에 사용할 수 있게 된다!
2. 임의 접근이 아주 쉬워진다. 체인이 메모리에 존재하기 때문에, 디스크 참조가 필요 없다!

<br>

하지만 FAT을 이용한 방법에도 단점은 있다. <br> **전체 테이블이 메모리에 존재해야 잘 동작한다!** 그리고 **차지하는 양이 디스크 용량에 비례한다.** <br> 분명 효율적이지 않은 방법이다..


## 2.4 I-node :star:
**index-node!** **i-node는 파일의 속성들과 파일의 디스크 블록 주소를 가진다.** <br>

![4 3 i-node](https://user-images.githubusercontent.com/71186266/203041806-0ddf817b-d4d1-4e29-b3b6-f51b2260024f.png)


i-node
1. 파일의 속성들
2. 파일의 디스크 블록 주소
를 가진다. <br>

i-node를 통해 파일의 모든 블록을 발견할 수 있다. **장점들**
1. 어떤 파일을 열면(open) 해당 파일의 i-node만 메모리에 가지고 있으면 된다.
2. 만약 하나의 i-node가 n 바이트를 차지하고, 최대 k개의 파일을 동시에 열 수 있다면, 열린 파일들의 i-node 배열을 저장하기 위해선 kn바이트만 필요한 것을 바로 알 수 있어서, **시스템은 이 정도의 공간만 미리 예약해두면 된다. 필요한 공간을 바로 알 수 있다.**
3. 디스크 용량에 비례하지 않는 테이블을 가진다! **동시에 개방되는 최대 파일 개수만큼의 배열만 가지고 있으면 된다.**

<br>

**단점**
1. 각 i-node에 디스크 블록 주소를 저장할 수 있는 공간이 유한함.
**해결책**
1. i-node의 마지막 주소가 가리키는 블록에 데이터 대신 다른 디스크 블록들의 주소를 넣는 것!
2. (발전) 마지막 두 세 개에 여러 비스크 블록 주소들을 가진 디스크 블록을 가리키거나, 그런 주소를 모아둔 블록을 가리키는 것!

## Reference
- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
