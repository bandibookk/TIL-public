# 3.3.3 TLBs
페이징의 기본 원리를 알았으니, 구현에 대해 이야기 해보자. 가장 주요한 이슈는 아무래도 아래 2가지다
1. 가상 주소에서 물리 주소로의 변환은 빨라야 한다.
2. 가상 주소 공간의 크기에 따라 페이지 테이블의 크기도 커져야 한다.


주소공간 크기 문제는 생각보다 심각하다.  <br>
**예를 들어 32bit address space에서 4KB 크기의 페이지를 사용하는 경우를 살펴보자.** <br>

32-bit 주소 공간은 총 2^32개의 공간이 있다. 그리고 4KB는 2^12 Byte이다. 2^32 = 2^20 * 2^12 = 2^20 * 4K 이므로, **2^20개의 페이지. 즉, 4KB 크기 1 million 의 page를 수용하게 된다.** 이는 또 1 million의 페이지 테이블 엔트리를 필요로 한다. 또 프로레스별로 페이지 테이블을 줘야한다. <br>
이런 상황에서 64-bit 주소 공간은 어떻게 될까? 상상 이상의 숫자를 가지게 된다.


## 1. Two designs
1. **하드웨어 레지스터에 한개의 테이블만 갖기** <br>
빠른 하드웨어 레지스터 배열에 단일 페이지 테이블을 사용하는 설계이다. 우리가 아는 페이지 테이블과 같은 형태를 띈다. 어떤 프로세스가 실행될 때 OS는 메모리에 있는 프로세스 테이블 전체를 하드웨어 레지스터에 저장하자는 것이다. <br> **추가 메모리 참조가 없는 만큼 아주 빠르지만,** 페이지 테이블이 커지면 비용을 감당할 수 없고, **context switch 마다 테이블 페이지 적재 비용이 비싸다.**
2. **메모리에 테이블 한개만 갖기** <br> 페이지 테이블의 시작 주소를 가리키는 하나의 레지스터만 있으면 된다. context switch 시에 레지스터만 바꿔주면 된다. <br> 대신 명령 실행시 페이지 테이블 엔트리 참조를 위한 메모리 참조가 필요해서 (결국 mapping을 해줘야 해서) 느리다!

## 2. TLBs
**Translation Lookaside Buffers!** <br>
제시될 모든 방법들의 기초를 마련하는 어떤 관찰이 있다. 그것은 
#### 대부분의 프로그램들은 적은 개수의 페이지들을 집중적으로 참조하는 경향이 있다는 것이다. :star:
결국 페이지 테이블 엔트리 중에서 일부만 빈번하게 참조되고, 다른 엔트리 들은 아주 드물게 참조된다! <br> <br>

이런 상황.. 익숙하다.. 이런 상황에는 뭐다? 캐싱이다~ <br>

**Translation Lookaside Buffers! TLB는 페이지 테이블의 참조가 없이도 가상 주소를 물리 주소로 매핑할 수 있는 작은 하드웨어다.** 또는 **Associative Memory - 연관 메모리라고도 부른다!** 일반적으로 MMU 내부에 존재하며, 적은 갯수의 겐트리를 갖는다! 대부분 64개 미만의 엔트리를 갖는다. <br>

(TLB 그림)

각 엔트리는 한 페이지에 대한 정보가 적혀있다. <br>
가상 페이지 번호와 물리 페이지 프레임 번호 뿐만 아니라, Modified bit, Protection bit 등의 정보도 포함한다. vaild 비트는 엔트리의 유효 여부를 나타낸다. <br>
**TLB는 모든 엔트리가 동시에 검색된다. (병렬로 검색된다.)**

### 3. TLB의 동작
1. MMU는 우선적으로 요청된 가상 페이지 번호를 TLB에서 찾는다.
2. 있는 경우 페이지 프레임 넘버로 바로 주소 변환을 실행한다.
3. **없는 경우, TLB 미스 발생!!**
4. MMU는 페이지 테이블을 검색. 해당 페이지 테이블 엔트리를 찾는다.
5. **TLB 엔트리 중에 하나를 선택하여, 내용을 교체한다.**
6. 새로 찾은 페이지 테이블 엔트리 내용을 TLB 엔트리에 기록한다.
7. **교체될 떄, 수정 비트는 페이지 테이블에 기록한다.**  

### 4. 소프트웨어 TLB
MMU가 아닌 소프트웨어로 TLB를 구현해 보자! <br>
TLB를 소프트웨어로 구현하면 MMU에 여분 공간이 생겨서 다른 성능도 개선할 수 있고, 부하도 적고 좋다. <br>
소프트웨어 TLB에서 TLB 미스는 다음과 같이 처리된다. 
1. 페이지 테이블을 찾는다. (하드웨어도 마찬가지)
2. **페이지 테이블 또한 페이지 프레임에 존재하고, 이를 위한 TLB 검색이 또 발생한다.**
3. **페이지 테이블을 담고 있는 페이지 프레임의 정보가 TLB에 없다면, 추가적인 TLB 미스가 발생한다.**
4. 반복적인 TLB 발생...........

이런 문제의 해결은 **TLB 엔트리를 위한 큰 소프트웨어 캐시로 해결할 수 있다.** <br>
이 소프트웨어 캐시를 위한 페이지 정보는 항상 TLB에 존재한다!! OS는 이 소프트웨어 캐시를 먼저 검색해서 반복적인 TLB 미스를 줄여버린다!

### 5. 소프트웨어 TLB Miss의 종류
1. **soft miss** <br> 참조하려는 페이지가 **메모리에 있지만,** TLB에 정보가 없는 상황
2. **hard miss!** <br> 참조하려는 페이지가 TLB, 메모리에 둘 다 없어서 **디스크 I/O가 필요한 상황** <br> 대충 몇 밀리초로 소프트 미스에 비해 백만 배나 느리다

- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
