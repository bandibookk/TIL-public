# 3.3.2 Page Table
페이지 테이블은 가상 주소를 물리 주소로 매핑하기 위해 존재한다. <br>
Page Table을 일종의 함수로 생각해서 **Virtual Page Number가 인풋이 되고, 물리 페이지 프레임 넘버가 아웃풋이라고 생각하면 편하다.**
![page table1](https://user-images.githubusercontent.com/71186266/205454922-b5b6b2d0-63b0-4385-9a8d-4bcf967c9969.jpg)
바로 이렇게! <br>
가상 주소를 두 부분으로 나눌 수 있는데, 상위 4비트 정도를 **페이지를 가리키는 페이지 번호로** 사용하고, **나머지 하위 비트를 바이트 오프셋으로** 사용할 수 있다. <br>
(`가상 주소` = `가상 페이지 번호` + `오프셋`) <br>

페이지 번호 역할을 하는 앞 부분만 똑 떼어서 인풋으로 넣어주고, 결과로 물리 페이지 프레임 번호가 나오면 그 뒷부분에 나머지 뒷 부분을 딱 붙여주면 된다. <br>
그 결과로 **실제 페이지 참조에 이용할 물리 주소가 나오게 된다** <Br>
`물리 주소` = `페이지 프레임 넘버` + `오프셋`

그림을 참고해보자.

![page table2](https://user-images.githubusercontent.com/71186266/205454925-fc0af337-eb3f-4985-ad59-2c86417369f1.jpg)

그림의 가장 아래 부분에 가상 주소가 있다. 이 부분의 **앞 4비트가 가상 페이지 번호이다.** <br>

매핑 과정은 위와 같다. 요약하자면...
1. 가상 주소에서 가상 페이지 번호를 뗴어낸다.
2. 가상 페이지 번호를 이용해 page table에서 물리 페이지 프레임 번호를 알아낸다
3. `물리 페이지 프레임 번호`와 가상 주소의 나머지 부분 `오프셋`을 붙여 준다.
4. **실제 메모리 참조에 이용할 물리 주소가 만들어진다!**
5. `물리 주소` = `페이지 프레임 넘버` + `오프셋`


## 페이지 테이블 엔트리 구조
페이지 테이블의 엔트리 구조는 CPU 종속적이다. 일반적으로는 **32비트 크기를 갖고,** 공통으로 가지는 정보들만 살펴보자.

#### 1. 페이지 프레임 번호
역시 가장 중요한 부분은 **페이지 프레임 번호 부분인데, 가상 주소를 물리 주소로 매핑하는 기능을 담당한다.** <br>

#### 2. `present/absent` 비트
`present/absent` 비트도 중요하다. 이 비트가 1인 경우 해당 엔트리가 유효하고, 페이지 프레임 번호를 사용할 수 있다는 뜻이다. 쉽게 말하자면 그냥 해당 페이지 넘버가 어떤 페이지 프레임에 매핑 되어있는 상태라는 것이다. 0인 경우 그 반대이다.

#### 3. Protection bit - 보호 비트
보호 비트는 어떤 접근이 허용 되어 있는지를 표시한다.1비트의 경우 **1의 경우 읽기만 가능, 0의 경우 읽기/쓰기가 모두 가능하다.** 아 특이하다~

#### 4. Dirty Bit - Modigied bit :star:
더리빗~ <br>
수정 비트는 페이지의 내용이 변경될 때 세팅되는데, 이는 **운영체제가 페이지 프레임을 교체할 때 영향을 준다.** <br>
**수정 비트가 1로 설정 되어 있으면 dirty 상태라고 한다.** 0이면 clean 상태라고 한다.

#### 5. Referece bit
참조 비트는 해당 페이지가 읽기나 쓰기로 접근 되었을 때 설정된다. 이 페이지는 **페이지 폴트 처리를 위해 교체할 페이지 프레임을 선택할 때 이용된다.** <br>
최근에 사용된 페이지 보다는 그렇지 않은 페이지를 교체 대상으로 삼는게 성능에 좋은데, 이 선택에 참조 비트가 이용된다!

#### 6. caching disabled bit
캐시 무효화 비트는 페이지의 캐싱 가능 여부를 가리킨다. 이 기능은 페이지가 메모리가 아닌 레지스터에 매핑 되어 있을 떄 중요한 역할을 한다! 이 비트를 통해 캐싱을 끌 수 있다.## Reference

- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
