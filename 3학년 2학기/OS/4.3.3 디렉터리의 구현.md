
# 4.3.3 디렉터리의 구현
**디렉터리의 주기능은 파일의 ASCII 이름을, 데이터를 찾기 위한 정보로 매핑하는 것이다!** <br>
파일을 읽기 전엔 우선 OPEN해야 한다. OS는 사용자가 제공한 경로 이름을 통해 디렉터리 엔트리를 찾는다. **이 디렉터리 엔트리는 디스크 블록 접근을 위한 정보가 있다.**
<br>

## 1. 디렉터리 엔트리
디렉터리 엔트리는 어떻게 구성될까? <br>
일반적으로는 한 엔트리가 **\<디렉터리 이름, 속성>** 으로 구성된다. 이 '속성' 안에 디렉터리와 관련된 각종 정보들을 전부 저장하는 것이다. <br>
이런 단순한 설계에서, **디렉터리는 고정된 크기의 엔트리 리스트가 되는 것이다** 각 엔트리는 파일마다 존재하고 파일 속성 구조체나 디스크 블록의 주소 등을 가진다. <br>
이러한 직접 저장 방식 외에는 **i-node를 사용하는 방식이 있따.** i-node 시스템에서는, 속성을 디렉터리 엔트리가 아닌 i-node에 저장한다. <Br>
이 경우 당연히 엔트리가 파일 이름과 i-node 번호의 더 짧은 구성으로 만들어 진다. <Br>

## 2. 파일 이름 문제 (중요한가?)
자, 기존에는 고정 파일 이름을 제공했는데, 지금 우리가 평소에 쓰는 파일들의 이름은 매우 가변적이다. <br> 길이가 긴 상황을 고려해 미리 큰 메모리를 예약 해두는 것은 비효율적이다. <br>
**이런 문제의 해결을 위해 엔트리들의 크기가 고정되어 있다는 생각을 버려라!**  <br>

## 3. 파일 이름 가변 길이
다른 기법에서, 디렉터리 엔트리는 일부분에 어떤 **정형화된 조각을 갖는다.** 이 조각에는 엔트리의 길이 부터, 소유자, 생성 시간, 보호 정보와 기타 등등의 속성들로 구성된 정해진 포맷의 데이터들이 따라온다. <Br>
이와 같은 고정 길이의 헤더 다음에 필요한 길이 만큼의 파일 이름이 나온다! (321 page) <br>
이 기법의 단점은 파일이 제거될 떄 디렉터리에 가변 크기의 빈 공간이 생긴다는 것이다. 다른 파일의 진입이 크기가 맞지 않는 이유로 불가능해질 수도 있다. <br>
그리고 **하나의 디렉터리 엔트리가 다수의 페이지에 걸쳐 있을 수 있게 된다는 점이다. 이 때문에 파일 이름을 읽는 동안 page fault가 발생할 수도 있다!** <br>

### 파일 이름들 몰아 넣기
다른 방법으로는 **디렉터리 엔트리 자체는 고정 길이를 가지는 대신, 파일 이름들을 모두 모아 디렉터리 맨 뒷부분의 힙 영역에 배치하는 것이다.** <br>
이 기법의 장점은 한 엔트리가 제거된 다음, 다른 파일이 크기 걱정 없이 이 엔트리를 사용할 수 있다는 것! 이제 파일 이름은 워드 경계에서 시작할 필요가 없으며 파일 이름 뒤에 더미데이터가 올 필요 없다.


## 4. speeding up the file name search
지금까지 본 모든 설계는 파일 이름을 앞에서 뒤로 순차 검색한다. 이런 검색은 당연히 느린데, 개선을 위해 **디렉터리 마다 해쉬 테이블을 사용할 수 있다.** <br>
파일의 검색 또한 같은 절차를 거친다. 매우 빠른 검색을 지원하는 대신 관리가 아주 복잡하다. 때문에 디렉터리에 수 백에서 수 천 개의 파일이 존재하는 것이 일상적인 시스템에서만 진지하게 고려해 볼 수 있다. <br>

**캐시를 사용하는 방법도 고려해볼 수 있다.** <br>
검색 결과를 캐시에 남겨두고, 다음 검색 때 활용하는 것. 

## Reference
- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
