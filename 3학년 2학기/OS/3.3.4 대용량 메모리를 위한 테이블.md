# 3.3.4 대용량 메모리를 위한 테이블
### 큰 가상 공간을 효과적으로 관리하는 두 가지 방법

페이지 테이블을 이용한 주소 변환에 있어 큰 문제 2가지가 있었다. 
1. mapping은 빨라야 한다.
2. page가 너무 커져 버린다.

이 문제들 중, 매핑 속도를 해결하기 위해 도입됐던 것이 바로 **TLB이다.** <br>

**TLB의 도입으로** 페이지 테이블을 이용한 주소 변환에서, 가상 주소를 물리 주소로 변환할 때 **속도를 향상시킬 수 있었다.** <br>
이제, **큰 가상 공간을 효과적으로 관리하는 방법이 필요하다.** 이제부터 이 문제에 대한 두 가지 접근 방법을 알아보자. 

## 1. multilevel page table

그 첫번째는 **다단계 페이지 테이블을** 사용하는 것이다. **multilevel page table**  <br>
페이지 테이블이 너무 큰 상황. page table entry가 너무 많은 상황에서 사용한다. <br>

![multilevel page table](https://user-images.githubusercontent.com/71186266/206837461-a74f2cd7-d1cc-45a9-80a3-8eda86301a5e.png)


그림 (a)는 두 개의 페이지 테이블 필드를 가지고 있는 32비트 주소이다. <br>
구체적으로 아래와 같은 3 부분으로 구분된다.
1. 10 비트의 PT1 필드
2. 10 비트의 PT2 필드
3. 12 비트의 Offset 필드 

**12 비트의 Offset을 가졌으므로, 페이지의 크기는 2^12인 4KB가 된다.** <br>
그리고 PT1, PT2의 20 비트로 페이지를 지정할 수 있다. **20비트이므로 2^20개의 페이지가 존재할 수 있다.** <br> <Br>

multilevel page table의 핵심은 **모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다는 것이다.** <br>
특히 주소 공간에 비어있는 부분들인 data 영역과 stack 영역 사이의 공간을 유지할 필요가 없다. <br> <br>


### 다단계 페이지 테이블의 동작
그림 (b)는 2단계 페이지 테이블이다. 왼쪽을 Top Level 테이블, 오른 쪽을 2nd level 테이블로 본다. <br>

Top-levl page table은 2^10의 1024개 엔트리를 가지고 있다. 따라서, 각 엔트리가 가리키는 2nd level table은 전체 32-bit 2^32인 4GB의 공간을 감당해야 하므로, 하나당 2^32 / 2^10인 -> 2^22 즉, 4MB의 공간을 감당하고 있다. <br>
중요하니 다시 말 하겠다. **2nd level page table은 4MB를 cover 하고 있고, top level page table의 각 table entry는 4MB의 공간을 가리킨다.** <br> <br>

그림의 예에서는 Top-level page entry 0이 text를 위한 페이지 테이블을, entry 1이 data를 위한 페이지 테이블을, entry 1023이 stack을 위한 페이지 테이블을 가리키고 있다. <br>
즉, **가장 아래는 text, 그 위는 data 그리고 가장 윗 부분엔 stack을 위한 테이블이 위치해 있는 것이다.** 다른 엔트리들은 사용되지 않고 있다. <br> <br>

2nd level page table에서는 PT2가 인덱스로 사용되어, 접근하려는 페이지 자체를 담고 있는 page frame number를 찾게 된다. <br>

PT1 = 1, PT2 = 3, Offset =4인 경우 <br>
1. MMU는 Top level page table의 entry 1번으로 간다. (4MB ~ 8MB 부분)
2. 2nd level page table entry의 3번으로 접근한다.
3. 이 엔트리는 4MB 영역에서 12288 ~ 16383에 대응하는 주소를 가진다 (절대 번지로는 4,206,592 ~ 4,210,687)
4. 결국 엔트리는 가상 주소 0x00403004를 포함하는 page가 위치하는 page frame number를 유지한다.
5. 페이지가 존재하지 않는 경우 Present/absent bit가 0으로 되어 있으며, page fault가 발생한다!
6. 존재한다면, page fram number와 Offset값 4를 더해서 물리 주소를 구한다. 
7. **이 물리 주소가 버스를 통해 메모리로 전달된다.**

<br>

주소 공간에는 백만개나 되는 페이지가 존재하지만 **페이지 테이블은 단 4개가 필요한다.** <br>
1개의 Top level page table과 3개의 2nd level page table만이 필요할 뿐이다. <br>

페이지 테이블 level은 3, 4 이상으로도 확장이 가능하지만 3 단계 이상일 경우 복잡도가 커져서 그 가치가 보장되지는 않는다.

## 2. Inverted Page Table




![inverted page table](https://user-images.githubusercontent.com/71186266/206837467-1eb07da9-3d65-4460-88b9-d42ea1d5d149.png)

