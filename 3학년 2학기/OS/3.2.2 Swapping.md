## 3.2.2 스와핑
시스템의 모~든 프로세스들이 필요로 하는 공간을 메모리가 가지고 있을 수 있을까? 그건 어렵다. 
그럼 비싼 메모리의 용량 만큼만 프로그램을 실행시킬까? 그건 좋은 아이디어가 아니다. **그래서 도입된 것이 스와핑과 Virtual Memory이다.** 

<br> <br> 

**스와핑은 프로세스들의 이미지를 메모리에 적재 시켜 실행하다가, 더 이상 실행되지 않을 경우 디스크로 내려 보내는 방법이다.**  <br> 현재 실행중인 프로그램만 메모리에 올리고, 블락 되거나 실행중이 아닐 떄는 디스크로 내리는 것이다. 
이는 프로세스 이미지의 일부만 메모리에 있어도 프로세스를 실행 가능하게 해주는 가상 메모리 개념과 함께, 효율적인 메모리 사용을 제공한다. <br>
swap in으로 process를 디스크에서 메모리로 올리고, 실행 종료되거나 blocked되면 swap out으로 디스크로 내린다. <br>


![swapping](https://user-images.githubusercontent.com/71186266/198308717-73fe07e1-83a2-4afa-adcf-9ffbce0c745a.png)


스와핑은 위와 같이 일어난다. 자유롭게 쓰던 공간을, 다 쓴 다음 내어 주어 다른 프로세스가 사용할 수 있다. <BR> 
그림 (g)를 보면 C와 D 사이의 빈 공간에 프로세스 A가 쏙 들어왔다. 항상 이럴 수 있을까? 마침 공간과 A의 크기가 딱 들어맞았으나, 애매하게 더 작을 수도 있다.

<br>

요컨데, **다른 프로세스들이 들어오기에는 작은 빈 공간이 남을 수도 있다는 것이다.** 이러한 gap을 **Hole이라고 부른다.** <br> 이러한 gap을 없애려면 어떻게 하면 좋을까? 빈 공간들을 모아 프로세스들을 딱 붙여주는 작업이 필요하다. **이러한 작업을 메모리 조각 모음 - Memory Compaction이라고 부른다.** 모든 프로세스들을 **끌어 내려서,** 홀들을 모아 큰 공간을 만들어 내는 것이다!

### 스와핑 안의 프로세스들은 구체적으로 아래와 같이 배치된다.

![room of growth](https://user-images.githubusercontent.com/71186266/198312848-5fc12dd8-ffa6-48ce-a631-db32ded115df.png)


익숙한 그림이다. 메모리 하나에, 여러 영역들이 할당된다. 중간의 메모리 공간은 스택 또는 힙 어느 공간으로도 사용될 수 있다. <br> 만일 메로리가 부족하다면 다른 여분의 공간이 있는 위치로 이동하거나, 스왑아웃 되거나, 강제 종료된다.

 ## Reference
 - 운영체제론 <ANDRWE S. TANENBAUM 저>
