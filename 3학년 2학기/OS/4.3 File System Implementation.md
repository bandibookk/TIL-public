# 4.3 File System Implementation

구현하는 사람의 입장에서의 파일 시스템 관찰
- 어떻게 파일 이름을 부여할 것인가
- 무슨 연산을 가능하게 할 것인가
- 디렉터리 트리의 모양은 어때야 하는가
- 디렉터리의 저장, 디스크 공간 관리 등등을 결정하기 위한 다양한 방법들 살펴보자.

## 3.1 파일 시스템 배치 :star:
![4 3 파일 시스템 배치](https://user-images.githubusercontent.com/71186266/202966364-a951bd11-ca22-4dab-849e-9d36b5f1dbfb.png)


**파일 시스템은 디스크상에 존재한다.** 디스크는 여러 파티션으로 분할되어 있고, **각 파티션에는 독립적인 파일 시스템이 존재한다.** <br> 

**그리고 0번 섹터는 MBR - Mastr Boot Record라고 불리운다.** 컴퓨터를 부팅하는 용도로 사용된다. <br>

MBR 끝에는 **Partition table이 존재한다.** **이 테이블은 각 파티션들의 시작과 끝 주소를 가지고 있다.** <br>

조금 헷갈리는데, 초기에 파티션 테이블에서 하나의 파티션이 active로 설정 되어있다. 컴퓨터가 켜지면 BIOS는 MBR을 읽어서 이를 실행한다. <br>

#### 1. Boot block
MBR 프로그램은 활성 파티션의 위치를 파악하고, **Boot Block이라고 불리는 활성 파티션의 첫 번째 블록을 읽고 실행한다.** 부트 블록에 있는 프로그램은 해당 파티션에 존재하는 OS의 부트 프로그램을 메모리에 적재한다! <br>
모든 파티션은 파티션에 부팅 가능한 OS가 없더라도 **동일하게 부트 블록 부터 시작한다.** 언젠가 이곳에 OS가 설치될 수 있기 때문이다! <br>

부트 블록 부터 시작한다는 점을 제외하면, 디스크 파티션 내에서의 배치는 **파일 시스템마다 매우 다르다!** 위의 그림과 같은 배치가 잦기는 하다. <br>

#### 2. Superblock 
첫 번째 항목 <U>**SuperBlock은 파일 시스템에서 가장 중요한 인자들을 가지고 있다.**</U> 이는 컴퓨터 부팅시나 파일 시스템이 처음으로 접근될 때 메모리로 읽혀지고 아래와 같은 정보들을 가진다.
- **<U>Magic Number: 파일 시스템 유형(type)</U>**
- 파일 시스템 내 블록 갯수

#### 3. Free space mgmt
가용 블록 정보 - 비트맵이나 포인터들의 리스트

#### 4. i-node
**자료 구조의 배열로 파일 마다 하나의 i-node 자료구조가 존재한다! 파일에 대한 모든 것을 가니다!**

5. Root dir: 루트 디렉토리
6. 디스크의 나머지 부분 - 기타 다른 디렉터리나 파일 존재.


### Boot Sequence 다시 정리
1. **BIOS가 MBR을 읽고 실행한다.**
2. 파티션 테이블에서 활성 파티션을 찾아, **파티션의 첫번째 블록인 boot block을 읽고 실행한다.**
3. boot block 안의 프로그램은 해당 파티션의 OS를 실행한다 - 불러와서 메모리에 적재한다.


## Reference
- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
