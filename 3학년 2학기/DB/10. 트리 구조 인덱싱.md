
# 10. B+ Tree: 동적 인덱스 구조
구체적인 코드의 구현과 설명은 [이곳](https://github.com/binary-ho/Algorithm-and-Data-Structure/tree/main/B+Tree)을 참조하라. 직접 작성했다. <br>

![b+tree](https://user-images.githubusercontent.com/71186266/203336428-0d6cd94a-c35e-408d-84b1-ea9cc790d077.png)

B+ 트리 탐색구조는 내부 노드들이 탐색 경로를 가리키고, 단말 노드들은 데이터 엔트리를 가지는 균형트리이다. <br>

**포인트**
- 단말 페이지들을 효율적으로 탐색하기 위해, 이들은 이중 링크드 리스트로 조직되어 있다.
- 삽입 삭제가 수행되어도 트리의 균형이 유지된다.
- 루트를 제외한 각 노드는 최소 50% 이상 채워져 있다.
- 일반적으로 파일은 축소되기 보다는 확장된다. 연산에 대해 굳이 50% 기준을 맞추려 조정하지는 않는다. 
- 균형 트리이기 때문에 어느 단말에서도 높이는 같다.
- 루트 노드만 있으면 높이가 0
- 모든 노드는 m개의 엔트리를 갖는다. d는 차수 order일 때 d <= m <= 2d
- 루트 노드는 1 <= m <= 2d



## 10.3 B+Tree 노드의 형식

![인덱스 페이지](https://user-images.githubusercontent.com/71186266/203336433-1a03d8bf-5468-47ff-a2d0-45901deaee90.png)


각 비단말 노드는 m개의 인덱스 엔트리를 가진다. 인덱스 엔트리는 그 **값과** 자식을 노드를 가리키는 **포인터로** 이루어져 있다. 포인터가 하나 더 많다. <br>
즉, m개의 키값과 m+1개의 포인터를 갖는다. 왜 m+1이냐면, 맨 앞 노드의 값보다 작은 곳을 가리킬 포인터, 맨 끝 노드의 키값 보다 큰 곳을 가리킬 포인터 둘 때문이다.


## 10.4 탐색 연산
주어진 데이터 엔트리가 속해 있는 단말 노드를 재귀적으로 찾아낸다. <br>
key value K를 찾는다고 할 때
1. 각 노드 안의 값들은 오름차순 정렬 되어 있다.
2. 각 노드의 가장 앞의 숫자 보다 작거나, 가장 마지막 숫자 보다 크다면, 해당 노드를 가리키는 포인터를 통해 재귀적으로 다음 노드로 이동한다.
3. 2번이 false인 경우 중간에 있는 값들에 대해 K_i < K < K_i+1인 i를 찾아 i번째 노드로 이동한다.
4. 리프 노드에 도착할 경우 노드를 반환한다!

O(log_m(N))의 탐색을 보인다! 리프 노드에서 K가 없다면 K는 트리에 존재하지 않는다는 결론을 내린다.


## 10.5 삽입 연산

주어진 엔트리에 대해 **해당 엔트리가 속할 단말 노드를 찾아 엔트리를 삽입한다.**
주어진 엔트리는 재귀적으로 아래로 내려가면서 삽입된다. 댜개 단말 노드 부터 내려와서 루트 노드까지 다시 올라 오는 과정을 거친다! <br>
- **노드가 꽉차서 분할 할 때에는 분할로 만들어진 새로운 노드를 가리키는 엔트리를 반드시 부모 노드에 삽입해야 한다!** <br> 마침 새로운 값 K가 삽입되는 만큼, **부모 노드에도 K를 복사해서 올려서 새로운 노드를 가리키게 하면 되겠다.**
- 부모 노드도 포화인 경우 분할해준다. 그러면 2d + 1개의 키 값과 2d + 2의 포인터를 가지게 되는데, 이를 d개의 키 값과 d + 1개의 포인터를 가지는 두 개의 비단말 노드를 만든다. **그럼 남은 하나는? 노드의 중간 값으로 결정, 부모 노드의 부모 노드로 올려 보내서 이번에 새로 만들어진 노드를 가리키게 한다.** 노드 중간값과 새로운 노드를 가리키는 포인터가 하나의 엔트리가 된다. 비단말 노드이므로 이 값은 복사되지 않고 그냥 올려 보내진다. 
- **루트 노드가 분할되는 경우, 새로운 루트 노드가 생성되고 트리의 높이가 하나 증가한다!** 


### 10.6 삽입시 재분배 조건
- 어떤 단말 노드가 포화상태라면, 인접 노드를 가져온다. 여유 공간이 있고 같은 부모를 가지고 있다면 (형제 노드인 경우) 엔트리를 재분배한다!.
- 인접 노드가 부모가 다른 상태이거나, (형제 노드가 아니거나) 포화 상태인 경우 단말 노드를 분할하고 재조정한다.
- **재조정:** 분할 노드, 새로 생성된 인접 노드, 기존 인접 노드 이전 포인터, 차위 포인터를 재조정


## 10.6 삭제 연산
1. 엔트리가 속하는 단말 노드를 찾으며, 재귀적으로 엔트리를 제거한다.
2. 다시 루트 노드로 올라온다.

#### 재분배와 합병! - 적재 하한인 경우
**엔트리 수가 d인 경우!** 적재 하한을 유지하기 위해.. 
1. 형제 노드에서 엔트리 가져와서 재분배
2. 재분배가 불가능한 경우, 형제 노드와 합병!
<br>

둘 중에 한 가지 방식을 행한다.
1. 재분배 -> 부모 노드 수정. **두 번째 노드를 가리키는 인덱스 엔트리의 키 값은, 두 번째 노드에 있는 가장 낮은 탐색 키 값으로 수정되어야 한다.** 왜?? <br>
**두 노드가 합쳐지는 경우 두 번째 노드의 가장 낮은 값이 중간 값이 될 것 아닌가?** 아하!
2. 합병 -> 부모 노드는 두 번째 노드를 가리키던 인덱스 엔트리를 **삭제한다!** <br> 이러한 삭제로 인해 루트 노드의 하나 남은 엔트리마저 삭제되는 경우, **트리의 높이가 하나 줄어든다.**


<!-- ### 비단말 레벨의 페이지 사이에 엔트리의 재분배 -->

## Reference
- Database Management Systems \<Raghu Ramkrishnan 저>
