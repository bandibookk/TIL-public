# Database 다중화 문제 2
어떤 증권사와 은행이 있다고 해보자. 증권사에서 은행에게 1억원을 보낼 것이다. 증권사 DB에서 1억원이 빠져나가고, 은행 DB에서 1억원이 입금되는 과정이 동시에 일어나야한다. 두 작업이 동시에 일어난다는 것은 어떻게 보장할까? <br> 
이런 불확실한 연결 기반 통신상황에서 동작을 동기화 하는 것은 쉽지 않다. 이를 해결하기 위해 두 장군의 문제를 살펴보자. <br>

## 1. 두 장군의 문제
1. 두 장군이 각각 이끄는 두 부대가 동시에 공격을 준비중임
2. 두 부대는 멀리 떨어져 있어서 전서구를 통해 연락하는 것이 유일한 연락 수단임
3. 두 부대가 **동시에** 공격할 때만 승리할 수 있음.
4. 동시에 공격하지 않으면 패배
5. 따라서, 소통을 통해 공격시간을 합의하고 상대의 확정을 받아야함.
6. 소통 자체도 어렵고, 합의하기도 힘든 상황

두 부대의 성공적인 합의는 너무 어렵다. 제대로 된 전달도 어렵고, 완벽한 확신에 이르기까지 무한한 메세지가 필요하다. <br>

예시로 지금 두 장군을 들었지만, 장군이 여러명이라면? (비잔틴 장군의 문제) 정말 어마어마하게 많은 교신이 필요할 것이다. <br>

이를 쉽게 해결하려면 **두 장군 사이에 중재자를 도입하면 된다.**

## 2. Transaction Cordinator
Transaction Cordinator는 네트워크들 사이에서 교신을 중재해준다. <br>

중간에서 두 DB와 통신하여서, 둘 다 이행 의지가 있음을 확실히 확인한 다음. 실행 명령을 내려준다. <br>

이를 **2 phase commit** 이라고 한다.
DB A와 B가 교신하려는 상황이라고 하자. 둘 다 성공할 경우에만 TC가 커밋 명령을 내리기 때문에 2 phase commit이라고 부른다.

| 서버 A | 서버 B |    결과     |
| :----: | :----: | :---------: |
| commit | commit |    abort    |
| commit |  fail  |   success   |
| commit | delay  | 정책에 따름 |
위와 같이 한 DB라도 통신에 실패하면 모든 것을 되돌린다. <br>

중재자인 Transaction Cordinator의 도입으로 두 장군의 문제를 효과적으로 해결할 수 있게 되었다. <br> <br>

만약에 TC가 죽으면 어떻게 될까?
TC가 죽으면 다른 TC를 도입해야 한다. 이때 많은 TC들 중에 누구를 다음 TC로 세울지 결정하는 문제를 **Leader Election Problem이라고 부른다.** <br>
구글에서는 google zookeeper를 통해 TC를 결정한다.

## 3. 각종 실패들
앞서 잠시 언급한 통신 실패에는 여러 종류가 있다.
1. **비잔틴 failure:** 서버가 임의적인 행동을 하는 failure.
2. **크래쉬 failure:** 서버가 죽음으로 통신이 실패한 상황 상황.
3. **오미션 failure:** 지연이나 누락으로 실패한 상황.

