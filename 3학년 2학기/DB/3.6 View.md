# View!


뷰!(View)는 Table을 보는 '창'으로, **직접 정의하는 가상 테이블이다.**

여러 테이블들에서 내가 필요한 부분들을 엮어 가상의 테이블을 만들 수 있는 기능으로

편리하고, 보안적으로 안전하다.

내가 직접 정의하는 테이블이라고 말 했지만,

**실제로 데이터베이스에 저장되지는 않는다.**

단순히 테이블의 필요한 요소들만 논리적인 단위로 엮어 만드는 느낌이고,

실제론 어떤 테이블이 만들어 지지 않는다는 것이다.

예를 들어 학생 정보와, 학생 성적 정보가 따로 두 테이블에 저장되어 있을 때

한번에 엮어서 정보를 보이고 싶을 때가 있을것이다.

구체적으론 "A 학점을 받은 학생들의 이름과 학번 과목번호를 엮은 테이블"을 만들고 싶다고 생각해보자.

학생들의 학점은 Enrolled 테이블에,

나머지 학생 개인 정보들은 Student 테이블에 저장 되어 있다.

두 테이블의 정보를 엮어 아래와 같이 View를 정의할 수 있다.

```
CREATE VIEW A-Students (name, sid, course)
    AS SELECT S.name, S.sid, E.cid
    FROM Students S, Enrolled E
    WHERE S.sid = E.studid AND E.grade = 'A'
```

위 명령어의 입력으로 A-Students라는 가상의 테이블이 생겨나게 되고,

이는 실제로 저장된 테이블처럼 사용할 수 있다!

## 1\. 가상의 테이블? 실제로 저장 되지 않는다?

뷰는 가상의 테이블이고,

실제로 저장 되지는 않는다니..

그렇다면 어떻게 기존 테이블처럼 다양한 쿼리를 수행하고, 정보를 얻을 수 있을까?

**뷰에 대한 쿼리는 내부적으로 기본 테이블에 대한 쿼리로 변환되어 수행되기 때문이다.** 

실제론 단지 View를 정의하는 SQL 쿼리만이 저장 되어 있고, 

뷰에 대한 쿼리가 실행되면 알아서 View를 만들 때 정보를 가져온 원본 테이블들에 쿼리가 실행된다!

이런 마법같은 변환 **덕분에** 편하게 데이터를 가져올 수 있다.

하지만 쉽게 정보를 가져올 수 있는만큼, 정보 수정 쿼리들로 인해 원본 테이블이 변화할 수도 있는 것이다.

INSERT, UPDTAE, DELETE와 같은 쿼리에 삽입 변경 삭제 등의 쿼리에 **기본 테이블이 변해버릴 수 있다는 것이다.**

앞서 View를 Table을 보는 창이라고 소개했다.

이 이름에 힌트가 있다.

View를 Table이라는 어떤 방을 보는 하나의 창문이라고 생각해보자.

어떤 방 안에 맛있어 보이는 사과가 있고, 나는 창문을 통해 방 안을 들여다 보는 중이라고 생각해보자.

창 안 쪽으로는 방이 훤히 보이지만, 

창분을 통해 방 안쪽의 물건들을 내 맘대로 넣고 꺼낼 수 있을까?

당연히 쉽지 않다.

이와 같이 뷰를 통해 테이블의 데이터를 수정하는것은 제약이 따른다.

뷰를 통해 기본 테이블(뷰를 구성하는 원본 테이블들)의 내용을 쉽게 검색할 수는 있지만,

기본 테이블의 내용을 바꾸는 작업은 제한된다.

## 2\. 뷰와 연산 거부와 승인

1.  `INSERT` 연산  
      
    `INSERT`는 테이블에 튜플을 집어넣는 연산이다.  
    만약에 VIEW에 어떤 튜플을 `INSERT`를 해줄 때,  
    원본 테이블에는 있지만, VIEW에 나타나지 않는 애트리뷰트가 있을 수 있다.  
    이 경우, 원본 테이블의 View에 나타나지 않은 애트리뷰트들엔 어떤 값이 채워질까?  
    바로 **null 값이 채워지게 된다.**  
    **만약 그 값이 PK라면 어떻게 될따? 키 제약 조건에 의해 `INSERT`가 거부된다!**  
    PK는 유일하게 하나의 값을 가져야만 하기 때문에  
    PK가 없는 INSERT가 요청되거나  
    유일하지 않은 PK값을 가진 튜플의 삽입을 시도하면 해당 연산은 거부된다!  
    이는 `UPDATE`, `DELETE`연산에도 똑같이 적용된다!  
      
    **결국, 기본 테이블의 키 제약 조건을 위배하는 연산이 뷰에 요청된다면  
    연산이 거부되는 경우가 있다.  
      
    **
2.  **집계함수로 계산된 값은** 기본 테이블이 원래 포함하고 있던 애트리뷰트가 아니다.  
    내가 필요에 의해 테이블의 여러 조건을 조합해 만든 것이다.   
    원래 테이블이 가지지 않는 값에 대한 요청이기 떄문에 요청이 거부된다.  
      
    
3.  `DISTINCT`, `GROUP BY`를 포함하여 정의한 뷰는 변경할 수 없다.

결론적으로 DB는 View에 어떤 명령이 내려왔을 때,

그 재료가 되는 기본 테이블들의 어떤 투플을 어떻게 변경해야 할지 명확하길 바란다.

그렇지 않은 경우는 모두 거부하는 것이다. 

## 3\. 뷰 왜 쓰나요?

이렇게 까다로운 뷰를 사용하는 것의 장점엔 무엇이 있을까?

1.  **논리적 데이터 독립성 지원**  
    1개 이상의 기본 테이블에서 몇 가지의 어트리뷰트만 선택해 가져와 구성한 테이블이 뷰이다.  
    필요한 데이터만 딱 가져와서 테이블을 구성했으므로, 기존 테이블에 있던 다른 테이터들을 신경쓰지 않아도 된다.  
    이는 편리함을 가져온다.  
      
    
2.  보안의 관점에서도 좋다.  
    예를 들어, 학생 테이블에서 학생 정보 전체는 공개하기 싫고,  
    일부만 테이블로 공개하고 싶은 경우, 뷰가 유용하다.  
      
    공개 가능한 애트리뷰트들만 떼어 뷰를 정의하고,  
    그렇게 새로 만든 뷰를 공개한다면 보안적으로도 안전하다고 할 수 있다.  
      
    
3.  **질의문을 좀 더 쉽게 작성할 수 있다.**  
    뷰 자체가, 여러 조건들 하에 만들어진다.  
    예를 들어 위의 A-Student는 A학점 학생들의 정보만 모아둔다.  
      
    따라서 A학점 학생들에 대해 어떤 조건을 추가해 SELECT 연산을 하고 싶을 때,  
    기본 테이블들에 복잡한 쿼리를 날릴 필요 없이,  
    단지 AStudent View에 추가된 조건만을 고려한 쿼리를 날리면 되는 것이다.  
      
      
    

## 4\. 테이블 뷰 제거, 변경

```
DROP Students RESTRICT
```

`DROP Students RESTRICT`와 같은 명령으로 제거 가능하다.

어떤 뷰나, 무결성 제약조건이 Student를 참조하지 않으면 제거가 승인된다.  
  

```
DROP Students CASCADE
```

`DROP Students CASCADE`는 Students를 제거하고,  
이를 참조하는 뷰나 무결성 제약조건 또한 연쇄적으로 제거된다.  
  
  

`ALTER TABLE`은 기존 테이블의 구조를 수정한다.  
maiden-name라는 열을 Students에 추가하기 위해, 아래와 같은 명령어를 사용할 수 있다.  
기존의 모든 행들은 NULL로 채워집니다.

```
ALTER TABLE Students 
    ADD COLUMN maiden-name CHAR(10)
```

### Reference

-   데이터 베이스 개론 <김연희 저>
-   데이터 베이스 시스템 <Raghu Ramakrishnan 저>
