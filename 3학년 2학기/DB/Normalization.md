# Normalization
DB를 잘못 설계하면 불필요한 데이터의 중복이나 여러 사이드 이펙트가 발생할 수 있다. 이런 **이상(anomaly) 현상을 제거하며, 올바르게 설계해나가는 과정이 정규화이다.** <br>

- 정규화: DB 불필요한 데이터의 중복으로 발생하는 이상현상을 제거하며 설계하는 과정
 
## 1. Anomaly

이상현상에는 다음과 같은 3가지 이상이 있다.
1. **insertion anomaly:** 새 데이터를 삽입하기 위해 불필요한 데이터(null)도 함께 삽입해야 하는 문제. 
2. **update anomaly:** 중복 투플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제. **(즉, 동기화의 문제)**
3. **deletion anomaly:** 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실 문제

<br>

#### 이상현상들을 설명 위해 예시로 쓸 테이블
이벤트 참여 릴레이션 기본키는 **고객 아이디와 이벤트 번호** 이 때, **이벤트 번호는 이벤트 릴레이션에서 왔음.** <br>

- JoinEvent(<U>uid</U>, <U>event_id</U>, rank, user_name, grade)

### 1.1 insertion anomaly
책에서 '불필요한 데이터' 라고 괜히 어렵게 말했지만, **알고 보니 null인 경우가 많다.** <br>
예를 들어 가장 처음 고객 정보만 가지고 이벤트 참여 릴레이션을 채운다고 가정해보자. 그런데 아직까지 발생한 이벤트가 없어서 FK로 가져올 값이 없다. 그럼 어떻게 될까? 이벤트 아이디는 PK이기 떄문에 NULL 값을 넣어줄 수 밖에 없어서 **임시 값을 넣어 주게 된다. 이렇게 insertion anomaly가 발생하게 된다.**

### 1.2 update anomaly
**중복된 투플들 중 일부만 수정되어 테이터가 불일치하게 되는 모순** <br>

예를 들어 테이블에 아이디가 `jinho`인 사람이 투플이 3개 있다고 가정하자. (3가지 각기 다른 이벤트에 참여하여 3개의 투플) <br>
이 때, `jinho` 회원의 등급을 VIP에서 VVVIP로 올렸는데, 모든 투플에 적용이 안 된다면? 이 때 **한 고객의 등급이 다르게 기록 되어있는 모순이 생겨 update anomaly가 발생하게 된다.**


### 1.3 deletion anomaly

릴레이션에서 투플을 삭제하면 꼭 필요한 데이터까지 함꼐 삭제하여 데이터가 손실되는 연쇄 삭제 현상을 **deletion anomaly라고 부른다.** <br>


어떤 유저가 이벤트 참여를 취소했다고 가정해보자. 그러면 해당 투플이 지워질 것이다. 그런데 이 때, uid, user_name, grade와 같은 정보를 JoinEvent Table이 유일하게 가지고 있었다고 해보자. 그러면 **이벤트 참여와 관련이 없는 중요한 데이터까지도 전부 지워져서 deletion anomaly가 발생하게 된다.**



## 1.4 정규화의 필요성 - Anomaly의 해결

**이런 anomaly들이 발생하는 이유는 관련이 없는 데이터, 속성들을 하나의 릴레이션에 모아두고 있기 때문이다.** <br>
이런 anomaly를 방지하려면 **관련 있는 속성들로만 릴레이션이 구성 되어야 하는데 이를 위해 필요한 것이 정규화이다!**

<br>

**정규화는 함수 종속성을 고려하여, 릴레이션을 구성하는 속성들 간의 관련성을 줄이기 위해, 릴레이션을 분해하는 과정이다.** (decomposition) <br>

일반적으로 릴레이션에 함수적 종속성이 **하나만** 존재하도록 분해한다.


# 2. 함수 종속

**결정자와 종속자.** <br>

하나의 릴레이션을 구성하는 속성들의 부분 집합 X와 Y가 있을 때, **X에 대한 Y 값이 항상 하나이면 `X가 Y를 함수적으로 결정한다`, 그리고 `Y가 X에 함수적으로 종속되어 있다.`**

<br>

이렇게 말하면 어려워 보이니 구체적인 예시를 들자. 주민번호가 바뀌지 않는다는 가정 하에, 하나의 주민번호는 하나의 이름을 결정한다. 그러므로, 주민번호가 함수적으로 이름을 결정한다. <br> 

그리고 하나의 주민번호는 하나의 나이를 결정한다. 그러므로 나이는 주민번호에 종속 되어있다. 이렇게 풀어 보면 그리 어려운 개념은 아니다! <br>

위에서 예시로 든 JoinEvent 테이블을 보자
- JoinEvent(<U>uid</U>, <U>event_id</U>, rank, user_name, grade)

1. uid는 이름을 결정한다: uid -> user_name
3. uid와 event_id의 조합은 이벤트 등수를 결정한다: {uid, event_id} -> rank

이것이 함수 종속 개념이다. 그리 어렵지 않다. <br>

이제 부분 함수 종속과 완전 함수 종속을 알아봐야한다. <br>

1. 완전 함수 종속: **Y가 속성 집합 X의 전체에 종속 되어 있다.** user_name은 uid에 완전 함수 종속 되어 있다.
2. 부분 함수 종속: **Y가 속성 집합 X에의 전체에 종속 되어 있지 않다.** ex) user_name은 {uid, event_id}에 부분 함수 종속 되어 있다. (uid에 완전 종속 되어 있으므로!)


두 종속의 차이를 알아야 정규형을 이해할 수 있다.

# 3. 기본 정규형
정규형은 기본 정규형과, 고급 정규형으로 나뉜다.
1. **기본 정규형**
- 제 1 정규형
- 제 2 정규형
- 제 3 정규형
- Boyce/Codd 정규형

2. **고급 정규형**
- 제 4 정규형
- 제 5 정규형

각 정규형마다 만족시켜야 하는 제약 조건이 존재하고, **어떤 릴레이션이 한 정규형의 제약조건을 만족하면 릴레이션이 해당 정규형에 속한다고 표현함.** <br>

구성이 이렇다보니, 제 5 정규형까지 다 만족해야 할까?라는 생각이 들 수도 있는데, 아니다. <br>

오히려 너무 과하면 비효율 적일 수도 있다. **일반적으로는 기본 정규형을 따르는 것이 대부분이다.**


## 3.1 제 1 정규형
모든 속성이 원자값을 가져야 한다. 다중 값을 가져서는 안 된다. 말이 어려운데, <br>
**그냥 한 속성에는 값이 1개만 있어야 한다는 것이다.** 예를 들어 한 튜플이 여러 uid를 가지지 마라. 한 튜플이 여러 user_name을 가지지 마라. 이런 뜻이다.

<Br>

너무 간단하고 당연해서 허무하다. 직관적으로도 릴레이션의 최소 조건임을 바로 알 수 있다... <br>
굳이 예시 하나만 보자.

|  <U>uid</U>  |     event_id     |     username     |
| :---: | :--------------: | :--------------: |
| 24651 | E011, E003 | jinho, binary-ho, 진호우 |

이러지 말라는 것이다. 차라리

 |  <U>uid</U>  |     <U>username</U>      |      event_id   |
| :---: | :--------------: | :--------------: |
| 24651 | jinho | E011 |
|24651|binary-ho|E003|
 |24651|진호우|E003|


## 3.2 제 2 정규형

**부분 함수 종속을 제거하고, 모든 속성이 기본키에 완전 함수 종속되도록 릴레이션을 분해해야 한다.**  <br> <br>

**기본키와 기본키와 관련된 아이들만 분해해서 남기라는 것이다**. 무손실 분해를 이용해서! <br> 무손실 분해 (nonloss decomposition)는 릴레이션을 분해할 때, 의미상 동등하게, **정보 손실 없이 분해하라는 것이다.** 그래서 분해된 릴레이션을 자연 조인하면 다시 분해 전으로 돌아가게끔 해주라는 것이다. <br>
다음의 예시를 보자.
- JoinEvent2(<U>uid</U>, <U>event_id</U>, rank, grade, discount)
- rank는 해당 이벤트에서의 등수, 등급에 따라 할인률이 정해짐.

여기서 제 2정규화를 진행해보자. 각 기본키는 어떤 속성과 연관 있을까?
1. uid는 무엇을 결정하는가? -> **grade와 discount다.**
2. event_id는 무엇을 결정하는가? -> 단독으로는 결정 하는 속성이 없다.
3. {uid, event_id}는 무엇을 결정하는가? -> rank를 결정한다.

<br>

**그렇다면, uid와 uid를 결정하는 속성들과, {uid, event_id}와 이 집합이 결정하는 속성들로 나누자는 것이다!** <br>

자 원본

|  uid  | event_id | rank  | grade  | discount |
| :---: | :------: | :---: | :----: | :------: |
| 24651 |   E011   |   1   | silver |    5%    |
| 11111 |   E111   |   3   |  gold  |   10%    |
| 33333 |   E333   |   2   | silver |    5%    |

이것을 두 테이블로

1. 고객 릴레이션

| <U>uid</U> | grade  | discount |
| :--------: | :----: | :------: |
|   24651    | silver |    5%    |
|   11111    |  gold  |   10%    |
|   33333    | silver |    5%    |


2. 이벤트 참여 릴레이션

| <U>uid</U> | <U>event_id</U> | rank  |
| :--------: | :-------------: | :---: |
|   24651    |      E011       |   1   |
|   11111    |      E111       |   3   |
|   33333    |      E333       |   2   |

**우와 아름답게 나뉘였다! 이것이 제2 정규형!!**


#### 제 2 정규형을 지키지 않으면 발생할 수 있는 문제
**-> 부분 함수 종속성이 남아 있어서 발생하는 문제!**

- 삽입 이상: 이벤트에 참여하지 않는 고객의 추가시 NULL 발생 가능
- 갱신 이상: 같은 id를 가진 유저가 여럿일 경우 등급이 바뀌었을 떄, 유저가 여러 등급을 가지는 모순 발생.
- 삭제 이상: 이벤트만 지우고 싶은데, 유저의 정보들까지 날아간다.



## 3.3 제 3 정규형
**함수 종속성을 하나만 가져라! + 이행적 함수 종속을 없애라!**

<br>

이행적 함수 종속이란? (transitive FD) <br>
X -> Y이고, Y -> Z이면, 논리적으로 X -> Z가 성립한다. 이때 속성 집합 Z는 X에 이행적으로 종속되었다고 한다. <br>
역시 예시를 보는게 편하다. 위의 유저 테이블을 이어서 보면, 
1. 유저는 등급을 결정한다. -> 맞죠?
2. 등급은 할인률을 결정한다. -> 맞죠?
3. **그러면 논리적으로 유저는 할인률을 결정한다!** <br> **논리적으로 할인률은 유저에 이행적으로 종속되었다.** 

이런 이행적 종속 관계 때문에 위에서 언급한 문제들이 발생한 것이다... 더 나눌 수 있다는 것이다. <br>

어떻게? **X -> Y**와 **Y -> Z**로! (일반적으로)


| <U>uid</U> | grade  | discount |
| :--------: | :----: | :------: |
|   24651    | silver |    5%    |
|   11111    |  gold  |   10%    |
|   33333    | silver |    5%    |

이 아이를
1. 고객 릴레이션 2

| <U>uid</U> | grade  |
| :--------: | :----: |
|   24651    | silver |
|   11111    |  gold  |
|   33333    | silver |

2. 고객 등급 릴레이션


| <U>grade</U> | discount |
| :----------: | :------: |
|    bronze    |    1%    |
|    silver    |    5%    |
|     gold     |   10%    |
|    Jinho     |   100%   |

참! 아!름답다! <br>

**모든 속성이 기본키에 이행적 함수 종속이 되지 않게 해라! <br> 즉, 이행적 함수 종속을 없애라**  <br> <br>

**-> 함수 종속성을 하나만 가져라!**

#### 제 3정규형을 지키지 않으면 발생할 수 있는 문제점
**-> 이행적 함수 종속성 때문에 발생하는 문제들(등급과 할인률)**
- 삽입 이상: 새로운 등급을 추가하고 싶은데, 참여하지 않는 유저가 있다면 pk가 NULL이 되서 삽입이 불가능하다.
- 갱신 이상: 같은 등급을 가진 유저가 여럿일 경우 무언가 하나를 바꿔주면, 한 유저가 여러 등급을 가지는 모순 발생
- 삭제 이상: 유저만 지우고 싶은데, 등급과 할인률 정보까지 다 날아간다.


## 3.4 보이스/코드 정규형 (BCNF; Boyce/Codd Normal Form)
**후보키를 하나만 두어라. <br> 모든 결정자가 후보키가 되게 하라!** <br>

이것도 말이 어려운데, 반대로 접근하는 것이 이해가 쉽다. <br>

**후보키가 아닌 속성이 결정자가 되지 않게 해라!** <br>

Boyce/Codd Normal Form은 강한 제3 정규형이라고도 부른다. 보이스 코드는 제 3 정규형의 부분 집합이면서 더 강한 규칙이기 때문이다. <br>
릴레이션의 함수 종속 관계에서 모든 결정자가 후보키가 되게 하라는 규칙인데, **건방지게 후보키가 아님에도 다른 속성을 결정하는 속성들을 없애라는 것이다.**

| <U>uid</U> | <U>인터넷 강좌</U> | 강사번호 |
| :--------: | :----------------: | :------: |
|   24651    |        JAVA        |    1     |
|   24651    |       Spring       |    2     |
|   33333    |        JAVA        |    3     |
|   33333    |       Spring       |    4     |
|   77777    |       Spring       |    5     |


**강사번호가 인터넷 강좌를 결정한다!** <br> 한 강사는강 한 과목만 가르친다! 사 번호가 건방지게 후보키가 아니면서 함수 종속 관계에서 다른 속성을 결정하는 속성이 존재한다!!! <br>

차라리 **분해를 통해서 강사가 다른 릴레이션에서 대장이 되도록 해주면 되는거다.**  <br>
따라서 위의 표는 아래와 같이 바꿔주는게 맞다.

1. 강좌 담당 릴레이션

| <U>강사 번호</U> | 인터넷 강좌 |
| :--------------: | :---------: |
|        1         |    JAVA     |
|        2         |   Spring    |
|        3         |    JAVA     |
|        4         |   Spring    |
|        5         |   Spring    |

2. 고객 담당 강사 릴레이션 <br> -> 함수 종속 관계가 성립하지 않는 동등한 관계

| <U>uid</U> | <U>강사 번호</U> |
| :--------: | :--------------: |
|   24651    |        1         |
|   24651    |        2         |
|   33333    |        3         |
|   33333    |        4         |
|   77777    |        5         |

#### 보이드/코드를 지키지 않는 경우 발생하는 문제점!
**-> 후보키가 다른 속성을 결정하는 경우 발생하는 문제점**
- 삽입 이상: 새로운 담당 강사가 왔는데 수강 고객이 없는 경우 PK가 NULL이 됨.
- 갱신 이상: 강사가 담당하는 과목이 바뀌었을 때, 전부 바뀌지 않으면 강사가 담당하는 과목이 여러개인 모순 발생!
- 삭제 이상: 어떤 고객이 탈퇴하는 것으로, 강사 정보가 삭제 되어버림!


# 4. 기본 정규화 과정 정리
1. **제 1 정규형:** 속성의 도메인이 원자 값으로만 구성되도록 분해 -> **모든 속성이 원자값으로만 구성**
2. **제 2 정규형:** 부분 함수 종속 제거 -> **모든 속성이 기본키에 완전 함수 종속** 
3. **제 3 정규형:** 이행적 함수 종속 제거
4. **Boyce/Codd 정규형:** 후보키가 아닌 결정자 제거 -> **모든 결정자가 후보키**

이정도만 지켜주는 것이 보통이다. 꼭 제 4, 5 정규형을 지키려 더 분해하는 것이 답은 아니다. 효율이 떨어지는 경우가 더 많을 수 있다.

<br>
키워드만..
- 제 4 정규형: 다치 종속 제거
- 제 5 정규형: 후보키를 통하지 않는 조인 종속 제거


## Reference
- 데이터베이스 개론 <김연희 지음>
