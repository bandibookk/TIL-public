# 3.2 무결성 제약 조건!
DBMS는 부정확한 정보의 입력을 방지해야한다! **이것이 Integrity Constranint, IC -> 무결성 제약조건이다!** <br> **어떠한 인스턴스라도, 무결성 제약조건을 어길 수는 없다.**


## 3.2.1 키 제약 조건 :star: :star:
- 키 제약조건(key constraint): 필드들의 어떤 최소 부분 집합이 각 투플에 대한 고유한 식별자이다.
- **후보 키**: 키 제약 조건에 의해 투플을 유일하게 식별하는 필드 집합! <br> 후보 키는 아래와 같은 정의가 있다. 
1. 후보 키 필드의 값들은 그 인스턴스의 투플을 유일하게 식별함
2. 후보 키는 최소 단위여야함. **후보 키의 부분집합이 키가 되어서는 안 된다!**

- super key: 후보 키를 포함하는 필드들의 집합.
- 모든 릴레이션은 하나의 키를 갖는 것이 보장된다.
- **Primary Key:** 모든 가능한 후보키들 중 기본키를 지정할 수 있다. DBMS가 최적화나 검색, 인덱싱에 쓰는 것이 기본키. null이 허용되지 않는다!

### SQL 키 제약조건 명시 :star:
~~딱 1개까지 Primary Key를 정의할 수 있다!~~ <br>
**책에서 말을 헷갈리게 써 두었는데, 1개의 후보키만이 PK가 된다!** <br> 무슨 말이냐면, 1개의 필드만이 PK가 되는게 아니라, **하나의 필드들의 조합으로 이루어진 후보키가 PK가 된다는 뜻!** <br> 즉, 여러 **필드의 조합이 PK일 수 있다!**
```sql
CREATE TABLE Students (sid CHAR(20),
                      name CHAR(20),  
                      login CHAR(20),  
                      age INTEGER,  
                      gpa REAL
                      UNIQUE (name, age),
                      CONSTRAINT StudentsKey PRIMARY KEY (sid) )
```
- **sid가 기본키이며, name과 age의 조합 역시 하나의 키이다!** <br>
`CONSTRAINT StudentsKey` 부분은 제약조건에 **StudentsKey라고 이름을 붙여 준 것.** 오류를 식별하거나 할 떄 쓴다.
- UNIQUE 제약 조건을 사용함으로써 한 테이블에 속한 필드들의 부분집합이 키임을 선언할 수 있다.

## 3.2.2 외래키 제약 조건 :star: :star:
한 릴레이션에 저장된 정보를 다른 릴레이션에 저장된 정보로 링크할 때 사용. 데이터의 일관성을 위해, 하나가 변경되면 둘 다 점검해야한다! (당연) 이를 위해 두 릴레이션을 모두 포함하는 하나의 IC가 명시되어야 하는데, 가장 일반적인 IC가 **외래키 제약조건 (foreign key constraint)이다.** <br> <br>

아래와 같은 Relation이 있다.
```sql
Enrolled(studid: string, cid: string, grade: string)
```
실제로 존재하는 학생들만 과목을 등록할 수 있도록, studid 필드의 값은 Students의 어떤 필드의 sid 필드에 나타나야한다. 그러니까, **studid의 값은 Students의 sid값 중 하나여야한다.** <br> 이 경우, **Enrolled의 studid 필드를 외래키** 라고 부르며, **Students를 참조한다(refer)** <br> **참조하는 릴레이션의 외래키는 참조되는 릴레이션의 기본키와 부합해야한다!** 열들의 이름은 다르더라도 열들의 수가 같아야 하고, 호환성이 있어야 한다. <br>

1.  참조하는 릴레이션의 외래키는 참조되는 릴레이션의 기본키와 부합해야한다! -> 여러 케이스들 때문에, 내게는 조금 헷갈리는 표현이였는데, 외래키 선언 SQL문을 보면 이해간다. **참조 해올 때, 특정한 키를 골라서 가져오는게 아니라, 기본 키를 가져오는 것!** 
1. **참조되지 않은 값이 있을 수 있다!** 꼭 모든 값을 가져올 필요는 없다
2. sid에 없는 값을 studid에 넣으려고 하면, IC 위배로 삽입 연산이 거부당한다!
3. 참조되고 있는 sid를 가진 Students를 삭제하는 경우, 삭제가 거부 당하던지, 아니면 둘 다 삭제해야한다.
4.  **외래키 필드에는 null값이 올 수 있다?** -> **외래키는 동일한 릴레이션을 참조할 수도 있다!!** <br> 좀 헷갈렸다. 예를 들어 Enrolled에 partner라는 필드가 추가되었다고 해보자. 학생의 파트너 sid를 타나내는 필드이고, partner 또한 Students를 참조하는 외래키라고 선언할 수 있다! <br> 그렇다면, 아직 파트너가 없는 학생은 어떻게 되는가? **이런 경우에는 null 값이 올 수 있다.**

### SQL에서 외래키 제약조건 명시
```sql
CREATE TABLE Enrolled (studid CHAR(20),
                      cid CHAR(20),  
                      grade CHAR(20),  
                      PRIMARY KEY (studid, cid) 
                      FOREIGN KEY (studid) REFERENCES Students)
```
1. studid는 Students를 참조하는 외래키! <br> 즉, **Enrolled 릴레이션의 모든 studid 값은 Students의 기본키 필드 sid의 값으로 반드시 나타나야 한다.**
2. Enrolled의 기본키 제약조건은 한 학생이 수강하고 있는 각 과목에 대해, 오직 하나의 점수만을 가질 수 있다는 것을 의미한다. <br> 학생별로 한 과목에 대해 여러 번 점수를 기록하길 원하면, 이 기본키 제약조건을 변경해야함. 

## 3.2.3 일반적 제약 조건

위에서 언급한 것들 외에도, '일반적인' 제약 조건이 있을 수 있다. 예를 들어 Students Relation에서, `20세 이상은 학생이 될 수 없다!` 라고 요구할 수도 있다. <br> 이런 IC 명세서가 주어지면, DBMS는 제약조건 위배 삽입-갱신을 거부한다. <br> 이 IC는 도메인 제약조건을 확장한 것으로 생각할 수 있다. 이는 다른 단원에서 논의한다.
