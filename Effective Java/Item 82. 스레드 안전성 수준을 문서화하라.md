# Item 82. 스레드 안전성 수준을 문서화하라

**스레드 안전성에도 수준이 있다.** <br>
흔히 '스레드 안전'하거나 '스레드 안전하지 않음' 딱 두 선택지만 있다는 오해와 달리 <br>
스레드 안전성에는 그 수준이 존재한다. <br>
사용자는 그 스레드 안전성을 충분히 인지해야 하며, 만드는 사람은 그 수준을 명시해야 한다. <Br>
그냥 `synchronized` 붙어 있으면 스레드 안전한게 아닐까.. <Br>
싶지만 synchronized는 API에 속하지 않기 때문에 API 자체에 드러나지 않을 수도 있다. <br>

결론적으로 스레드 안전성에는 수준이 있고, <br>
멀티 스레드 환경에서 API를 안전하게 사용하려면 <br> 
스레드 안전성 수준을 명시 해줘야 호출하는 쪽에서 스레드 안전성 수준을 명확히 알 수 있다. <br>

## 5가지 스레드 안전성 수준
아래 다섯가지 스레드 안전성 수준들은 완벽하지 않으나 일반적인 경우를 포괄한다. <Br>
안전성이 높은 순서대로 나열하겠다.

### 1. 불변 immutable
불변 클래스는 말할 것도 없이 외부 동기화도 필요 없다. <br>
숫자로 따지면 상수와도 같은 객체 상태이기 때문에 스레드 안전하다. <br>
String, Long, BigIntger 등의 불변 객체들은 값을 변화시키면 값이 변하기 보단 새 값을 가진 새로운 객체를 내놓는다


### 2. 무조건적 스레드 안전 (unconditionally thread-safe)

내부에서 충실하게 동기화를 마친 경우 무조건적 스레드 안전이라고 부른다. <br>
비록 인스턴스가 수정될 수 있는 가능성이 없는 것은 아니지만, <br>
외부 동기화 없이 사용해도 안전하다. <br>
AtomicLong, ConcurrentHashMap과 같은 클래스들이 무조건적 스레드 안전에 속한다. <br>
무조건적 스레드 안전 클래스를 작성할 때엔 synchronized 메서드가 아닌 <br>
비공개 락 객체를 사용해야 클라이언트나 하위 클래스에서 동기화 매커니즘을 망쳐 놓는 것을 예방할 수 있다. <br>
비공개 락 객체는 아래에서 다루겠다.


### 3. 조건부 스레드 안전 (conditionally thread-safe)

무조건적 스레드 안전 상태와 같지만, <br> 
조건부 스레드 안전에 속하는 클래스의 일부 메서드는 동시 사용시 외부 동기화가 필요하다 <br>
`Collections.synchronized` 래퍼 메서드가 반환한 컬랙션들의 반복자는 외부에서 동기화 해줄 필요가 있다. <br> <br>

조건부 스레드 안전 클래스는 정말 '조건'에 따라 스레드 안전 여부가 갈릴 수도 있기 때문에 <br>
주의해서 문서화 해주어야 한다. <br>
어떤 순서로 호출할 때 동기화가 필요한건지, 이 순서를 따르려면 어떻게 락을 얻어야 하는지를 알려줘야 한다. <br>

예를 들어 `Collections.synchronizedMap`의 API에 순서에 따른 <br> 
synchronizedMap이 반환하는 컬렉션 뷰의 순회 락 획득은 아래와 같은 순서로 진행 되어야 한다. 
```java

// synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면 
// 반드시 그 맵을 락으로 사용해 수동으로 동기화하라.

Map<K, V> map = Collections.synchronizedMap(new HashMap<>());
Set<K> set = map.keySet();

// 동기회 블록 밖에서 keySet을 가져와도 되며
// set이 아닌 map을 통해 동기화 해야 한다

synchronized(map) {
  for (K key : set) {
    key.foo();
  }
}

// 이대로 따르지 않으면 동작을 예측할 수 없다.
```
위 코드의 주석에 기입한 것과 같이 권장하는 방식대로 락을 획득해야 한다.

1. 동기화 블록 밖에서 keySet을 가져와도 되며
2. set이 아닌 map을 통해 동기화 해야 한다

이렇게 API 수준에서 '조건'을 명시해 줘야 한다.


### 4. 스레드 안전하지 않음 (not thread-safe)
4번 부터는 스레드 안전하지 않다. <br>

스레드 안전하지 않음 영역의 클래스의 인스턴스는 수정될 수도 있다 <br>
해당 클래스의 메서드를 동시에 사용하려면 <br> 
외부적인 동기화 메커니즘을 제공해 주어야 한다.  <br>
`ArrayList`, `HashMap`과 같은 기본적인 컬렉션들이 이곳에 속한다.


### 5. 스레드 적대적 (thread-hostile)
`스레드 적대적` 클래스들은 스레드 안전하지 않음을 넘어 스레드에 적대적이다. <Br>
모든 메서드 호출을 외부 동기화로 감싼다고 하더라도, <br>
이들은 멀티 스레드 환경에서 안전하지 않다. <br>
이 수준의 클래스는 아무런 동기화 없이 정적 데이터를 수정한다. <br>
대부분 우연히 만들어졌으며 추후 밝혀지는 경우 수정하거나 deprecated API로 지정되었다. <br>


## 비공개 락 객체
클래스 자체가 외부에서도 사용할 수 있는 락을 제공해줄 수도 있다. <br>
그렇게 해주는 경우 클라이언트에서 알아서 원자적인 메서드 호출을 수행할 수도 있다. <br>

하지만 이 유연성에는 끔찍한 대가가 따르는데, <Br>
<!-- 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없게 된다. <br> -->
<!-- ConcurrentHashMap과 같은 동시성 컬렉션과는 함께 사용하지 못한다. <br> -->
**클라이언트가 공개된 락을 돌려주지 않는 서비스 거부 공격이 가능해진다** denial-of-service attack <br>

이런 서비스 거부 공격을 막으려면 synchronized 메서드 대신에 **비공개 락 객체를 사용해야 한다.**
```java
private final Object lock = new Object();

public void foo() {
  synchronized(lock) {
    ...
  }
}
```

이런 식으로 private final로 숨겨둔다면 <Br>
1. 클래스 바깥에선 볼 수 없어 외부에서 동기화 관여가 불가능하다.
2. final로 선언하여 우연히라도 락 객체가 대체될 수 없게 했다.


이런 비공개 락 관용구는 무조건적 스레드 안전 클래스에서만 사용해야 하는데, <br>
그 이유는 조건부 스레드 안전 클래스의 경우 특정 호출 순서를 따라야만 하고 <br>
클라이언트에게 자유를 주진 않기 때문이다. <br>




## Reference
- Effective Java <조슈아 블로크>
