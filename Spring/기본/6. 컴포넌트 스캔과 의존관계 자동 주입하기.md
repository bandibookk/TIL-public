# 컴포넌트 스캔과 의존관계 자동 주입하기
(4, 5번 항목이 중요한 page입니다.)
## 1. `@ComponentScan`
컴포넌트 스캔은 `@ComponentScan`을 설정 정보에 붙여주면 사용 가능합니다. 

```java
@Configuration
@ComponentScan(
        excludeFilters = @ComponentScan.Filter(type =  FilterType.ANNOTATION, classes = Configuration.class)
)
public class AutoAppConfig {
}
```

기본적으로 **`@Component` 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록합니다.** 스프링 빈에 등록하고 싶은 클래스들에 `@Component`를 달아주면 됩니다. `@Configuration`이 붙은 설정 정보도 자동으로 등록이 되는데, 이는 `@Configuration`의 소스 코드를 열어보면 `@Component`가 붙어있기 때문! 

## 2. `@Autowired`
의존관계는 어떻게 주입되나요? <br>
기존에는 아래와 같이 주입해 주었습니다.
```java
@Configuration
public class AppConfig {
  ...
  @Bean
  public DiscountPolicy discountPolicy() {
    return new RateDiscountPolicy();
  }
}
```
위와 같이 정확히 명시를 해 줌으로서 이용이 가능했었는데, `@ComponentScan`을 사용할 때는 어떻게 해야할까?

```java
@Autowired
public MemberServiceImpl(MemberRepository memberRepository) {
  this.memberRepository = memberRepository;
}
```
**`@Autowired`를 달아 주면, 해당 인터페이스에 맞는 `@Bean`을 찾아 찾아 의존관계를 자동으로 주입해줍니다!** 단순히 보면 `ac.getBean(MemberRepository.class)`와 같다.  <br>

다른 예시도 보자.

```java
@Configuration
public class AppConfig {
  @Bean
  public OrderService orderService() {
    return new OrderServiceImpl(getMemberRepository(), discountPolicy());
  }
}
```
위와 같이 AppConfig에서 해주던 것을 아래와 같이 처리해줍니다.
```java
@Component
public class OrderServiceImpl implements OrderService {
  ...
  @Autowired
  public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
  }
  ...
}
```

\*Autowierd의 정확한 동작은 다른 강의에서 설명합니다.


## 김영한 강사님 ppt 발췌
![kim1](https://user-images.githubusercontent.com/71186266/188900082-1f791117-e878-453a-b41a-8cfe3c9b09ac.png)
![kim2](https://user-images.githubusercontent.com/71186266/188900071-1c827f53-bd5a-4296-a9ba-01e11a04100a.png)


- 생성자가 여러개 일때도 전부 찾아서 자동으로 주입해줍니다!
- 그럼 같은 타입이 여러개일 경우 어떤 일이 일어날까?


# 6. 컴포넌트 스캔 탐색 위치와 기본 스캔 대상
## 1. 탐색 패키지, 클래스 한정!
컴포넌트 스캔은 탐색할 패키지의 시작 위치를 지정할 수 있습니다. <br> 예를 들어 `member` 패키지와 `service` 패키지만 탐색하고 싶은 경우! 아래와 같이 `basePackages`를 지정 해주고, <br> 특정 클래스만 지정해 주고 싶은 경우 `basePackageClasses`를 지정해 줍니다.
```java
// 예시
@Configuration
@ComponentScan(
  basePackages = { "hello.core.member", "hello.service" },
  basePackageClasses = AutoAppConfig.class,
  excludeFilters = @ComponentScan.Filter(type =  FilterType.ANNOTATION, classes = Configuration.class)
)
public class AutoAppConfig {
}
```
패키지가 너무 많거나, 특정 패키지만 스캔하고 싶을 때 사용합니다.

## 2. Default는 어떻게 될까요?
```java
package hello.core;
import ...
@Configuration
@ComponentScan(
  excludeFilters = @ComponentScan.Filter(type =  FilterType.ANNOTATION, classes = Configuration.class)
)
public class AutoAppConfig {
}
```
**`@ComponentScan`이 붙어있는 클래스인 AutoAppConfig가 속해있는 패키지인 hello.core 부터 ~ 하위 모든 패키지를 검사하는 것이 기본 설정입니다!**

## 3. 그래서 권장하는 방법은?
Spring Boot나 강사님이 권장하는 방법은 **패키지 위치를 따로 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것을 권장합니다!**
<br> 

예를 들어 `com.hello`인 곳에 컴포넌트 스캔이 있으면 알아서 `com.hello.member`, `com.hello.service` 전부 알아서 체크해 주는 것이다. 

# 4. `@SpringBootApplication`! :star::star:
**컴포넌트 스캔은 달 필요가 없다?** <br> `@SpringBootApplication`은 가장 처음 프로젝트를 만들면, 최상위 클래스에 만들어지는 스프링 부트 어플리케이션의 시작점 클래스를 나타내는 곳이다! <br> **그런데 이 애노테이션의 소스코드를 까 보면 `@ComponentScan`이 달려 있다!**


# 5. 컴포넌트 기본 스캔 대상! :star::star:
얘네 전부 스캔합니다!
- `@Component`
- `@Controller`: 스프링 MVC Controller로 인식
- `@Service`: 특별한 처리 X, 개발자들이 보기 위한 것
- `@Repository`: 스프링 데이터 접근 계층으로 인식, 데이터 계층 예외를 스프링 예외로 변환해준다.
- `@Configuration`: 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.

위 애노테이션들은 전부 `@Component`를 가지고 있습니다. **애노테이션 끼리 상속관계를 갖는다기 보다는, 스프링에서 애노테이션이 애노테이션을 들고 있도록 합니다.**

<br>

기본적으로 `useDefaultFilters`옵션이 켜져 있다.
