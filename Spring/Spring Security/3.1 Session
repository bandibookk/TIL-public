# 3.1 Session
## 세션의 관리
서버는 돌대가리다 <br>
Session은 어떻게 관리될까? <br>
나에겐 진호라는 친구가 있다. <Br> 
얼마 전에 진호네 집에 놀러갔다. <br>
진호네 초인종을 눌렀더니 진호가 문을 열어줬고, 진호는 나에게 친구 인증서 한장을 써 줬다. <br> 
이 `친구 인증서`는 진호네 집에 놀러온 친구라는걸 인증해주는 인증서로, <Br> 
나중에 잠시 편의점을 다녀오려고 나갔다가 돌아올 때, 내가 나임을 증명해준다. <br>
진호는 이 인증서만 보고 나인지를 판단하는 이상한 친구다 <br>
만약 내가 이 인증서를 잃어버리면, 진호네 궁궐 보디가드 분이 나의 출입을 막는다. <br>
내가 난디.. <br>
반대로 다른 사람이 이 인증서를 들고 와도 나라고 인식하고 문을 활짝 열어줘 버린다. 
참 해맑다. <br>
진호는 나눠준 인증서가 너무 많아서 나눠준 `친구 인증서`를 노트에 적어둔다! <br>
그래서 친구들이 들어올 때마다 노트를 확인한다. 진호는 이 노트 하나만 믿기 때문에 이 노트에서 지워진다면 진짜 친구여도 친구란걸 확인할 수 없다. <Br> <br>


**서버는 Session을 이런 식으로 관리된다.** <br>

1. 브라우저를 통해 어떤 사이트에 접속하면, 사이트 서버에 GET요청으로 Resource를 요청한다. <br> Resource는 별게 아니라, 나에게 제대로 된 화면을 보여주기 위한 html, css 등의 파일등을 의미한다.
2. 서버는 요청을 확인한 다음 `세션 아이디`의 목록을 만들어 세션 아이디를 적어둔다.
3. 클라이언트에게 Resource를 보내며 패킷의 `header`의 '쿠키'에 이 세션 아이디를 담아 보내준다.
4. 그러면 클라이언트는 이 세션 아이디를 보관하며 이 사이트와의 세션에서 계속 써먹는 것이다.
5. 서버는 클라이언트를 확인할 때, 자신이 관리중인 목록을 보면 되는 것이다.

<br> <br>

그럼 세션 목록에서 세션은 언제 지워질까?
1. 서버가 세션 아이디를 강제로 지울 때.
2. 사용자가 브라우저를 종료할 때, 쿠키에 보관된 세션 ID를 지운다. <br> 브라우저가 다시 접속하게 되면, 새로운 세션 ID를 준다.  
3. 30분이 지나면 삭제한다. <br> 2번의 상황에서 브라우저가 종료되어서 클라이언트가 세션 ID값을 잃어버려도, <br> 서버가 보관중인 세션 값은 살아있을텐데, 이 30분이 지나면 사라지게 되는 것이다.  


## 세션의 단점
**세션의 단점은 수 많은 세션 ID를 관리하는 것이 어렵다는 점이다.** <Br>
앞서 언급한 것처럼 세션은 `세션 ID의 목록`을 관리하는 것이 강요된다. <Br>
예를 들어 한 서버가 원활하게 관리할 수 있는 유저 동접자 수가 100명 정도라고 생각해보자. <br>
이용자가 많아져서 유저 정보 300개 정도를 관리할 일이 생긴다면, 어쩔 수 없이 서버를 3개 정도 운용해야 한다. <Br>
이때 서버 A, B, C가 있다고 생각해보자. <br>
서버를 여러개 운용할 때, 당연히 어느 한 서버로 요청이 몰리게 두지 않는다. <br>
요청이 한군데로 몰리게 할거면 여러개 운용할 이유가 전혀 없다. 
때문에, 여러 서버로 골고루 요청을 나누는 `로드 밸런싱` 작업이 들어간다. <br>
요청이 여러 서버로 들어가게 된다는 것인데.. 내 세션 ID는 누가 관리하는가? <br>
첫 접속시 서버 A가 요청을 처리해줬다고 생각해보자. 그럼 서버 A의 세션 ID 목록에 내 세션 ID가 저장될 것이다. <Br>
하지만, 다음 요청이 A 서버로 또 갈것이라는 보장은 전혀 없다. <Br>
B 서버로 갈 수도, C 서버로 갈 수도 있다. 
그럴 때마다 세션 ID를 새로 받는건 엄청난 비효율이다. <Br>
**때문에 모든 서버가 공유하는 DB를 만든다.** <br>
이 DB에 세션 정보들을 저장해두면 문제는 해결된다. <Br>
하지만 다른 문제가 생기는데, DB 입출력은 I/O 작업이기 때문에 느릴 수밖에 없다는 것이다. <br>

이런 단점을 해결하고자 RAM 기반 DB인 레디스를 쓰곤 하는 것이다. 
하지만 완전히 만족스러운 해결책은 아니다. <Br>
이런 세션의 문제점을 모두 해결하는 것이 JWT 방식의 인가다. JWT를 사용하면, 서버가 따로 `목록`을 운용할 필요가 없기 때문이다. <br>
JWT에 대해선 다음에 알아본다. <br>

## Reference
- 스프링부트 시큐리티 & JWT 강의 <최주호 인프런 강사>
