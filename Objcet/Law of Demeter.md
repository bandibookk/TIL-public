작성중


명확한 책임과 역할을 지닌 참가자들이 협력에 참여해야한다. 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력해야한다.

자율적인 객체. 객체들은 애플리케이션의 기능을 구현히가 위해 협력하고, 협력 과정에서 맡은 바 책임을 다하기 위해 자율적으로 판단하고 행동한다.
스스로 정한 원칙에 따라 판단하고 행동하는 객체. 타인의 명령에 따라 판단하고 행동하는 객체는 자율적이지 않음.

<br>

객체가 어떤 행동을 하는 유일한 이유는 다른 객체로 부터 요청을 수신했기 때문임. <br>
요청을 처리하기 위해 객체가 수행하는 행동을 **책임** 이라고 한다. 
자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다. 

적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. 따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 애플리케이션의 품질을 결정한다.


## 자유로운 증언
증언하라, 와
1. 목격했던 장면을 떠올려라
2. 기억을 시간순서대로 재구성하라
3. 말로 간결하게 표현하라.

책임을 너무나도 제한한다. 반대로 너무 자유로워도 문제  `설명하라` 뭘? 너무 추상적이고 포ㄹ괄적이다.
협력은 참여 의도를 명확하게 설명할 수 있는 수준에서만 추상적이여야 한다. <br>
증언하라가 훌륭한 책임인 이유는 자율성을 보장할 만큼 충분히 추상적이며, 협력 의도를 또렷하게 표현할 수 있을 정도로 구체적임

## 어떻게가 아닌 '무엇'을
- 증언해라: `what`만 있다. 어떻게에 대한 내용은 없어서 자율적으로 선택할 수 있다. 참 좋다.


1. 목격했던 장면을 떠올려라
2. 기억을 시간순서대로 재구성하라
3. 말로 간결하게 표현하라.

어떻게가 너무 많이 설명되어있다. 책임의 수준에서 `어떻게`가 들어가니까 모자 장수의 선택은 크게 제한된다.

객체가 다른 객체에 접근할 수 있는 유일한 방법은 요청 뿐. 이 요청을 메세지라고 부른다. 메세지는 객체로 하여근 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법임.

## 3. 메세지와 메서드
### 메세지
메세지는 메세지 이름과 메세지 인자로 나뉨
`모자장수 증언하라(어제, 왕국)` -> 모자장수야(수신자) 어제 왕국(인자)에서 목격한 것을 증언하라(메세지 이름) <br>

왕은 모자장수가 처리를 할 수 있다는 막연한 사실만을 알 뿐 방법에는 관여하지 않는다. 객체의 내부와 외부는 메세지를 기준으로 분리된다. 
메세지는 외부의 누구나 볼 수 있는 공개된 영역에 존재하지만, 메세지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속함.

<br>

메세지는 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 의사소통 수단임. 객체의 메세지 수신 가능은 객체가 메세지에 해당하는 책임을 수행할 수 있다는 것을 의미함. 처리 방법은 자율적으로 선택할 수 있다. 외부의 객체는 메세지만 볼 수 있다.

### 메서드
메세지를 처리하기 위해 내부적으로 선택하는 방법을 **메서드라고 부른다.** 메세지를 수신한 객체는 실행시간에 자유롭게 메서드를 선택할 수 있다. 이것이 일반 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나이다.

## 4. 다형성
이제 다형성을 이렇게 표현할 수 있다. **다형성이란 서로 다른 유형의 객체가 동일한 메세지에 대해 서로 다르게 반응하는 것을 의미한다.**

메세지는 **무엇이 실행될지만 명시한다.** 어떻게는 수신자가 결정할 수 있다. 메세지 처리에는 제약이 없음. 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있음. 왕의 입장에서는 상대가 누구든 간에 **증언하고** 있으므로, 결과가 동일하다. 수신자를 구별할 필요가 없다. 수신자의 종류에는 관심이 없다. 이것이 다형성 <br>

송신자 입장에서 동일한 메세지를 처리할 수 있으면 협력안에서 대체 가능하다. 
<br>

다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로서 달성된다. 이를 통해 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 협력을 유연하게 만들 수 있다.

## 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실이 가지는 장점

1. **협력이 유연해진다.** 송신자는 수신자가 메세지를 이해한다면 누구라도 상관 없다. 수신자를 유연하게 변경할 수 있다.
2. **협력이 수행되는 방식을 확장할 수 있다.** 협력의 세부적인 수행 방식을 쉽게 수정할 수 있다. 관계가 느슨하기 때문에, 책임만 완수한다면 어떻게든 수용 가능하다. 동작 방식을 바꾸어도 협력 구조가 변하지 않는다.
3. **협력이 수행되는 방식을 재사용 할 수 있다** 송신자가 누구여도 협력을 재사용 할 수 있다.


## 송신자와 수신자를 약하게 연결하는 메세지

결국 메세지의 은혜! 메세지가 다형성을 지탱한다. 메시지는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만들어준다.

송신자는 오직 메세지만 바라본다. 수신자가 메시지를 이해하고 처리해줄 것이라는 사실만 아는 것으로 충분하다.

## 메세지를 따라라
객체지향의 핵심, 메세지
객체지향의 기본 개념은 책임을 수행하는 자율적인 객체 <br>

연쇄적으로 메세지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다. <br>

객체지향의 강력함의 핵심은 상속 관계가 아닌 메시지로 부터 나온다. 객체지향 애플리케이션은 클래스를 이용해 만들어지지만, 메세지를 통해 정의된다. 

데이터 중심의 설꼐는 객체의 자율성을 저해한다. 외부의 객체가 객체의 내부를 마음대로 주무를 수 있다면, 객체의 자율성이 저하된다. 

객체가 메세지를 선택하는 것이 아니라, 메시지가 객체를 선택해야한다. 메시지를 중심으로 협력을 설계해야 한다.

책임 주도 설계 - 기본 아이디어는 객체들 간에 주고 받는 메시지를 기반으로 적저랗ㄴ 역할과 책임, 협력을 발견하는 것이다.


## What/Who 사이클
책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에, 수행할 객체를 결정하는 것. 이를 What/Who 사이클이라고 부른다. 어떤 행위를 먼저? 누가? (어떤 행위가 바로 메시지) <br>

객체가 어떤 메세지를 수신하고 처리할 수 있느냐가 객체의 책임을 결정한다.

## 묻지말고 시켜라
디미터 법칙, 묻지말고 시켜라 스타일. <br>

책임-주도 설계는 객체가 아니라 객체들이 주고 받는 메시지에 초점을 맞춤으로서 객체지향의 장점을 극대화한다. What/Who 사이클은 어떤 객체가 필요한지를 생각하지 말고, 어떤 메시지가 필요한지를 먼저 고민하라고 조언한다. <br>

송신자는 메시지 결정 시점에서 어떤 객체가 메시지를 수신할 것인지 알 수 없기 때문에 당연히 메시지 송신자는 메시지를 수신할 객체 내부 상태를 볼 수 없다. 따라서, 메시지 중심의 설계는 메시지 수신자의 캡슐화를 증진시키고, 내부를 모르므로 느슨하게 결합된다. <br>


객체는 다른 객체의 상태를 묻지 말아야한다! 객체가 다른 객체의 상태를 묻느나든 것은 메시지를 전송하기 이전에 객체가 가져야 하는 상태에 관해 너무 많이 고민하고 있다는 증거다. 필요한 메시지를 전송하기만 하고 메시지를 수신하는 객체가 스스로 메시지의 처리 방법을 결정하게 하라.

<br>

결과적으로 묻지 말고 시켜라 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에, 설계를 유연하게 만든다. <BR>


샌디 메츠: 뭊디 말고 시켜라 스타일이란 메시지가 어떻게 해야하는지를 지시하지 말고 무엇을 해야하는지를 요청하는 것이라고 설명한다. <br>
어떻게에서 무엇으로 전환하는 것은 인터페이스의 크기를 급격하게 감소시킨다. 이는 외부에서 해당 객체에 대해 의존성이 적어진 다는 것을 의미한다. 결과적으로 메시지 송신자와 수신자 간의 결합도가 낮아지기 때문에, 설꼐를 좀 더 유연하게 만들 여지가 많아지고, 의도 역시 명확해진다. 객체가 자신이 수신할 메시지를 결정하게 하지 말고, 메시지가 협력에 필요한 객체를 발견하게 해야한다. <Br> <Br>


## 인터페이스와 메시지
메시지가 인터페이스를 결정한다. 객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 **메시지 전송이다.** 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며, 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 빚는다.


1. 협력에 참여하는 객체의 책임은 자율적이여야 한다.
2. 자율성 - 자신의 의지와 판단력을 기반으로 객체 스스로 책임을 수행하는 방법을 결정할 수 있음.
3. 메시지 - 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 채워진다.
4. 객체가 책임을 수행하기 위해 외부로 부터 메시지를 받기 위한 통로 -> 인터페이스


외부에 공개된 인터페이스를 **공용 언터페이스** 숨겨진 실제 동작 부분을 **구현이라고 부른다** 객체는 행동을 가진다. 행동은 메시지를 수신했을 떄만 실행되는 메시지 처리 방법이다. **이를 메서드라고 부른다.** 메서드의 코드는 외부에 노출되지 않으므로, 구현 부분에 속한다.

즉, 객체의 외부와 내부를 분리하라는 것은 결국 객체의 공용 인터페이스와 구현을 명확하게 분리하라는 말과 동일하다.


## 캡슐화
1. 상태와 행위의 캡슐화: 객체는 상태와 행위의 조합이다. 객체는 스스로 자신의 상태를 변경하고, 외부에 응답할 수 있는 행동을 내부에 함께 보관한다. 객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체다. 이런 관점에서의 캡슐화를 **데이터 캡슐화라고 한다.** 

객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야함 하는 행위만 골라 공용 인터페이스를 통해 노출한다. 따라서 데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제조건이다. **객체가 자율적이기 위해서는 자기 자신의 상태를 스스로 관리할 수 있어야 하기 떄문에, 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제조건이다.**

외부의 객체는 공용 인터페이스에만 의존해야 하고, 구현 세부 사항에 대해서는 직접적으로 의존해서는 안 된다. 


객체를 자율적인 존재로 바라보는 것은 결국 객체의 내부와 외부를 엄격하게 분리한다는 것을 의미한다. 객체는 자신의 의지에 따라 변경하고 조작할 수 있는 비밀을 가지고 있다. 이것은 객체의 내부다. 또 동시에 객체는 외부의 객체가 의지하고 접근할 수 있는 공용 인터페이스를 가진다. 이것은 객체의 외부다. 어떤 것도 동시에 객체의 내부와 외부에 포함될 수 없다.

## 책임의 자율성이 협력의 품질을 결정한다.

객체의 책임이 자율적일 수록 협력이 이해하기 쉬워지고, 유연하게 변경할 수 있게 된다. 결과적으로 채김이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.
