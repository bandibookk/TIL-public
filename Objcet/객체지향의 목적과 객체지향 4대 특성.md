# 그래서 객체지향이 왜 좋다는걸까? (+ 객체지향 4대 특성)

안녕하십니까 GDSC 백엔드 멘토 이진호입니다.

이번 과제는 객체지향 패러다임과 객체지향 4대 특성에 대해 공부하는 것이였습니다!

객체지향이 뭔지는 대충 알겠는데..

캡상추다 캡상추다.. 어떻게 구현하는지 까지는 조금 알겠는데

그 필요성과 장점이 잘 와닿지 않는 분이 읽어보시면 좋을 것 같습니다.

오늘은 간단하게 **객체지향 패러다임의 목표와 장점**을 설명하면서

그 안에 **객체지향 4대 특성**을 녹여보겠습니다.

거시적인 객체지향의 내용을 다루고 있고,

구체적인 코드로의 표현은 저희 스터디 기본 도서인 '스프링 입문을 위한 자바 객체 지향의 원리와 이해'나

'오브젝트' 등의 도서를 참고하면 좋을 것 같습니다.

혹은 글에서 언급하는 키워드들로 검색해 봐도 좋습니다.

(이 글은 기본적으로 책에서 객체지향 4대 특성에 대해 기본적으로 학습했음을 전제로 작성했습니다)

## 1\. 객체와 객체지향

저희 기본 도서에서 다룬 바와 같이 객체지향 패러다임 이전의 프로그래밍은

우리가 컴퓨터에게 눈높이를 맞춰 주어야 했습니다.

니모닉을 넘어 어셈블리 언어로,

어셈블리 언어에서 C로

인간은 0과 1로 이루어진 코드를 조금씩 바꾸어 나갔습니다.

각 요소들에 이름을 붙여주고, 논리 덩어리를 묶기도 했습니다.

덕분에 프로그래밍 언어는 좀 더 이해하기 쉽고, 다양한 환경에서 동일하게 사용 가능했으며,

재활용 할 수 있는 형태로 개선되었습니다.

하지만 이런 절차적/구조적 프로그래밍은 우리가 세상을 바라보는 방식과는 거리가 멉니다.

세상은 0과 1로도, 프로시저만으로도 이루어져 있지 않습니다.

저도 객체지향에 대해 처음 배울 땐,

왜 이러한 언어들이 세상을 바라보는 방식과 거리가 멀다고 말하는지 전혀 이해하지 못 했습니다.

C를 배우고, C#, C++을 배우면서

그냥 클래스라는 단지 중복을 줄여주는 어떤 '기능'을 배웠고,

뭐 세상을 표현하니 뭐니 하는 글을 눈으로 읽을 뿐 잘 와닿지 않았습니다.

사실 알고보니 저는 단 한번도 우리가 어떻게 세상을 인식하는지 고민해본 적 없던 것이였습니다.

한번 생각해봅시다.

우리는 세상을 인식할 때 어떻게 인식할까요?

고개를 들면 하늘이 있고, 구름이 보입니다.

밤엔 별이 뜨고 아버지는 옥상에서 담배를 태우십니다.

우리는 세상을 객체로 인식합니다.

하늘, 구름, 밤, 별, 아버지, 옥상, 담배

이 모든 것은 실체가 있는 ‘객체’ Object 입니다.

우리는 세상을 객체들의 합으로 인식합니다.

식물은 우리에게 산소를 제공하고, 동물은 우리에게 단백질을 제공해줍니다.

햄버거는 빵과 야채 고기의 합이고

인간은 다양한 유기물의 합이며

우주는 은하 군집의 합입니다.

우리에게 있어..

세상은 객체들의 합으로 이루어져 있고,

이 객체들의 상호작용으로 이루어져 있습니다.

이렇게 우리가 세상을 인식하는 방식처럼 프로그램을 만들 수는 없을까요?

기존처럼 반복되는 부분을 변수나 함수로 만들어 재활용 하는 것을 넘어서서,

객체 자체를 코드로 표현하고, 분류하여 재활용 할 수는 없을까요?

인간은 다양한 요소로 이루어져 있지만, 기본적인 사용법과 기능은 비슷 비슷합니다.

공기로 숨을 쉬고, 피가 붉으며, 알 대신 새끼를 낳고 젖을 먹입니다.

이런 ‘인간’을 코드로 표현할 수 있다면,

지구를 코드로 짤 때, 약 80억번의 복사 붙여넣기를 할 필요가 없겠지요?

이렇게 **인간이 세상을 인식하는 방식처럼 프로그램을 만드는 방식을**

**객체지향 패러다임 프로그래밍이라고 부릅니다.**

(참고) 본디 사전적으론 실제로 존재하는 것 만을 객체라 부르지만,

객체지향에선 개념도 객체, 논리도 객체입니다.

## 2\. 객체로 표현하는 것의 장점

인간이 세상을 바라보는 방식대로 코드를 짜면 뭐가 좋을까요?

인간이 바라보는 대로 작성하니 더 직관적이고 작성하기 쉬워질까요?

마냥 그렇지는 않습니다.

모든 설계는 트레이드 오프입니다.

객체지향 패러다임은 하나의 설계법중 하나이고

100% 완전한 설계란 없으며, 장단점을 비교하여 적용해야 합니다.

객체지향 패러다임에 따라 프로그래밍을 작성하면

아주 간단한 프로그램의 경우 오히려 더 복잡하게 코드를 짜게 될 수도 있습니다.

하지만 거대하고 복잡도가 높은 프로그램의 경우

코드의 중복을 줄이면서도, 유연한 설계가 가능하게 해줍니다.

좋은 프로그램이란 아래와 같이 말할 수 있습니다.

1.  오늘 돌아가고
2.  내일 변경하기 쉬워야 합니다.

돌아가는 프로그램이 좋은 프로그램인 것은 당연합니다.

하지만 변경하기 쉬운 프로그램을 만드는 것은 절대 쉽지 않습니다.

앞서 언급한 예시대로 모든 인간의 코드를 80억번의 복사 붙여넣기와

각 인간에 맞춰 조금씩 수정해 가며 작성했다고 생각합시다.

갑자기 클라이언트께서 우리가 만든 시뮬레이션 지구의 스펙 변경을 요청합니다.

모든 인간의 피 색을 파란색으로 바꿔주세요.

모든 인간이 하늘을 날 수 있게 해주세요.

이제 우리는 열심히 모든 인간의 코드를 뒤져 피 색을 바꾸어 주고

날기위한 신체 구조 변화와 몇 가지 기능을 추가해 주어야 합니다.

원래는 80억 코드를 일일히 고쳐야 했겠지만,

하지만 ‘인간’ 자체에 대한 코드를 작성해 두었고 80억개의 인스턴스를 만들어 사용 중이였다면,

이러한 변화를 손 쉽게 가져다 줄 수 있습니다.

어떤 본질적인 공통점이 있는 대상을 묶어 하나의 **분류**로 만들고, 코드로 표현하니 정말 편리합니다!

변경하기도, 확장하기도 너무나도 쉬워졌습니다.

이렇게 우리가 '분류' 하기 때문에 Class라는 표현을 사용하는 것이고,

이것이 바로 **추상화**입니다.

저와 서강준, 카리나의 공통점은 이름이 3글자라는 점 뿐만 아니라,

공기로 숨을 쉰다는 점과 물 없이 살아갈 수 없다는 점,

알 대신 새끼를 낳는다는 점 등의 수 많은 공통점들이 있습니다.

두 분께는 꽤나 아쉽겠지만 저희 셋의 본질적인 공통점을 추출해

포유류, 인간, 한국인 등으로 분류할 수 있습니다.

이렇게 본질적인 공통점을 추출해 한 종류로 분류해 내는 것을 **추상화**라고 합니다.

포유류에는 수 많은 동물들이 있습니다

고래, 코끼리, 캥거루, 강아지, 고양이, 인간..

이 동물을은 자식에게 젖을 먹이고 온혈동물이라는 포유류의 특성을 모두 가지고 있습니다.

이런 다양한 동물들이 공통적으로 갖는 특성을

매번 코드로 작성해줄 필요 없이

추상화를 통해 ‘포유류’이란 분류를 만들고

작성한 코드를 같은 특성을 지닌 분류에 **공유**해줄 수 있다면,

코드 작성의 수고가 많이 줄어들고, 공통된 특성에 변화를 주거나 확장할 때 아주 편리하겠죠?

이러한 상위 분류의 특성을 재활용하여 하위 분류에 적용해 주는 것을 **상속**이라고 합니다.

이렇게 **추상화**와 **상속**으로 코드의 중복을 많이 줄이겠다는 아이디어는 정말 좋습니다.

하지만 큰 단위로 분류하는 것이 마냥 쉽지만은 않습니다.

같은 포유류여도 울음소리가 다르고, 먹이와 먹이를 먹는 법이 다르고, 새끼를 품는 방식과 기간이 다른 등 본질적으로 같은 목적을 가진 행위여도 다르게 행동합니다.

이런 종간 다양성, 그리고 종 안에서의 다양성은 큰 단위로 분류하는 것을 크게 방해합니다!

이렇게 객체의 속성이나 기능을 그 맥락에 따라 여러 형태를 띌 수 있도록 해줌으로써

한 상위 분류로 여러 하위 분류 객체를 참조할 수 있게 해주기 위해 필요한 것이 **다형성**입니다.

우리는 **다형성**을 통해, 한 객체를 다양한 맥락 안에서 자유롭게 사용할 수 있고,

더욱 편하게 분류할 수 있습니다.

야옹야옹 우는 동물들, 그르릉 하고 우는 동물들, 응애 응애 하고 우는 동물들을 따로 분류할 필요 없이

'울 수 있음' 으로 분류해버릴 수 있습니다.

## 3\. 상호작용이 더 중요하다

세상은 객체와 객체들의 상호작용으로 되어 있다고 했습니다.

그리고 지금까지의 설명은 **객체**에 집중 되어 있습니다.

하지만 우리가 더 집중해야 할 것은 객체가 아니라, **상호작용**입니다.

태양은 식물에게 빛 에너지를 제공해주고,

식물은 동물들에게 산소를 제공해줍니다.

그리고 우리는 태어나서 지금까지 수 많은 사람들의 도움을 받고, 도움을 주며

이제까지 잘 살아남아 왔습니다.

이러한 상호작용을 잘 표현해 주어야 유연한 구조를 만들 수 있습니다.

유연한 구조를 이루기 위해선

**객체들의 자율성**을 높혀 줘야합니다.

정말 도구 그 자체인 '자료구조'로서의 객체를 제외한 객체들을

어떤 행위를 행할 수 있는 주체로 인정해주고, 자율성을 높혀 줘야 합니다.

자신이 맡은 책임은 최대한 자신이 행할 수 있도록 존중해주고,

다른 객체와의 의존성은 최대한 낮춰 줘야 합니다.

어느 한 객체가 갑자기 사라지거나, 변해도 다른 객체에게 큰 영향을 미치면 안 됩니다.

예를 들어 이 반대인 경우를 먼저 살펴보겠습니다.

예를 들어 갑자기 외계인이 습격해 지구의 모든 공기와 물을 크게 변성시킨다고 생각해봅시다.

인간을 포함한 각종 동식물들은 모조리 살아남을 수 없을 것입니다.

혹은 6대째 전해져 내려오는 며느리도 모르는 비법 여수 돌게장 식당의 돌게장 계승자 김옥분님께서 갑자기 앓아 누우셨다고 생각해 봅시다.

여수 돌게장집은 금방 망해버릴 것입니다.

이는 우리가 공기와 물에,

식당이 김옥분 할머니께 너무 깊게 의존하고 있기 때문입니다.

이러한 상황을 **객체간의 결합도가 높다**고 표현합니다.

**객체간 결합도가 낮은 프로그램이 변화에 유연하게 대처할 수 있습니다!**

이번엔 어떤 중식당의 주방 직원들이 모두 요리와 식자재 관리, 청소, 서빙, 고객 응대까지 한번에 하고 있다고 생각해봅시다.

만약 갑자기 식당의 주 메뉴를 일식으로 바꿔야 한다면, 일일히 모든 직원이 요리법 새로 배워야 합니다.

이는 한 객체가 너무 여러 책임을 가지고 있기 때문이고,

자신의 책임과 관련 없는 책임들을 떠안고 있기 때문에 발생합니다.

주방 직원은 주방의 일만 다뤄야 합니다.

특히 요리사는 요리에 대해서만 신경 써야 합니다.

한 객체가 여러 책임을 맡고 있고, 한 책임이 똘똘 뭉쳐있지 않고 여러 객체들에게 퍼져 있기 때문에,

이러한 상황을 **응집도가 낮다**고 표현합니다.

이러한 상황이 코드에서 발생하는 경우 더 문제가 많습니다.

한 객체가 너무 여러 책임을 도맡고 있다면,

일단 읽는 사람이 이 객체가 정확히 뭘 하는 객체인지 파악하기 힘들다는 점도 문제지만,

한 가지의 기능만 수정하려 할 때에도 이 객체에, 그리고 이 객체와 연관된 수 많은 객체들에게 미치게 될 복잡한 영향을 모두 고려해야 합니다.

각 객체가 하나의 책임만을 맡게 된다면 어떨까요?

코드는 **더 이해하기 쉬워지고, 변경 또한 쉬워집니다.**

식당의 주 메뉴를 일식으로 바꿔야 할 때,

단지 중식 요리사를 모두 해고하고, 그 자리에 일식 요리사를 고용하면 되기 때문입니다.

마치 포드가 제안한 자동차 공장의 분업화처럼,

한 모듈은 하나의 책임을 가질 때, 이해하기 쉽고 변경과 확장에 유연합니다.

자신이 맡은 책임을 최대한 자신이 가지고 있는 상황을 **응집도가 높다**고 표현합니다.

결국 오늘 돌아가고 내일 변경하기 쉬운 프로그램이 좋은 프로그램이고,

변경에 유연한 프로그램은 낮은 결합도와 높은 응집도를 통해 만들어 낼 수 있습니다.

이러한 객체의 자율성을 존중하는 상호작용을 돕는 것이

마지막 특성인 **캡슐화**입니다.

자바에서 캡슐화는 접근 제어자로 구현이 가능합니다.

접근 제어자를 이용해 다른 객체가 너무 깊이 접근하는 것을 막습니다.

객체의 자율성을 존중하여,

다른 객체들은 단지 이 객체가 어떤 기능을 수행해 줄 것이라고 믿도록 하고

이 객체에게 모든 책임을 맡기는 것입니다.

오늘 제가 뭘 먹었는지 알고 싶다면

그냥 저에게 물어보시면 됩니다.

이는 저의 자율성을 존중해 준 것입니다.

하지만 제가 저의 모든 것을 public으로 열어 둔다면,

다른 사람이 제가 뭘 먹었는지 궁금 할 때

결제 내역을 통해 확인할 수도 있고,

제 뇌를 열어봐 기억을 해집어 확인할 수도 있고,

아니면 제 위장을 열어 보고 확인할 수도 있을 것입니다.

하지만 제 온 몸과 장기 등을 private로 막아두고, 제 자율성을 존중하여

단지 저에게 물을 수만 있다면

저는 사실대로 말 할 수도, 거짓말을 할 수도 있습니다.

이렇게 다른 객체의 접근을 막는 것이 **캡슐화**이고,

**캡슐화를 통해 자신을 꽁꽁 숨기도록 하여 객체의 자율성을 높혀줄 수 있습니다.**

객체에 한가지 책임을 준 다음, 캡슐화를 해버린다면

다른 객체가 이 객체와 상호작용을 할 때는 그냥 이 객체를 믿고,

‘오늘 뭐 먹었는지 말해’와 같은 메시지를 던질 수 밖에 없습니다.

도구처럼 뇌를 해집거나 배를 갈라보는 등 자신의 맘대로 이용할 수 없고,

어떤 답변을 제가 해줄 것이라고 믿고, 단순히 처리를 맡길 수 밖에 없게 됩니다.

이런 객체들의 자율성을 높혀주는 일을 **캡슐화**를 통해 만들어 낼 수 있습니다.

이렇게 객체지향 4대 특성을 녹여내며 객체지향에 대해 좀 더 자세히 설명해 보았습니다. 

도서나 블로그 글들이 대체적으로 구체적인 방식에 대한 내용만을 다루기 때문에

기본적인 목적을 설명해 보았습니다.

이제 구체적인 지침들을 읽으면 더 잘 이해되고, 머리에 잘 남을 수 있을거라고 믿습니다.

더 궁금하신 분들은 '오브젝트'라는 도서를 읽어 보시길 추천합니다.

디미터 법칙과 인터페이스 품질 : https://www.youtube.com/watch?v=tdXd-f7QCnE&t=226s
