# 사용자 프로필 사진 불러오는 로직 백앤드에서 실행하기
지금 일 하는 곳에서 유저들간의 순위를 매기는 랭킹 페이지를 만들어야 할 일이 있었다. 이 때 최대 100위 까지의 유저를 한 화면에 보여주어야 하는 상황이였는데, 이 유저들의 프로필 사진을 전부 보여주어야 했다. 
<br> <br> 
프로필 사진을 보여주는 것이 왜 문제가 되냐면, 원래 사진과 같이 용량이 큰 것들은 유저들의 정보를 저장해 두는 실시간데이터베이스에 함께 보관하지 않고 따로 저장소를 두기 때문이다. <br> 따라서 DB에도 접근하고, DB에서 얻어온 정보를 이용해서 저장소(storage)에 또 접근해야 하다 보니, 그 방식에 따라 속도 차이가 많이 날 수 밖에 없다. 

<br>

일단 내가 선택한 방식은 순위 한 줄 한 줄의 컴포넌트들이 알아서 각자 storage에서 사진을 불러오는 방식을 선택했다. 마치 DB처럼 한 군데에서 storage를 통째로 뜯어와서 각각의 컴포넌트의 uid를 이용해 뿌려주기에는 너무 부담이 되었다. <br> 하필 storage 구조도 `/users/${uid}/'유저를 위한 파일들'` 이런 식으로 짜여 있기 때문에, users를 뜯어오자니 매우 무거웠고, 애초에 '객체'나 '이터러블'과 같은 방식의 접근이 불가능했다. 특정 파일의 URL을 받아오는 식으로 처리해야 되기 때문에 ->  `/users/`를 한번만 가져온 다음, 각각 uid로 접근해!와 같은 방식이 불가능했다.

<br> 

그래서 그냥 **일단 순위를 나타내는 컴포넌트들 먼저 랜더링 되게 하고** **그 컴포넌트들이 각각 자신의 프로필 사진을 불러오도록 해주었습니다.** 물론 그 동안 기본 프로필 사진으로 보이게 되지만, 일단은 빠르게 화면을 보여드리고자 이렇게 구현했습니다. (성능개선을 전부 마친 지금은 한번에 보여드리는게 어떨까 싶기도 하네요.)

원래 저희 사이트에서는 프로필 사진을 불러올 일이 그리 많지 않았습니다. 내 프로필 탭에서나 어쩌다 한번씩 불러오는 것이 고작이였기 떄문에, 간단하게 혀냊 백앤드 솔루션으로 쓰고 있는 파이어베이스의 storage 접근 함수를 이용한 함수를 사용하고 있었습니다.
<!-- 
```js
function getPhotoUrl(uid) {
  return storage.ref().child(`users/${uid}`).listAll()
  .then((res) => {
    let promises = [];
    res.items.forEach((item) => {
      promises.push(item.getDownloadURL())
    })
    return Promise.all(promises)
  }).then((urls) => { return (urls[0]) })
}
```

위와 같이 파일의 URL을 다운 받는 `getDownloadURL`을 이용한 함수 `getPhotoUrl`를 만들어 쓰고 있었습니다. 이 때는 아직 백앤드를 도입하기 전이라서, 프론트 단의 `getPhotoUrl` 함수를 이용해서 사진 URL을 불러왔습니다.  -->
<br> <br> 
캐시를 전부 삭제한 다음 성능을 테스트 해보았습니다. 100명의 가상 회원을 만들어 두고, 각각 프로필 사진을 로딩하는데 걸리는 시간을 측정해 보았습니다.

![fromt_final](https://user-images.githubusercontent.com/71186266/185648030-220c43c5-d041-4218-b17b-aa318410ca84.png)

프론트 단에서 처리시 평균 30.0651초가 걸렸습니다. 가장 빠른 것은 1.509초만에 처리 되었고, 가장 느린 것은 43.657초가 소요되었습니다. 동기적으로 작동하듯 위에서 부터 로딩 되었습니다. 가장 먼저 보이는 1~20위권은 늦어도 2초 안에 로딩 되었지만, 느린 것은 사실입니다. 따라서 백앤드 단에서 새로 함수를 만들어 주었습니다.

<br> <br>
이후 같은 일을 하는 함수를 백앤드에서 새로 만들어 주었습니다. 구글 클라우드에 직접 접근해서 해당 uid가 가진 프로필 사진의 URL을 가져옵니다.

![final_test back2](https://user-images.githubusercontent.com/71186266/185649240-fe386819-92cb-4ff0-82a1-5035e515cb5c.png)

캐시를 지우고 테스트 해본 결과 **평균적으로 0.988초가 소요되었습니다.** 이는 약 30.430배의 차이입니다. (최소 0.572초, 최대 1.659초) <br> <br>

이번 경험으로 백앤드와 프론트앤드를 나누는 것의 중요성을 다시 한번 느꼈습니다. 대략 생각했을 때는 뭐 얼마나 큰 차이가 날 까 싶지만, 겨우 100개의 데이터만 해도 이렇게 큰 차이가 있었습니다. 브라우저는 화면을 랜더링 하는 데에만 집중하게 하고, 최대한 부담을 줄여주고, 나머지는 백앤드가 수행할 수 있도록 해주는 것이 정말 중요하다는 것을 다시금 느껴볼 수 있었던 좋은 경험이였습니다. 
