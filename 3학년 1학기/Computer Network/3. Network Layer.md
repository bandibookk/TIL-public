# 3. Network Layer


### 인터넷이란..
인터넷은 전세계 수백만 또는 수십억 컴퓨터들을 연결하는 네트워크입니다. 한 컴퓨터의 Application Layer의 메세지는 다른 컴퓨터의 Application Layer에 도착합니다. 인터넷은 연결장치로 연결된 수 많은 **네트워크나 링크**의 조합이며, 다양한 LAN과 WAN을 연결하는 인터넷 망입니다.        

<br/>

### 기존 방식의 문제점..
기존 Data Link Layer까지의 Circuit Switching 방식은 거대한 네트워크의 연결에 너무 많은 시간이 소요되었습니다. N개에 노드에 대해 무려 O(N^2)의 시간이 소요되었습니다. 유선전화에서 지금도 사용하는 방식인 해당 방식은 각 단말에게 물리적인 circuit이나 channel을 주고, 1:1로 통신하게 만드는 방식이였습니다. 모든 노드를 직접 1:1로 연결해야 했고, 계속해서 **독점적인** 연결을 유지해야 했으므로, 인터넷을 연결하는 방식으로는 굉장히 비효율적이였습니다. 예를 들어 1시간 통화에서 단 한마디만 나누는 경우를 생각해봅시다. 한 마디를 하는 동안만 연결하고 끊으면 훨씬 효율적이겠죠?      

<br/>

### IP는 이런 문제를 어떻게 해결하였는가?
이러한 문제를 해결하기 위해 도입된 정보 통신 규약이 Internet Protocol. 즉, **IP**입니다. IP는 Network Layer에서 IP 주소지정과 패킷 분할 및 조립 기능을 담당합니다. router를 이용하여 패킷을 교환하는 방식을 **Paket Switching** 방식이라고 부릅니다. 각 노드를 1대 1로 연결하는 것이 아니라, 라우터를 두고 한 라우터는 근처의 노드들과 연결합니다. 그리고 라우터와 라우터 간에 통신을 하는데, message를 데이터 뭉치인 패킷으로 나누어 전송하고, 받는 쪽에서는 다시 모아 원본 메세지를 복원해냅니다. 연결을 항시 유지하는 것이 아니라 주고 받을 때만 연결하므로 **Connectionless service**라고 부릅니다. Connectionless Packet Switching 방식은 **best effort service입니다.** 쉽게 말해 그냥 최선을 다 한다는 말인데, 최선을 다 할 뿐이지 **데이터가 손실 없이 전송 되었는지, 순서는 맞게 전송 되었는지를 보장하지 않습니다.** 다만 최선을 다 할 뿐.. (이러한 문제점은 차후 다음 계층에서 TCP를 통해 해결하게 됩니다.)

<br/>

## 3.1 Connectionless Packet-Switching
Sorce 단말의 Network 계층에서 데이터를 여러 패킷으로 쪼게어 냅니다. 이후 라우터를 통해 데이터를 전달하는데, 각 라우터는 각 패킷을 전송 할 때 그 때 그 때 최소의 cost로 전달 할 수 있는 **최단경로**를 알아 내어 해당 라우터로 전송을 시작합니다. 예를 들어 1번 패킷은 라우터 R1 ->  R2 -> R5의 루트로 전송되었는데, 2번 패킷은 R1 -> R3 -> R4 -> R5의 루트로 전송 될 수도 있습니다. 이런 경우에는 **순서가 뒤바뀔 수 있겠죠?** 또한, 모종의 이유로 4번 라우터 R4가 파괴되었다고 가정합시다. 그런 경우에는 2번 패킷은 목적지에 제대로 전달 될 수 없겠죠? 이런 상황에서 패킷은 **손실 될 수 있습니다.** 하지만 **IP는 이런 순서 뒤바뀜이나 손실을 감지해서 복구 요청을 보내는 기능이 없습니다.** 다만 최선을 다 할 뿐.. 


<br/>

## 3.2 Forwarding process in a connectionless network
각 라우터는 **Routing table**이라는 표를 가지고 있습니다. 각 라우터는 Routing table을 참고하여 도착지점까지 패킷을 보내려면 당장 어떤 인터페이스로 패킷을 전송할지 결정합니다. 이런 **Routing table을 만드는 과정을 Routing이라고 부릅니다.** 그리고 이런 **Routing table을 보고 수신한 데이터를 어디로 보낼지 결정하는 과정을 Forwarding이라고 부릅니다.**

## 3.3 Delay in connectionless network
각 라우터는 패킷들을 처리하는 동안 도착한 패킷들을 임시로 보관하는 queue를 가지고 있습니다. 무한 대기를 방지하기 위해 이 queue는 크기가 제한 되어있습니다.**queue가 꽉차게 되면 오래된 패킷을 버려서 무한한 Delay를 예방 하는 것입니다.** 이 **Queueing Delay**는 Routing table을 만드는 과정이 오래 걸려 발생하는 Routing table Delay보다 그 총합이 훨씬 크며, 패킷 스위칭의 단점에 해당합니다. 이런 딜레이는 어떻게 줄일 수 있을까요? **의도적으로 받는 속도를 제한합니다.** 초당 처리 가능한 만큼을 예상해서 감당 가능한 만큼만 받는 것입니다. 하지만 이 도한 예측이 어렵다는 문제가 있습니다.

<br/>

### 이 문제를 해결하겠다! 연결 지향 서비스
**Connection-Oriented Service**는 setup, data transfer, teardown의 3가지 페이즈가 요구됩니다. 패킷 전달 내내 연결을 요구하고 쪼개놓은 패킷을 통째로 보내버립니다. 그럼 송수신자 정보가 패킷 내에는 필요 없어 보이지만, 커넥션리스로 구현된 라우터를 지날 수도 있기에, 이 때에도 송수신자 정보는 요구됩니다. 각각의 패킷은 virtual circuit identifier **(lable)** 을 가지고 있습니다. 각 패킷은 이 레이블을 기반으로 forwarding됩니다. **서킷 스위치의 장점을 취하는 패킷스위치 방식을 만들려다가 둘의 단점을 모두 경험하게 되어 조금 실패한 방식입니다.** 위에서 언급한 의도적인 제한을 도입합니다. 그래서 queueing delay가 거의 없습니다.

1. **Setup phase:** virtual circuit을 위한 라우팅 테이블을 만듭니다. 소스 및 대상 주소로 테이블을 만듭니다.
2. **Data transfer phase:** 작성된 enrty를 기반으로 패킷을 주고 받습니다.
3. **Teardown phase:** 소스가 모든 패킷을 전송한 다음 teardown 패킷을 보냅니다. 연락을 끊기 위한 패킷입니다. 모든 라우터들이 해당 항목을 삭제합니다.

장점: 라우팅 테이블에 레이블을 기록하는 방식은 노드를 기록하는 방식보다 매우 매우 용량을 적게 차지합니다. log를 씌워준 급. 그래서 테이블 딜레이가 매우 적습니다.(레이블링) 또한 수용 가능한 만큼만 패킷을 수용하기 때문에 queueing delay가 거의 없습니다.

단점: **3 phase 과정이 더 오래 걸릴 수도 있습니다.** 에를 들어 '안녕' 한 마디를 말 하기 위해 전화기를 들어서  -> 번호를 누르고 -> 받을 때 까지 기다렸다가 -> 말 하고 -> 끊는 등 연결을 맺고 끊는 과정이 오히려 더 오래 걸리는 일이 될 수도 있습니다. flow가 제한 되어있는 **국가간의 통신** 등에는 유리하다고 볼 수 있습니다.
