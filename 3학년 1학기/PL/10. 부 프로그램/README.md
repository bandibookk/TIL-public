
# 10. 부 프로그램
- 함수는 실행하면서 주변환경을 망가뜨리면 안 된다.
**referential transparency: 함수의 결과는 입력 파라미터에만 의존합니다.**

**<함수의 반환 값으로 허용되는 자료형>**
1. FORTRAN, ALGOL 60: 스칼라형(실수, 정수, 논리형 숫자만)\
2. Pascal: 스칼라 + 포인터
3. PL/1: 스칼라, 포인터 + 문자열 // 하나씩 추가되네
4. Ada: 배열 레코드 포함한 모든 자료형 가능! - 반환문의 직교성!
5. C, C++: 스칼라형, 포인터(직교성)  

# 10.2 매개변수 평가와 전달기법
### 형식 매개 - 실 매개 변수 대응법
1. 위치 대응: 걍 순서대로 대응
2. **Ada!: 위치 + 실 매개 병행 사용**
예시) 아래는 모두 같은 애들 <br>
TEST(A => 0.1, C => 50, B => 100.0) - 순서 무관 <br>
TEST(0.1, C => 50, B => 100.0) - 위치, 실 매개 섞어도 됨. <br>
TEST(0.1, 100.0, 50) - 위치로만 해도 돼 (당연) <br> <br>


## 호출 방식 정의 정리
1. **참조 호출(by reference)**: 실 매개 변수 **주소**를 대응되는 형식 매개 변수에 보냄 <br>
2. **값 호출(by value)**: 실 매개 변수의 **값만** 형식 매개 변수로 복사 - 마치 지역 변수 처럼. 실 매개 변수랑은 남남. <br>
3. **결과 호출 기법(by result)**: **피호출자가 반환 직전에 형식 매개변수의 값을 대응되는 실매개 변수에 복사 후 반환...** <br> 뭐가 return으로 나올지 모르는 이상한 애.. 입력 받는 매개 변수를 그냥 데이터 담는 락앤락 통으로 보고 값 다 버려버리고 지 맘대로 뭐 담는 이상한 아이 <br>
4. **값-결과 호출 기법(by value-result)**: by value + result! <br>
우리가 아는 보통의 함수 호출 기법! 값 복사해서 쓴 다음에 결과 반환! <br> 정의는 **값 호출 기법과 결과 호출 기법을 함께 사용한 방법 callee 실행 시작에서 값 호출, 끝에서 결과 호출 기법을 적용함** <br>
5. **이름 호출 기법(by name)**: **형식 매개 변수의 이름이 사용될 때마다 그에 대응되는 실 매개변수 <U>자체가</U> 사용된 것으로 간주!** 예를 들어 v[k]를 a로 받아왔다면, a가 사용될 때 마다 k를 찾아내어 v[k]를 이용한다.   <br>
매번 r-value, l-value를 계산함. 대신 구현이 어렵고 프로그램 판독성이 아주 난해함  <br>

# 10.3 형식 매개 변수 명세
- 실 매개변수와 형식 매개변수의 **정적 형 검사** -> **형식 매개변수 명세표 요구!!**
- 형식 매개변수 명세: 자료형, 전달 기법, 초기값, 대응관계
#### 예시
1. Pascal: 값 전달이 기본, var 선언 -참조전달, 값-결과 전달
2. Alogol 60: 이름전달 기본! value - 값 전달
3. Ada: in(값 전달), out(결과 전달), in out(값-결과 전달)
- in: 지역 **상수** 취급! 지역 변수 취급 X
- 형식 매개변수의 디폴트값 선언 가능 (상수인 in도 가능)
- Ada 함수는 투명성을 위해 in 모드만 가능(뭔 소리야)


# 10.4 부수 효과와 이명
- goto문 -> 악질
- 포인터 사용: aliasing 발생 유도!
- side-effect!

### 부수 효과 - side effect들~
1. 단위 프로그램간 의사 소통 허용: 비지역 변수 접근?
2. 참조 전달기법과 이름 전달기법: **실 매개변수 값을 변화 시킬 수도 있단다** 
3. 단점?: 프로그램 판독성 저하, 심각한 오류 발생, 함수의 투명성 상실

### 이명
- 동일한 기억장소를 함께 사용해버려서 의도치 않게 간접적으로 변수의 값이 변하는 일이 발생.. 초기 언어들은 효율적인 기억 장소 사용을 위해 이명을 허용했다가 낭패를 봤지...


# 10.5 연산자 overloading
**한 개체가 두 가지 이상의 개념 갖음. 영역 구멍과 대조**
- 사용 이유: 자연스러운 일반적 표현 가능, 문맥에 의해 구별되어서 혼동되지도 않음
- 중복정의 사용시 구별법: 문맥에서 파악 가능하면 컴파일러가 수행. 아닌 경우 사용자가 제약 사항을 명시 (자격 부여)
- 결정: 자료형 정보를 파스 트리의 각 노드에 붙인 것을 가정
# 10.6 Generic Functions - 포괄 기능
- **generic procedure: 포괄 프로시저. 하나 이상의 요소를 매개변수로 받아들여 실 프로시저를 생성할수 있는 프로시저 틀!**
- **컴파일 시간에 실매개 변수가 대체되어** 실 프로시저 발생
- 코딩 오류 감소, 프로그램 길이 축소 -> 생산성 Up!
- 추상화 제공
1. Ada
- macro의 확장 개념
- 프로그램 생성 틀
- 실 프로시저는 번역시 정적 생성
- 고려사항: 사용 가능 연산?
# 10.7 코루틴! 
**호출된 프로그램의 수행이 완전히 끝나기 전에 타 프로시저로 제어를 넘겼다가 재개 할 수 있는 프로시저**

### A에서 resume B 문장 실행 시 수행 작업
1. A의 resume 문장 **다음 위치**를 A의 제어 장소에 기억
2. coroutine B의 실행 위치를 알기 위해 **B의 제어 장소의 값 참조**
3. B의 제어 장소의 참조된 값으로 제어 분기 
