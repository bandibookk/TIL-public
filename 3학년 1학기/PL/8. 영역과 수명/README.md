# 8. 영역과 수명
모든 식별자는 고유의 영역을 가지고 있다. 영역은 자신이 효력을 나타낼 수 있는 영역을 의미하는데 해당 영역 안에서만 사용이 허락된다. 영역에 대한 이해는 프로그래밍에 있어서 매우 중요하다. 적절한 영역 안에서 사용 가능하도록 만들어 줘야 효율적인 프로그램을 만들 수 있기 때문이다. 영역은 수명과도 관련이 있는데, 보통은 영역을 벗어나면 수명이 끝난다. 다른 이유로도 수명은 끝날 수 있다.

#### <목차>
#### 8.1 블록과 영역 - **[이동](#81-블록과-영역)**
#### 8.2 정적 영역과 동적 영역
#### 8.3 언어에서의 영역
#### 8.4 변수의 수명
#### 8.5 Ada의 영역


# 8.1 블록과 영역
### 영역과 수명
- 영역(Scope): 식별자의 사용이 허락되는 프로그램의 범위
- 수명(Extent or Life time): 식별자가 값을 보유할 기억장소가 배정 되어있는 실행 시간 

영역과 수명이 왜 있는걸까? 그냥 모든 식별자를 전역 변수로 만들어 주면 안 되는 걸까?
<당연히 안 됩니다.>
1. 식별자 사용이 복잡해진다.
2. 식별자 혼돈이 유발된다.
3. 프로그램 합성시 문제가 발생한다.

## 8.2 정적 영역
- 식별자의 사용 영역을 블록 정적 내포관계로 결정(컴파일러 언어)
1. 지역변수: 현재 블록에서 선언, 형식매개변수 (함수의 매개 변수)
2. 비지역변수: 현재 블록에서 사용 but 바깥 블록에서 선언됨
3. 전역변수: 모든 블록에서 사용 가능

- 무료변수: 현재 블록에서 선언되지 않고 사용되는 변수

**정적 영역은 변수를 찾을 때, 자신을 포함하고 있는 블록에서 먼저 찾은 다음, 없으면 그 바깥쪽 블록을 찾아본다.**

### 정적 영역 변칙 현상 anomaly 
- 영역 구멍 (hole-in-scope): 내포된 블록 사이에 동일한 이름의 지역변수를 선언하면 바깥 블록에서 선언한 지역변수는 내부 블록 구간에서 사용 할 수 없는 현상. 즉, **밖에서 선언했는데 그거랑 똑같은거 지금 블록에 또 있으면 밖에 있는거 못 쓰는 현상**

1. 영역 구멍이 발생한다.
2. 영역과 선언의 가시성에 약간의 차이를 갖는다 (뭔 말임)

**단, Ada와 Java에서는 영역 한정자로 영역 구멍을 해결했다. `어느 블럭의 어떤 변수`라는걸 명시해주기 때문**

## 8.2 동적 영역
- 식별자의 영역이 **실행시간에 확정**
- 프로그램의 실행 **순서**에 따라 식별자의 사용 영역이 결정된다.
- 인터프리터에서 주로 사용.

### 동적영역 규칙 ⭐⭐⭐⭐⭐
1. 자기 블록 탐색
2. 자기 블록을 <U>호출한</U> 블록을 탐색
3. 해당 변수를 찾아낼 때까지 이를 계속 반복한다.


# 8.3 주요 언어에서의 영역

### 1. FORTRAN
FORTRAN: 영역과 수명의 빌런. COMMON이라는 전역변수 선언 가능
### 2. JOVIAL
JOVIAL: 알골 68 후계자. 정적 영역 규칙(블록). 실행시간에 배개변수 형 검사
### 3. PL/1
PL/1: 알골 60 후계자. **BEGIN..END 블록 개념 도입!**
but, 얘도 빌런이다. **묵시적 선언 가능**으로 사고를 쳤다.
원래는 영역 구멍이 나고 말면 되는 문제인데 **묵시적 선언**으로 인해 어떤 변수를 호출하는건지 매우 혼란스러움. (혼동)
### 4. ALGOL 68
BEGIN..END 블록 개념 일반화 시킴
ex) if-fi, then-else, else-fi, begin-end, loop-pool, case-esac 등 다양한 블록 단위
### 5. Pascal
수업 다시 듣자 몬소린지 모르겠네.
### 6. C, C++, Java
알골과 같은 블록 개념 언어, 대괄호 {} 영역 정의. 영역 구멍 발생 가능하고, 모든 함수 전체를 영역으로 하는 외부 영역 = 전역 변수가 존재함. 다른 파일에서도 볼 수 있는 찐 전역변수이다. <br>

### 7. Ada


**C++이랑 자바는 변수 선언이 어디에서나 나타날 수 있고, for문 초기화식에 제어 변수 선언을 허용함.**

||영역의 특징|
|----|----|
|FORTRAN|common이라는 전역변수 선언 가능|
|JOVIAL|알골 68후계자, 블록 - 정젹 영역 규칙, 실행시간에 매개변수 형 검사|
|PL/1|알골 60 후계자, **BEGIN..END 블록 개념 첫 도입**, **묵시적 선언 가능**|
|ALGOL 68|BEGIN..END 블록 개념 일반화, 다양함|
|Pascal|BEGIN..END을 복합문 개념으로 사용, 정적 영역|
|C, C++, Java|대괄호 블록 도입, 영역 구멍, 찐 전역변수|

1. **블록은 JOVIAL, begin..end는 PL/1에서 처음 도입했습니다.**
2. Pascal은 begin..end를 다른 방식으로 이용합니다.
3. c, c++, java는 갓입니다. 대괄호, 찐 전역변수



## 블록 구조를 통한 영역개념의 장점
1. 지역성(locality)를 높여준다: 모여있으면 효율 업. 변수를 사용할 프로그램 가까이에서 선언
2. 운영 체제하에서 작은 working set 요구. 작은 크기의 기억장소를 요구. 그 순간 실행되는 만큼만 확보하면 된다.
3. 표준 패키지를 사용자 프로그램에 결합시켜 하나의 프로그램을 만들기 쉽다.
4. **프로그램 구성을 단계적으로 세분화 하는데 도움이 된다.**

# 8.4 수명
- 변수가 기억장소를 할당 받은 기간(실행시간)
### 1. Fortarn
정적 기억장소 할당 -> 변수 수명 = 프로그램 수명 (미친놈)

### 2. Algol 60
- 변수 수명: 블록 시작~끝
- own 변수: 정적 할당, static 변수 수명이 주 프로시저 시작~끝
- 나머지 변수들은 스택 기반 동적 할당이다. 변수의 크기가 실행시 할당 후, 고정된다.

### 3. PL/1
|type|수명|
|:----:|:----:|
|automaic|블록 진입 ~ 탈출|
|static|주 프로시저 진입 ~ 탈출|
|controlled|allocate() ~ free()|
|based(stack)|allocate() ~ free()|

## 동적 수명 개념 ⭐
별거 없고 힙 사용한건데, <br>
C: malloc() ~ free() 이런거다. <br>
C++: new ~ delete <br>
Pascal: new() ~ dispose() <br>
PL/1: ALLOCATE() ~ FREE() <br>


## 수명과 기억장소 할당 정리
|기억장소 할당|정적 할당|Stack 기반(동적)|Heap 기반(동적)|
|:----:|:----:|:----:|:----:|
|Fortran|변수 수명 = 프로그램 수명|X|X|
|ALGOL 60|own 변수|X|이외의 모든 변수 - 재귀 허용|
|PL/1|STATIC|AUTOMATIC|CONTROLLED, BASED|
|C, C++, JAVA|static|auto(default)|malloc-free, new-delete, new|



