# 6 변수, 바인딩, 식, 제어문
# 6.1 변수
### 변수의 4대 요소
1. 이름 
2. 속성 집합 - attribute 
3. 참조 reference
4. 값 value

**이렇게 4대 요소가 연결 되어 있어야한다.**
ex) X := 3.14
1. 이름: X
2. 속성: 실수이다. (원주율)
3. 참조: 값이 저장된 위치 주소!
4. 값: 3.14

# 6.2 binding 개념
기본적인 추상화 메커니즘으로 '이름'과 '속성'을 연겨라는 과정
ex)
1. const num5 = 5; <br>
-> num5에 **상수라는 속성**과 **값 5**가 바인딩
2. int x = 100; <br>
-> 이름 x에 **변수, 정수 속성**과 초기**값 100**이 바인딩
3. x := 2; <br>
-> x에 새로운 속성으로 **값 2**가 바인딩


### 바인딩 시간이란?
바인딩이 발생되는 시간으로 언어의 각 요소들 마다 바인딩 되는 시간이 다르다. 언어들간의 중요하고, 미묘한 차이들은 전부 바인딩 시간이 어떻게 되어있냐와 관련이 되어있다. <br>
종류로는 **언어 정의시간, 언어 구현시간, 번역시간, 실행시간**이 있고, **왼쪽으로 갈 수록 빠른 바인딩, 오른쪽으로 갈 수록 느린 바인딩이다.**  <br>

바인딩이 빠를 수록, 빠르고 효율적이고, <br>
느릴 수록 유연합니다! 동적 바인딩은 느린 대신 유연하고, 정적 바인딩은 좀 더 빠릅니다.<br>
<U>바인딩 시간이 느린 순서대로, 유연한 순서대로 정렬해보겠습니다.</U>

#### 1. 실행시간 -> 동적 바인딩 (젤 느려)
프로그램의 **실행 시간에** 발생되는 바인딩. 변수의 값을 배정하거나, 변수에 기억 장소를 할당하는 등의 행위를 담당한다.
- 모듈 프로그램의 실행 시작시 발생하는 바인딩: 형식 매개변수와 실매개 변수간의 바인딩, 지역 변수 기억장소 할당
- 프로그램 실행시 사용 시점에 수시로 발생하는 바인딩: 배정문으로 값을 변수에 저장하는 것 <br>
**결론적으로 동적 바인딩은 변수에 값 저장하고 기억장소 할당하고 전부 동적 바인딩이야.** <br>

#### 2. 번역시간 -> 정적 바인딩 (좀 빨라)
**언어를 번역하는 시점에서 발생되는 바인딩으로 이 때의 바인딩을 정적 바인딩이라고 부른다.** 다른 말로는 컴파일 시간, 링크 시간, 로드 시간이라고도 부른다. **전체 프로그램 실행동안 유지!** <br>
번역시간 예시: 변수의 형, 자료 구조의 형과 크기, 레코드 항목들의 형을 확정합니다.
**결론적으로 정적 바인딩은 크기 딱 정해진 만큼'만' 줘야하는 변수나 자료구조의 형과 크기등을 바인딩 하는 것이야.**

#### 3. 언어의 구현 시간 (좀 더 빨라)
언어 정의 시 일부 특성을 한정 X 언어를 컴퓨터에서 구현할 떄 일부를 확정하는 바인딩! **정수의 자릿수, 실수의 유효숫자 개수, 수의 기계 내에서의 표기법 등 그냥 언어 만들 떄 정해준 언어 자체의 특성이라고 보면 된다.**

#### 4. 언어 정의 시간
진짜 언어 자체 특성: **언어 구문 정의**, 반복문, 자료구조, 연산종류나 혼합형 연산의 피연산자들 형 결정 등등... <br>

ex) Y := X + 10
-> X: 현재값, 자료형, 자료형의 종류 등 
상수 10: 이진수로? 10진수로? 표현 방법과 의미
연산자 +: 연산자의 성질과 의미
배정문 := : 배정문의 성질과 의미 

![binding](https://user-images.githubusercontent.com/71186266/170642930-5e0ae5ed-4881-4dde-b03f-71a861ff2d1b.PNG)


# 6.3 선언 1
- **선언문 Declarations**: 실행시 사용될 자료의 속성을 언어의 번역기에게 알려주는 프로그램 문장!
- **디폴트 선언 default**: 묵시적인 선언입니다.
- 자료의 속성: 자료형, 크기, 이름, 생성 시기, 소멸 시기, 참조하기 위한 첨자 등을 가르킴디나.
- **ex) JAVA 선언문1**
```java
int []x = new int[10]
```
1. 생성, 소멸시기: 블록 시작과 종료
2. 자료형: 1차원 배열
3. 원소 수: 10
4. 첨자 범위: 0 ~ 9
5. 원소 자료형: 변수
6. 배열 이름: x

### 선언문의 목적
선언문의 목적은 **결국 효율입니다.** 
1. 주기억 장치 사용과 변수, 배열, 레코드 등의 **효율적인 접근이 가능합니다.**
2. **생성과 소멸 시점을 알기 떄문에, 스택 기반의 기억장소 할당 등을 수행 가능합니다. -> 주기억 장치 경영의 효율성**
3. **정적 형 검사가 가능합니다.** 메모리를 미리 얼마나 확보할지 정하기 위해 필요한 검사입니다.
- 형고정 연산: 하드웨어 제공
- 혼합형 연산: 프로그래밍 언어에서 제공!
- **정적 형 검사로 혼합형 연산을 형고정 연산으로 변환시키면 아주 효율적입니다~~** 혼합형 연산 -> 캐스팅으로 형고정 연산
-  **유연성을 추구하기 위해** 혼합형 연산의 동작 형 검사


### 그놈의 형 검사 종류입니다.
선언부 형 검사의 종류에는 크게 두 가지가 있습니다. 
#### 1. 정적 형 검사 (static type checking)
**모든 변수의 형 선언을 요구합니다!**
단점: **유연성을 포기** 자료의 생성과 소멸에 많은 제약이 존재합니다.
장점: 실행 시간 효율이 높습니다~ 선언문의 목적은 뭐다? 효율. 짱.
#### 2. 동적 형 검사 (dynamic type checking)
선언문 사용 없습니다~
장점: **단순화, 유연성이 높다**
단점: 프로그램 실행 시간 지연, 자료 표현상의 효율 저하, 복잡한 기억 장소 경영 기법을 요구! 즉, **느리고, 복잡해서 에러가 많다**
#### Alogol, Java, Ada
약간의 효율성을 상실하여, 실질적인 큰 유연성을 얻는 선언문을 채택했다. 
결국에는 **유연성을 포기하면 높은 효율을 가질 수 있고,** <br>
**유연성을 가지려면 느리고 복잡하고 에러가 많습니다.** <br>
언어 대장 자바는 유연성을 택했습니다.

## 선언문의 목적 - 결국엔 효율!
1. 주기적 장치 사용과, 변수, 배열, 레코드 등의 **효율적인 접근** 가능
2. 주기억 장치 **경영의 효율성**: **생성과 소멸 시점을 알므로**, 스택 기반 기억 장소 할당 가능 
3. static type check - 정적 형 검사 가능!
- **메모리를 얼마나 확보할지 정할 수가 있다.**
- 정적 형 검사를 이용해서 혼합형 연산을 형고정 연산으로 변환 가능하다 -> 효율성 추구!
- **혼합형 연산의 동적형 검사 -> 유연성 추구**
- 형고정 연산(type specific operation): 하드웨어 제공
- 혼합형 연산(mixed operation): 프로그래밍 언어 제공

# 6.3 선언 Declaration 2
- 실행 시 사용될 자료의 속성을 언어의 **번역기에게 알려주는** 프로그램 문장

<**정적 형 검사 예시**>
```c++
int X;
float Y; 
cout << X + Y;
```
1. 혼합형 연산 발견
2. X를 실수 형 변환
3. 실수 형 덧셈 코드 생성
**이게 다 선언 덕분에 가능하다!**
## 6.3.1 형 검사의 예시 3가지
### 1. 정적 형 검사 (static type checking) 
- **유연성을 포기하는 대신 효율을 추구 하겠습니다.**
- 모든 변수의 형 선언을 요구함.. -> 유연성 포기!
단점으로 작용: 자료 생성, 소멸, 내용 변경에 많은 제약이 있다
- **장점: 실행 시간 효율이 높습니다 - Java, C, Algol, Pascal 등..**
### 2. 동적 형 검사 (dynamic type checking)
- 선언문 사용 X **효율을 살짝 포기하는 대신 유연성을 갖겠습니다.**
- 장점! 프로그래밍이 단순하고, **유연성**
- 단점: 프로그램 실행 시간 지연, 자료 표현상 효율 저하, 기억장소 경영이 복잡함..
- Lisp, APL, Snobol 4등의 인터프리터 언어 -> 느리고 에러가 많습니다.
### 3. ALgol, Java, Ada - 약간 효율 포기하고 큰 유연성을 갖는 선언문을 채택!
왜? 몰라 찾아보자.

# 6.4 배정문 (Assignment statement)
변수 내용을 변경시키는 기본 연산입니다.
## l-value와 r-value
배정 연산자의 왼쪽과 오른쪽을 의미! <br>
l-value는 값이 저장되는 위치-주소, 참조이고, <br>
r-value는 주로 저장되는 '값'을 의미합니다. <br>

|자료형|l-value|r-value|
|:----:|:----:|:----:|
|변수|변수의 주소|변수의 값|
|배열 "A[i]"|i 번째 원소의 위치|원소 A[i]의 값|
|상수 3.5|X|값 3.5|
|포인터 ptr|ptr이 저장된 위치|**ptr이 가르키는 위치**|

## 배정문들
### 빌런 1. Bliss
변수 이름이 l-value 뿐이다. r-value는 변수 앞에 '.'을 찍는 이상한 언어
### 빌런 2. Algol 68
앞에 "ref"가 붙어야 l-value란다..? 포인터는 "ref ref"? 증말 까다롭다요.
### 3. 단순 배정문 '='  이제 부터 괜찮은 애들
단순 배정문 '='을 쓰는 아이들이 많아졌당. <br>
거기까지는 좋은데, <U>**"관계 동등 연산자도 똑같이 쓰는 애들 헷갈리게 한다: PL/I"**</U> 뭔 말이냐, 다른 언어의 '=='를 '='로 썼다는 것이다.. 당연히 헷갈리지. 둘을 혼용하면 안 된다. <br>

**혼용 안 하겠다고 배정문을 바꾼 애들도 있다. Alogol 60, Pascal** <br>
**얘네는 배정 연산자를 :=로 바꿨다잉**

### 4. 다중 목적지 배정문: a = b = 0; 이런거
빌런 PL/I: `SUM, TOTAL = 0` -> sum과 total에 0 대입.

### 5. 조건 목적지 배정문 flag ? count1 : cont2 = 0;
걍 삼항 연산자
### 6. 복합 배정 연산자 sum += 10 이런거
C, C++, JAVA에서는 이항 연산자에 복합 배정 연산자를 허용함.
### 7. 단항 배정 연산자 cnt++; 이런거
전위 연산자, 후위 연산자 이런거
### 8. 혼합형 배정문: 자료형이 다른 애들끼리!
- Fortran, C, C++: 묵시적 형 변환을 적용
- Java: 확장 형 변환인 경우에만 혼합형 배정 허용
- Pascal: 몇 개 묵시적 형 변환 허용 - integer는 real에 배정 가능
- Ada, modula-2: 혼합형 배정 불허
##### 묵시적 형 변환: 우변 식이 평가된 후 발생합니다. 
```c++
int a, b;
float c;
c = a / b; 
```
-> 묵시적 형 변환 발생! a와 b가 float으로 변환된다.



# 6.5 상수와 변수 초기화
상수는 l-value의 사용금지이다. 실질적으로 참조 없이 값만은 보유함
<고려 사항 4가지>
1. 단순 변수, 구조 변수 (array)
2. 상수 값 표현: 수식 가능? 여부
3. 상수 값 배정 시간 (정적? 동적? 배정 가능?)
4. prefefined constatnt 제공?

## 4가지 예시를 살펴보자.
1. **Pascal**: const 사용으로 상수 선언! 숫자 스트링 열거형만 됨.


||**상수**|**변수 초기화**|
|:----:|:----:|:----:|
|Pascal|const로 선언. 숫자, 스트링, 열거형 가능|X|
|Algol68|상수는 `=`로 선언|변수는 `:=`로 배정|
|Ada|constatn 사용. 구조형도 ok|O|
|C|`#define`이였다가 정식으로 생김|배열도 O|
|JAVA|const 있는데 쓰진 않고, static final|배열 객체라 new 필요|

# 6.7 조건문
# 6.8
