# 4.2 PL 구현 기법
## 컴파일러 언어와 인터프리터 언어
- 컴파일러 방법의 장점: 기계어로 번역된 것을 하드웨어 인터프리터가 디코드 하여 실행
-> 빠르고 효율적! 한번 디코딩하면 반복해서 쓸 수 있다. 대신에 번역된 프로그램이 큰 기억장치를 요구! <br> 원본 -> 기계어 -> 하드웨어 인터프리터가 디코딩
- 인터프리터 방법의 장점: 하이브리드! 번역기가 **중간언어**를 생성 후, **중간언어로 작성된 프로그램을 소프트웨어 인터프리터로 실행한다.** 실행시간에서는 비효율적이지만, 사용자 적응성을 제공한다. <br>
원본 -> 중간언어 -> 인터프리터로 실행

# 송프언

1. Binding 문제
```c++
Y := X + 10에서의 바인딩 구하기
Y빼고 다 들어간다요.

변수: 현재값, 자료형, 자료형 자릿수, 수의 내부 표기법
상수: 표현 방법과 의미 (이진수냐? 문자열이냐? 등)
연산자, 배정문: 성질과 의미
```

1. Y에 X + 10 배정 -> 실행시간 배정, 동적 바인딩
2. X에 값 초기화 -> 실행시간 배정, 동적 바인딩
3. X의 자료형 확정 -> **번역시간**, 정적 바인딩
4. X가 숫자 자료형이므로, 자료형 **자릿수**를 확정 -> 언어 구현 시간
5. X라는 변수의 기계 **내부 표기법** 확정 -> 언어 구현 시간
6. `+`라는 연산자와 `:=`라는 배정문 관한 **언어 구문 정의**는 **언어 정의 시간**에 일어남. 
7. **상수 10의 표현 방식 -> 언어 구현 시간** 

||Y := X + 10|
|:----:|:----:|
|실행 시간|Y에 r-value 배정, X에 현재값 초기화|
|번역 시간|X의 자료형 확정|
|언어 구현 시간|X의 자료형 **자릿수**,<br> 상수 10의 **기계 내에서의 표기법**|
|언어 정의 시간|`+`, `=`에 관한 언어 구문 정의|


# GOTO문
- 제어 전이!
- 장점: **효율성과 범용성이 선명하게 좋다.**
- 단점: **비구조적 - 판독성 저하로 프로그램 질이 떨어짐**, <br> **프로그램 유지보수가 난해함 - 디버깅 어려워짐**
- 이런 GOTO문 제거를 시도하는 과정에서 다양한 순서 제어문들이 생겨났다. 

### 비슷한 애들
- 프로그램 제어 전이의 측면에서...
1. IF문: 조건식의 진리값에 따라, 내포된 문장들의 순서를 실행하거나, 건너뛰게 하는 조건문
2. Case문: 조건식의 진리값에 따라, 많은 선택 가능한 문장들의 순서들 중에서 하나를 실행하도록 선택하는 조건문
3. 반복문: **하나 이상의 문장을 0번 이상 반복 실행시키는 문장**내포된 문장의 반복실행을 제어하기 위한 기법을 포함하는 복합문
4. 어셈블리 **JUMP**: Jump 명령어가 있다. 점프 명령어의 operand로 상수, 레이블, 레지스터가 올 수 있다.
- Algol-W에서 case문은 레이블의 중복을 허용하였다. goto는 유일해야했음.
- Goto를 제외한 각각의 goto 유사 명령어들은 어떤 방식으로 goto 명령어가 가지는 문제점을 해결 및 회피하였는 지 설명하라
- goto문이 기존에 수행했던 다양한 기능들.. 상황에 필요한 다양한 제어 구조를 제공하는 식으로 해결했다. 택일문, 반복문, 되부름 등.. 

# 4.2 프로그래밍 언어 구현 기법
저급 수준의 언어를 기계 언어로 하는 컴퓨터를 제공한 다음, 사용자가 고급 언어 프로그래밍을 하면 이를 컴파일러로 번역하여 기계에게 저급 언어를 알려준다. <br> <br>

**번역 기법**: source(원시 언어) -> translator -> target(목적 언어)
- 각 언어들을 컴파일러나 어셈블러가 번역하여 **목적 모듈**로 만든 다음, **링커**로 전부 합쳐서 **로드 모듈 -> 로더 -> 기계어**로 만든다. 로더는 메모리에 코드를 올리는 역할을 한다.

### 번역기의 종류
1. **컴파일러 (compiler)**
- **고급언어 -> 저급언어**
- 원시 언어: 고급언어
- 목적 언어: 저급언어 (기계언어와 유사)
- 저급 언어에서는 준기계어 형태 또는 어셈블리 언어

2. **어셈블러 (assembler)**
- **어셈블리 언어 -> 준기계어 형태**
- 원시 언어: 어셈블리 언어
- 목적 언어: 준기계어 형태

3. **링키지 에디터(linkage editor - linker)**
- 여러 개의 프로그램을 묶는 역할! **로드 모듈 생성!**
- 로드 모듈: 어느 정도 실행 가능한 하나의 기계어 **프로그램**

4. **로더 (loader)**
- **relocate! 메모리에 뭐가 들어갈지 알려주는 아이**
- 기계어 프로그램(로드 모듈)을 실제 실행 가능한 기계어로 번역해서, 주기억 장치에 적재

5. **프리프로세서(preprocessor)**
- **source와 target이 모두 고급 언어인 번역기**
- 고급 언어를 다른 고급 언어로 번역 ->  출력된 고급 언어를 이미 구현된 방법으로 실행시킬 때 사용
- 고급 언어 확장할 때 유용

### 6. **인터프리터!!!!**
- 그 자리에서 한 줄 한 줄 해섞!!
- **실행시켜버림! 일종의 시뮬레이션. 컴파일러랑 달라!**
- 고급 언어 기계를 다른 기계에서 소프트웨어로 시뮬하는 방법! python!


### 인터프리터 vs 번역

||특징|효율|장점|단점|
|:----:|:----:|:----:|:----:|:----:|
|**번역기**|입력 프로그램과 동일한 의미의 목적 언어 프로그램 생성|번역 효율적인 부분 - 반복 수행과 수식 계산 등|실행시간 효율성(디코딩 한큐)|큰 기억장치 요구|
|**인터프리터**|직접 입력 프로그램을 실행|I/O routine 등 시뮬 효율 존재|유연한 대신 효율 떨어짐|사용자 적응성 제공|
