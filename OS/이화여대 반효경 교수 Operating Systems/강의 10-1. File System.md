# File System
우리가 메모리에 접근할 때는, 메모리에 주소를 부여해, 주소를 통해 접근했다. <Br>
Fild은 `A named collection of related information`으로, 다양한 정보들을 `이름`을 통해 접근할 수 있게 해주는 논리적 단위이다. <br>
일반적으로 비휘발적인 저장 장치에 적용되고, 저장 장치 자체도 파일로 접근할 수 있게 해준다. C드라이브, D드라이브 폴더와 같이 저장장치 그 자체도 폴더로 접근 가능하다. <br>

## 1. 파일의 기본 속성들
### 1.1 `Operation`
`create`, `read`, `write`, `delete` 등이 있고, 이름과 같은 역할을 한다. <br> 
추가 설명이 필요한 오퍼레이션은 아래와 같다. <br> 
- `reposition (Iseek)`: 읽어들이는 시점을 바꾸는 연산이다. 주로 편집기에서 커서를 이동시킬 때 쓴다. 
- `open`, `close`: 디스크에서 파일 그 자체가 아니라 **파일의 `metadata`를 메모리로 가져오고 내리는 연산.**
### 1.2 `File Attribute`
파일 속성. 파일의 `metadata`로도 부르는데, 파일 자체의 내용물이 아니라, 파일을 관리하기 위한 각종 정보들을 가리킨다 <br>
예를 들어 파일의 이름, 유형, 저장된 위치, 파일 사이즈와 접근 권한, 각종 시간 정보, 소유자 등의 정보를 가리킨다. <br>

### 1.3 File System
운영체제에서 파일을 관리하는 부분이다. 파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리하고, 파일의 저장 방법을 결정하며, 파일을 보호한다.


## 2. Directory와 Partition
파일의 메타데이터 중 일부를 보관하고 있는 파일이다. 우리가 맨날 사용하는 `폴더` 개념이다. 여러 파일들을 모아두는 역할을 하는 파일인 것이다. <br>
파티션은 Logical Disk라도 불린다. 하나의 물리적 Disk에 여러 파티션을 두고 각각의 파티션에 서로 다른 `file system`을 깔 수도 있고, `swapping`할 떄 사용할 수도 있다! <br>
보통은 하나의 디스크 안에 여러 파티션을 두고 사용한다.


## 3. `open()` 연산 자세히 살펴보기
Operation `open()`의 과정을 좀 더 자세히 살펴보자. <br>

앞서 언급한 것처럼 `open()`은 파일의 메타데이터를 메모리에 올리는 연산이다. <br>
예를 들어 유저 프로세스 A가 아래와 같은 명령을 수행했다고 생각해보자. 
```
<사용자 메모리 영역>
fd = open("/a/b")
``` 
**커널 메모리 영역에는 전역적으로 사용되는 `Open File Table`이라는 현재 열려있는 파일들의 메타데이터를 모아둔 Table이 있다.** <br>
여기에는 root directory의 metadata가 기본적으로 있는데, 그 메타데이터를 뒤져 파일 `a`가 저장된 위치를 먼저 찾을 것이다. <br>
찾아냈다면 이제 Disk에서 `a`의 정보를 찾아 `a의 metadata`를 커널 메모리 영역의 `Open file table`에 올린다. <br>
그 다음 다시 Open File Table의 a의 메타데이터를 뒤져서 b의 주소를 알아낸다음 Disk를 뒤져 메타데이터를 커널 메모리 영역으로 끌고온다. <br>
이제, **커널 메모리 영역의 유저 Process A의 PCB에 `Open File Table`에서의 b의 인덱스를 저장한다.** 이렇게 해주면 언제든지 빠르게 b의 메타데이터를 확인할 수 있지 않는가? <br>
그리고 위의 fd에 그 값을 넣어준다! 그래서 파일을 열 때는 아래와 같이 열면 되는 것이다.  
```
<사용자 메모리 영역>
fd = open("/a/b")
read(fd...)
```
컨텐츠는 커널 메모리 영역에 캐싱된다.


## 4. File Protection
### 4.1 Access Control Matrix
기존의 메모리에 대한 보호는 그냥 `Read/Write`와 같은 연산에 대한 권한만 확인했으면 됐다. <br>
File은 여러 사용자가 공유하기 때문에, `어떤 사용자에게 권한이 있는가?`와 `어떤 연산이 가능한가`의 두가지 요소를 체크해야 한다. <br>
이에 표로 나타내는 것이 더욱 용이한데 이를 `Access Control Matrix`라고 부른다.


연산의 유형에 따른 접근 권한으로는 `Read/Write/Execution`이 있다. '실행'이 추가 되었다. <br>
한 가족이 컴퓨터를 공유해서 사용했던 경험이 있었다면, 공감할 수 있겠지만, **위 표는 희소행렬의 형태가 될 가능성이 높다.** <br>
유저나 파일의 종류는 정말 많은데, 서로 쓰는 파일의 종류는 천차만별일 수 있기 때문이다. <br>
이는 당연히 공간적인 비효율을 초래한다. 이러한 비효율을 막기 위해 유저를 기준으로 리스트를 만들던가, 파일을 기준으로 리스트를 만들 수 있다. <br>
유저를 기준으로 권한이 있는 파일을 정리한 것을, `Access Control List`라고 부르고, 파일을 기준으로 접근 권한을 가진 유저를 정리한 것을 `Capability List`라고 부른다. <br>

### 4.2 Grouping
그러나, 그럼에도 메모리 비효율이 아직 있기 때문에 차라리 '권한' 그룹을 만드는 방법이 제시됐다. <br>
전체 유저를 owner, group, public의 세 그룹으로 구분한다. 각각 파일의 소유자, 같은 그룹에 속한 유저, 그 외의 유저를 의미하는데, 한 줄에 접근 권한 정보를 3비트씩 표시해버린다.
```
rwxr--r--
(owner/group/other)
```
위와 같이 앞의 3비트 `rwx`는 소유자는 읽고, 쓰고,  실행할 수 있다는 의미이고, 같은 그룹과 다른 그룹 유저는 읽기만 할 수 있다는 의미이다. <br>
UNIX에서 부터 이런 방식을 사용해왔다.

### 4.3 Password
모든 파일에 비밀번호를 두는 방법도 제안되었는데, 매 접근마다 시간도 소요되고, 권한별로 비밀번호를 암기해야하는 등 많은 관리 문제가 있었다.

## 5. Mounting
서로 다른 파티션에 저장된 정보에는 어떻게 접근할까? Disk 1의 어떤 파일 `F`에 접근하려 했는데, 그 파일의 정보들이 Disk 3에 있는 경우, Mounting연산을 통해 Disk 3의 루트 디렉토리에 접근할 수 있다. Disk 3에서는 `F`가 루트 파일이 된다.

## 6. Access Method
1. `순차 접근`: sequential access는 옛날 카세트 테이프나 비디오에서나 썼던 방식으로, 읽거나 쓰는 경우 offset이 자동적으로 증가한다. `A-B-C`와 같이 파일이 배치되어 있을 때, `C`를 읽고 싶으면, `A-B`를 강제로 읽어줘야 한다. 우리가 자주 사용하는 유형은 아니다.
2. `직접 접근`: direct access, random access라고 부른다. 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있다. 우리가 사용하는 저장장치들은 대게 이런 유형으로 되어 있다.


## Reference
- 반효경 교수님 OS 수업 <Kocw, 이화여자대학교>
