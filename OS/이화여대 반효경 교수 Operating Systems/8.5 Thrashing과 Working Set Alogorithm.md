# 8.5 Thrashing과 Working Set Alogorithm
## 5.1 스레싱
프로세스가 제대로 돌아가려면, 일정 수준 이상의 페이지 프레임을 할당 받아야한다. <Br>
긴 반복문을 생각해보자. 여러 페이지 프레임에 나뉘어 긴 반복문이 돌아가는데, 만약에 반복문 전체가 메모리에 한번에 올라가지 못 하는 상황이라면? <br>
수 없이 많은 Page Fault를 겪게 될 것이다. 스왑 아웃 스왑 인은 안 그래도 오버헤드가 큰데, 잦은 Fault는 프로세스 성능에 얼마나 큰 영향을 미칠지 상상할 수 있을 것이다. <br> <br>

집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못해 `페이지 부재율`이 크게 상승해 `CPU 이용률`이 떨어진 현상을 `스레싱(thrashing)` 이라고 한다. <br>

### Multi-Programming Degree
메모리에 동시에 올라가 있는 프로세스의 수를 **다중 프로그래밍 정도 MPD라고 부른다.** <br>

어떤 상황에서 CPU의 이용율이 낮을까? 현재 메모리에 동시에 올라와 있는 프로세스의 수가 너무 적어서 전부 Blocked State에 가 있으면 준비 큐는 비게 된다. <br>
이런 경우 CPU는 놀게되고, MPD를 올리게 된다. <br>


그런데, MPD가 너무 높으면 끔찍한 일이 벌어진다. <Br> 

MPD가 높은 상황에서 각 프로세스마다 할당되는 메모리 양이 적어질 수 밖에 없다. <br>
아무래도 계속해서 Page Fault가 발생할 것이고, 부재 발생시 새로운 페이지를 가져오는 작업은 I/O에 해당하기 때문에, 또다시 많은 페이지들이 Blocked State로 갈 것이다. <Br>
문제는 대부분의 프로세스들이 Blocked로 가면서 또 **CPU이용률이 적어지고, OS는 이 상황을 MPD가 적어서라고 잘못 판단할 수 있다는 것이다.** <br>
이제 지옥의 시작이다. OS는 MPD를 계속 올릴 것이다. 그러면 각 프로세스별 메모리 할당은 계속 작아질 것이다. <br>

**이런 상황을 바로 Thrashing이라고 부르는 것이다.**

![스레싱](https://user-images.githubusercontent.com/71186266/212529270-8a94fdb0-2521-4cd0-adea-dcf1d71fba94.jpg)


<br>

결국 스레싱이 발생하지 않으면서도 CPU의 이용률을 높힐 수 있도록 아주 적절하게 MPD를 조절하는 것이 중요하다! <br>
스레싱 발생을 방지하는 방법에는 Working-set Algoritm과 Page-fault frequency scheme가 있다.

## 5.2 Working-Set Algoritm
프로세는 일정 시간 동안 특정 주소 영역을 집중적으로 참조하는 경향이 있다. <br>
쉽게 말하자면, 일정 시간 동안 쓰던 곳만 계속 쓴다는 것이다. <br>
공구를 생각해보자. 사다리에 오르기 전에 작업복에 몇 개의 공구만 담을 수 있다면, 당장 자주 쓰이는 것만 들고 올라갓 것이다. <br>
Working-Set 알고리즘은 이런 방식으로 동작한다. **프로세스가 일정 시간 동안 원활히 수행되기 위해, 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합을 워킹셋이라고 정의한다.** <Br>
그리고, 이 <U>**워킹셋을 한꺼번에 메모리에 올릴 수 있는 경우에만 해당 프로세스에게 메모리를 할당해준다.**</U> <br>
그게 안 되는 경우에는 잔혹하게 **프로세스에게 할당된 페이지 프레임들을 모두 반납시킨 후 그 프로세스의 주소공간 전체를 디스크로 스왑아웃 시킨다.** <br>

### Working-set Window
워킹셋 윈도우는 슬라이딩 윈도우 개념과 같이 어떤 **범위를 나타내는 용어이다.** <br>
윈도우의 크기를 W, 시각 t에서의 워킹셋을 WS(t)라고 할 때, 
```
WS(t) = [t - W, t] 사이에 참조된 서로 다른 페이지들의 집합
```
시간이 흘러 범위에서 벗어난 페이지는 메모리에서 쫒겨나게 되는 것이다. 그러니까 페이지가 참조된 시점부터 W시간 동안은 메모리에 유지되고, 그 시점이 지나면 메모리에서 지워지게 되는 것이다. <br>

### 워킹 셋이 MPD를 조절하는 방식
메모리에 올라와있는 프로세스들의 워킹셋 크기의 합이 프레임 수보다 클 경우, 전부 메모리에 올라갈 수는 없을 것이다. 이 때 워킹셋 알고리즘은 일부 프로세스를 스왑 아웃 시켜, 나머지 프로세스들의 워킹셋이 메모리에 모두 올라가는 것을 보장시킨다. **이는 MPD를 줄이는 효과를 발생시킨다.** <br>
그리고 프로세스들의 워킹셋을 모두 할당하고도 프레임이 남는다면? 반대로 스왑-아웃되었던 프로세스들을 다시 메모리에 올려서 워킹셋을 할당해준다. **이는 MPD를 증가시키는 행위와 동일하다.** <br>
이런 식으로 워킹셋 알고리즘은 CPU 이용률을 높게 유지하면서도 MPD를 적절히 조절해 스레싱을 방지한다. <br> <br>

**윈도우의 크기가** 너무 작으면 지역성 집합을 모두 수용하지 못할 수도 있다. <br> 
그리고 너무 크면 MPD가 감소해 CPU이용률이 적어질 수도 있다. 적당한 크기의 공구함이 필요하다는 것이다. <br>

그때 그때 상황에 맞게 워킹셋의 크기를 조절해가면서 운용하는데, 프로세스가 메모리를 많이 필요로 할때는 많이 주고, 필요 없을 때는 적게 준다. <br>
일종의 동적인 프레임 할당 기능까지 수행한다.

## 5.3 페이지 부재 빈도 알고리즘
Page Fault Frequency 알고리즘은 PFF라고도 부르는데, 프로세스의 페이지 부재율을 주기적으로 조사해서 각 프로세스에 할당할 메모리양을 동적으로 조절하는 알고리즘이다. <br>
일종의 할당 메모리양의 상한과 하한을 정해 두고, 해당 지점을 터치하면 동적으로 더 할당해주거나, 빼앗는 알고리즘이다. <Br>
페이지 부재 빈도 알고리즘에서는 이런식으로 메모리 내에 존재하는 모든 프로세스들에게 필요한 프레임을 다 할당해준 뒤에도 만약에 프레임이 남는다면, 스왑 아웃 해두었던 프로세스들에게 프래임을 나누어준다! <br>
페이지 부재 빈도 알고리즘은 이렇게 MPD를 조절하며 CPU의 이용률을 높하고, 스레싱을 방지한다. 

## Reference
- 운영체제와 정보기술의 원리 <반효경 저>
