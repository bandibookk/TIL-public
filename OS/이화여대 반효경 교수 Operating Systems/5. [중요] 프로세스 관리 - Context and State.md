# 5. 프로세스 관리
## 1. Process와 Process Context
**Process is program in execution!** 프로세스란, 실행 중인 프로그램을 뜻한다. <br>
디스크에 실행 파일의 형태로 저장된 프로그램은 메모리에 올라가서 실행되면서 비로소 생명력을 갖는 **프로세스가 된다.** <br>

**프로세스 개념을 이해하기 위해선, 프로세스의 Context 개념을 이해해야 한다** 어떤 문장 구조 속에서 단어의 의미를 파악하기 위해선 그 문맥을 파악해야 한다.

프로세스 또한 마찬가지이다. 우리는 프로세스의 어떤 한 시점을 관찰하게 되는데, 프로세스의 문맥이란 현재 시점에서의 CPU 수행 상태를 나타내는 하드웨어 문맥을 의미한다. <Br>

프로세스의 시작 부터 종료까지 CPU에서 한번에 명령을 수행하면 참 아름답겠지만, 여러 프로세스가 함께 수행되는 시분할 시스템 환경에서는 프로세스는 CPU를 짧은 시간동안만 점유할 수 있다. 이러한 점유 시간은 타이머 인터럽트에 의해 관리된다. 타이머 프로세스에 의해 CPU를 빼앗겼다가, 추후 다시 획득하는 식으로 CPU 관리가 이루어진다. <br>

이렇게 CPU를 빼앗겼다가 다시 돌려 받을 때, 이전에 프로세스가 가지고 있던 상태를 정확히 알고 있어야만 제대로 된 복구가 될 것이다. <br>
**정확한 재현을 위해 필요한 정보가 바로 프로세스의 문맥이다.** <br> 
프로세스의 문맥은 해당 프로세스의 PC가 어떤 프로세스의 주소 공간을 가리키고 있는지, stack 영역에는 어떤 내용들이 쌓여 있는지, 레지스터엔 어떤 값들이 존재하는지 등등의 **현재 상황을 규명하기 위한 다양한 정보들이 Context이다** <br>

Process의 Context는 3가지로 분류할 수 있다.
1. 하드웨어 문맥: CPU의 수행 상태 - PC, Register 등..
2. 프로세스 주소 공간: cose-data-stack으로 구성된 주소 공간의 상태. 프로세스 관리를 위한 자료구조 PCB 존재
3. 커널상 문맥

## 2. Process State
프로세스는 Running, Ready, Blocked의 3가지 State를 가지고 있다. blocked state는 wait, sleep 등으로도 불린다. <br>
**실행 상태는** 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태이다. 우리 눈에는 여러 프로그램이 수행되는 것으로 보이지만, **실제로 Running State에 있는 프로세스는 매 순간 하나뿐이다.** <br>
**준비 상태는** CPU를 할당 받지 못 해서 기다리고 있는 state이다. Blocked 상태와 달리 언제라도 CPU를 할당 받으면 명령을 실행할 수 있다. <br>
**봉쇄 상태는** CPU를 할당 받더라도 당장 명령 실행이 불가능한 상태로, 프로세스가 요청한 I/O 작업이 진행중인 경우를 예로 들 수 있다. <br>
하나의 프로세스는 항상 하나의 상태에 머물러 있고, 이는 시간의 흐름에 따라 변하게 된다. 이런 State의 구분으로 컴퓨터 자원이 효율적으로 관리될 수 있었다. <br>

## Context Switch와 CPU Dispatch
실행시킬 Process를 변경하기 위해, 원래 수행중이던 Process의 Context를 저장하고, 새로운 Process의 Context를 세팅하는 과정을 **Context Switch라고 부른다.** <br>
ex) Running State에서 프로세스가 실행되는 중 타이머 인터럽트 발생으로 CPU 제어권이 OS로 이양된 상황.
1. OS는 타이머 인터럽트 처리루틴으로 가서 수행중이던 Process의 Context를 저장한다.
2. Ready State에 있는 프로세스 중에서 새롭게 CPU의 제어권을 부여할 프로세스를 선택한다.
3. Running State였던 Process는 Ready State가 되고, 새롭게 CPU를 할당 받은 Process가 Running State가 된다.

Context Switch는 Timer Interrupt 발생 외에도 I/O 요청 등으로 Running State에 있던 Process가 Blocked State로 바뀌는 경우에도 일어날 수 있다. <Br>
이 때, Ready State에 있는 프로레스들 중에서 하나가 선택되어 CPU를 할당 받고, 제어권을 넘겨 받는 과정을 **CPU Dispatch라고 부른다.**

## 프로세스 State 변화 예시 :star:
1. Running State Process가 기계어 명령을 수행하고 있다. 디스크에서 파일의 내용을 읽어와야 하는 명령을 만났는데, 읽어온 결과가 있어야 다음 진행이 가능한 상황! <br> **I/O 작업은 CPU의 처리 속도에 비해 너무나도 느리므로, 해당 프로세스를 Blocked State로 바꾸어 준다.**
2. **Ready Stated Process중 적당한 것을 골라 Running으로 올려주고, 명령들을 수행한다.** <br> Ready State인 프로세스들은 언제든지 CPU만 획득하면 곧바로 명령 수행이 가능하도록 대기중이었다.
3. I/O를 요청한 프로세스는 <U>디스크 입출력을 기다리는 큐</U>에 줄 서 있다가, 자기 차례가 되면 **Disk Controller에게서 서비스를 받을 수 있다. 즉, 마그네틱 매체에서 원하는 데이터를 로컬 버퍼로 읽어올 수 있다.**
4. **입출력이 완료되면, Disk Controller는 CPU에게 입출력이 완료 되었다는 Interrupt를 발생시킨다.** 
5. CPU는 인터럽트가 발생한 것을 확인하고 대응하는 루틴을 수행하는데, **루틴이 진행되는 동안 CPU에서 수행되던 프로세스의 상태는 사용자모드 실행 상태에서 Kernel 모드 실행 상태로 바뀐다.** <br> 좀 특이하다. 프로세스가 실행하던 중에 인터럽트가 발생하면, 인터럽트가 발생한 원인과 무관한 프로세스가 돌고 있더라도, 인터럽트를 당한 프로세스가 User Mode에서 Kernel Mode로 진입한 것으로 간주하게 된다. 
6. **디스크 컨트롤러가 발생시킨 인터럽트는 입출력이 완료된 프로세스의 상태를 Blocked State에서 Ready State로 바꾼 후, 장치의 Local Buffer에 있는 내용을 메모리로 이동시킨다.**
7. 인터럽트 처리까지 모두 끝나면, Ready State에 있는 I/O 요청 Process에게 다시 CPU를 할당해준다. (경우에 따라 다른 프로세스가 수행될 수 있지만, 일반적인 경우는 아님.)

<!-- Quiz: block에서 running 바로 가나? -->
