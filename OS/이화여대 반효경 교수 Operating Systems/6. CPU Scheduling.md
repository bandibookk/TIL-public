# 6. CPU 스케줄링

CPU는 프로그램의 기계어 명령을 **실제로 수행하는** 컴퓨터 내의 중앙처리장치이다. PC는 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있고, CPU는 PC가 가리키는 주소의 명령을 하나씩 수행한다. <br>
CPU는 보통 하나의 시스템 내에 하나 밖에 없다. 시스템에게 있어 CPU는 마치 인간의 중추와 같다. 여러 프로그램이 동시에 수행되는 시분할 환경에서 이런 CPU 자원이 얼마나 효율적으로 관리되어야 하는지 가늠이 가는가? <br>
**이 장에서는 그런 CPU의 스케줄링에 대해 다룬다.** <br>

## 0. I/O bound Process
스케줄링의 이해에 앞서, 기본적으로 기계어 명령어들의 특성과, 수행되는 명령어들로 인한 프로세스의 구분을 알아폴 필요가 있다. <br>

기계어 명령어는 크게 `CPU에서 수행되는 명령`, `메모리 접근을 필요로 하는 명령`, `입출력을 동반하는 명령`으로 나누어 볼 수 있다. <Br>
이런 구분은 자연스럽다. CPU 혼자 수행 할 수 있는 작업, 메모리까지 동원되어야 하는 작업, 외부 장치의 I/O를 요구하는 작업으로 나뉘는 것은 자연스럽게 느껴진다. <br>

당연히 3명령어가 순서대로 속도가 빠르다. 여기서 ADD 명령어와 같은 CPU 수행 명령, STORE, LOAD와 같은 메모리 접근 명령은 **사용자 프로그램이 직접 수행행할 수 있는 일반 명령에 해당한다.** CPU가 명령을 **컴퓨터 내부에서만** 처리하므로 받아들일 수 있다. <br>
반대로, **컴퓨터의 외부 장치에 접근해야하는 I/O 명령은 시스템에 의해 특권명령으로 규정된다.** 따라서 사용자 프로그램이 **직접 수행할 수 없고, OS를 통해서만 서비스를 대행할 수 있다.** 프로그램이 수행되던 중 I/O를 요청하면 CPU 제어권은 OS Kernel로 넘어가고, 느린 입출력 장치의 점근이 수행된다. <br>

### Burst
결국 사용자 프로그램은 이런 CPU와 I/O 장치라는 두 개의 상이한 자원을 사용하는 사이클로 볼 수 있다. <br> 
**프로그램이 CPU를 직접 가지고 명령을 수행하는 단계를 CPU Burst, I/O 요청에 의해 Kernel에 의한 입출력 잡업을 진행하는 단계를 I/O Burst라고 부른다.** 이런 두 단계의 조합이 프로그램의 수행의 정체이다. <br>

대부분의 프로그램은 수 많은 I/O를 요구한다. 우리가 게임을 할 때는 끊임없이 키보드 마우스를 두들기고, 모니터에선 화면이 스피커에선 소리가 나온다. 우리는 게임을 하면이 이런 입력 출력이 당연히 바로 바로 반영되길 기대한다. <br>
이런 interaction이 계속되는 프로그램은 대화형 프로그램(interactive program)에 해당된다. 이렇게 **I/O Burst가 빈번하고, CPU Burst가 매우 짧게 나타나는 프로세스를 I/O Bound Process라고 부른다.**  <br>
반대로 I/O를 거의 하지 않고, CPU Burst만 길게 나타나는 프로세스를 **CPU Bound Process라고 한다.** 이런 프로세스들은 사용자 입출력을 받기 보다는 계산 위주로 작동하는 프로그램이 되겠다. <br>

### I/O bound Process
이렇게 상이한 패턴을 가진 여러 프로세스들을 한 시스템 내부에서 실행시키려니.. 효율적인 스케줄링이 당연히 필요하다. <br>

대부분의 경우 컴퓨터 시스템 내의 프로세스들은 짧은 CPU 버스트를 가지고 있다. CPU를 한번에 오래 사용하기 보다는 잠깐 잠깐씩 사용하고, 대부분은 I/O를 수행하는 프로세스들이 주를 이룬다는 것이다. 서비스 하는 입장에서, 이런 입출력이 느리다면 고객들은 참지 않긔. 컴퓨터가 조금만 느려져도 노트북을 반대로 접어버리고 싶은 고객들이 대부분일 것이다. <br> 
따라서, **CPU 스케줄링시 CPU 버스트가 짧은 I/O 바운드 프로세스의 우선순위를 높게 잡아줘야 한다!** <br>
CPU Bound Process한테 우선순위를 높게 줘 버린다면, 우리는 긴 CPU 연산시간을 I/O 장치를 휴면 상태로 두고 넋 놓고 기다리고 있어야한다. <br>

## 1. CPU 스케줄러
CPU 스케줄러는 코드이다. Ready State 있는 Process들 중에 어떤 프로세스에게 CPU를 할당할지 결정하는 OS의 코드를 CPU Scheduler라고 부른다. <br> 
프로세스가 명령을 수행하던 중 타이머 인터럽트가 발생한다면, CPU 스케줄러가 호출된다. 작업을 잘 하고 있다가, 나에게 주어진 CPU 사용 시간이 끝나버렸으니 이제 쫒겨날 것이고, 다음에 누가 사용 할 지는 스케줄러가 정해주는 것이다. <br>

이런 CPU 스케줄링 방식에는 nonpreemptive 방식과 preemptive 방식이 있다. **비선점형 방식은 CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방식이다.** 다른 프로세스가 감히 내가 사용중인 CPU를 선점할 수 없기에, 비선점형 프로세스라고 불리운다. <br>
반대로 선점형 프로세스는 프로세스가 CPU를 계속 사용하고 싶어도 강제로 빼앗을 수 있다. 보통 time quantum을 부여한 다음(할당 시간) 타이머 인터럽트를 발생시키는 방식으로 빼앗는다. <br>

### nonpreemptive 스케줄링
비선점형 스케줄링 예시
1. **Running State Process가 I/O 요청 등으로 인해 Blocked State로 바뀌는 경우**
2. Running State Process가 종료되는 경우


위의 중지되거나 종료되는 두 경우는 비선점형이다. <br>


선점형 스케줄링 예시
1. **Running State Process가 Timer Interrupt 발생에 의해 Ready State로 변경된다.**
2. **I/O 요청으로 Blocked State에 있던 Process의 작업이 완료되어 Interrupt가 발생되고, Process가 Ready State로 바뀌게 되는 경우**

위의 Ready State로 가는 두 경우는 선점형이다. <br>
두 스케줄링에 쓰이는 알고리즘들은 다양하다. 이는 `6.4 스케줄링 알고리즘` 단원에서 확인할 것이다. <br>

## 2. Dispatcher
Dispatcher는 신데렐라 요정 할머니나, 수리남이나 내부자들의 조우진 배우 같은 역할을 한다. 스케줄러님께서 고심하셔서 다음 CPU 할당의 은총을 받게 될 프로세스를 결정하면, **디스페처가 선택된 프로세스에게 실제로 CPU를 이양한다** <br>
**디스패처는 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 해주는 OS의 코드이다.** <br>
1. **현재 수행중이던 Process의 Context를 해당 프로세스의 PCB에 저장한다.** (저 사람 끌어내!)
2. **이후 새롭게 선택된 프로세스의 Context를 PCB로 부터 복원한 다음, 해당 프로세스에게 CPU를 넘겨준다.** (다음 작업자를 앉힌다)
3. 이후, 시스템의 상태를 사용자모드로 전환해 **사용자 프로그램에게 CPU의 제어권을 넘겨준다.**
4. 이후 사용자 프로그램은 평화롭게 복원된 Context 중의 **PC로 부터 현재 수행할 수소를 찾을 수 있게 되는 것이다.** 


### Dispatch latency
디스패처가 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패지 지연시간이라고 부른다. <br>
대부분의 시간은 Context Switch가 차지한다.

## Reference
- 운영체제와 정보기술의 원리 <반효경 저>  
