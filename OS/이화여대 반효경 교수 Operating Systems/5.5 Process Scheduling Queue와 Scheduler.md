# 5.5 Process Scheduling Queue
프로세스를 스케줄링 하기 위한 큐.. <br>
OS는 여려 Queue를 운용한다. <br>
Ready State에서 CPU를 기다리기 위한 Ready Queue, <br>
Device를 기다리기 위한 Device Queue가 있고, 공유 데이터의 사용을 기다리기 위한 Software 데이터 큐가 있고 (따로 이름은 없는 듯) **시스템 내의 모든 Process들을 관리하기 위한 작업 큐 - Job Queue가 존재한다.** <Br>
**이들 프로세스를 위한 Queue는 PCB의 연결리스트로 구성되어 있다.** 포인터를 사용해 순서를 정하며, 가장 앞 부분은 Queue Header라고 부른다. <Br>

## 5.1 Ready Queue - 프로세스용
**Ready State 안의 프로세스들은 Ready Queue에 줄 세워져 있다.** 해당 큐에 줄 세워진 순서는 **CPU Scheduling 방식에 따라 다르게 정렬 되어 있다** 이대로 바로 가장 앞의 프로세스가 다음 Running State가 될 Process로 결정된다. <br>

## 5.2 Device Queue - 하드웨어 Resource
이런 Ready Queue 외에도 OS는 특정 **하드웨어 자원들을** 기다리는 프로세스들을 줄 세우기 위해 **자원별로 Device Queue를 둔다.** <br>
예를 들어 Disk에 I/O 서비스를 요청한 Process들은 Disk I/O Queue에 Keyboard 입력을 받아야 하는 경우에는 keyboard I/O Queue에 줄을 서게 되는 것이다. (I/O이기 때문에 대게 Blocked State)

## 5.3 Software Resource용 Queue
이런 Queue들은 Software의 공유 데이터에 접근할 때도 필요하다 <br>
**데이터 일관성을** 위해 공유 데이터에 대한 접근 권한은 Software Resource로 분류되어 관리된다. 공유 데이터는 매 시점 하나의 Process만이 접근 가능해야 한다. <br>
이 떄, 한가지 주의해야 하는 점이 있다. <Br>
**현재 CPU가 사용하지 않는 데이터도 보호가 필요할 수 있다.** 왜냐하면 꼭 Running State에 있는 Process가 아니더라도, 현재 Ready State나 Blocked State에 있는 Process에서 사용중인 데이터를 변경하게 된다면! 똑같이 **일관성이 깨질 수도 있다.** <Br>
따라서, `공유 데이터`라는 Software Resource는 접근 중인 프로세스가 반납할 때까지는 다른 Process가 접근할 수 없게 해야한다. <U>**큐에 줄을 서게 만들면서 말이다!**</U> <br>


## 5.4 Job Queue
앞서 이야기한 준비 큐와 장치 큐 외에 추가적으로 **시스템 내의 모든 Process를 관리하기 위한 Queue인 Job Queue가 존재한다.** <br>
Job Queue에는 프로세스의 **상태와 무관하게** 현재 시스템에 속한 모든 프로세스가 속하기 때문에, **작업 큐에 있다고 해서 반드시 메모리를 가진 것은 아니다.**
장치 큐에 있는 프로세스들은 Blocked State에 있기 때문이다. <br>
프로세스는 상태에 따라 준비 큐와 장치 큐를 오가며 실행된다. <Br>
**작업 큐가 가장 넓은 개념이고, 준비 큐와 장치 큐에 있는 프로세스들을 모두 작업 큐에 속한다.** <br> <br>
 
# 5.6 Scheduler
**Scheduler는 Code이다.** <br>
어떤 프로세스에게 자원을 할당할지 결정하는 OS Kernel의 코드를 지칭한다! <br>
크게 Long Term Scheduler, Short Term Scheduler으로 나뉘고, 최근에는 장기 스케줄러가 거의 쓰이지 않고, Medium term scheduler가 쓰인다고 한다. <br>
기본적으로 장기 스케줄러는 막 만들어진 프로세스의 준비 큐 삽입 여부를 결정한다.

## 6.1 단기 스케줄러
단기 스케줄러야 말로 중요한데, <br>
**단기 스케줄러는 Ready State의 Process들 중에서 어떤 프로세스를 다음 번에 Running State로 만들것인지 결정한다.** 다시 말하면, 준비 큐에 있는 프로세스들 중 **누가 먼저 CPU를 할당 받을지 결정하는 중요한 역할!** <br>
그래서 **단기 스케줄러는 CPU 스케줄러라고도 부른다.** <br>
시분할 시스템에서 타이머 인터럽트가 발생하면, 이 단기 스케줄러가 호출되는 것이다. <br>
단기 스케줄러는 호출이 잦을 수 밖에 없다. 밀리초 정도의 시간 단위로 매우 빈번한 호출이 있으므로, **수행 속도가 충분히 빨라야 한다.** 그냥저냥 수십초나 분 단위로 호출되는 장기 스케줄러와는 조금 느려도 된다. <br>

## 6.2 장기 스케줄러
장기 스케줄러는 막 만들어진 프로세스가 준비 큐에 삽입될건지 결정하는데, 메모리에 동시에 올라가 있는 프로세스의 수를 조절한다. <br>
시작 상태의 프로세스에게 메모리가 할당될지를 결정하는데, 풀어서 말 하자면 그냥 **새로 킨 프로그램이 돌아갈지 말지를 결정하는 것이다.** 이미 많은 프로세스가 진행 중이여서, **각 프로세스가 받게 되는 메모리가 지나치게 적은 경우 시스템 효율이 떨어지게 된다면, 이를 조절하는 역할을 한다.** <Br>

자원이 풍부하게 된 현대 시분할 시스템 OS에서는 잘 사용되지 않는다고 한다. **현대 시스템에서는 장기 스케줄러 없이 곧바로 프로세스에 메모리가 할당되고 준비 큐에 올라가게 된다.**

## 6.3 중기 스케줄러..
대신에 현대의 시분할 시스템 OS에서는 중기 스케줄러를 두는 경우가 많다고 한다. <br>
중기 스케줄러 또한 많은 프로세스에 메모리가 할당된 상태를 해소하기 위해 추가된 스케줄러이다. <br>
메모리에 당장 CPU 수행에 필요한 프로세스의 주소 공간조차도 올려 놓기 힘들 정도로 너무 많은 프로세스가 올라가 있는 경우, **디스크 입출력이 수시로 발생해 시스템 성능이 저하될 수 있다..** <br> 
이런 상황에서 중기 스케줄러는 메모리에 올라와 있는 프로세스들 중 Blocked State인 프로세스들을 우선적으로 **Swap Out한다.** 스왑 아웃은 메모리에 올라와 있는 프로세스의 내용을 Disk의 스왑 영역에 저장하는 행위이다. 어차피 Blocked State인 프로세스들은 당장 CPU를 획득할 가능성이 없으므로 메모리에 있어봐야 큰 의미가 없고, 중기 스케줄러의 0순위 타겟인 것이 자연스럽다. <br> 

### Suspended State - stopped state
중기 스케줄러로 인해 추가된 State이다. <br>
외부에서 재개되지 않는 이상 다시 활성화될 수 없는 스왑 아웃 상태이다. <Br>
Ready State에서 왔다면, Suspended Ready State, Blocked State에서 왔다면, Suspended Blocked State이다. 

## Reference
- 운영체제와 정보기술의 원리 <반효경 저>  
