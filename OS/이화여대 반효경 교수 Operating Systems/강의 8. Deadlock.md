# DeadLock
Deadlock은 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 가리킨다. <br>
한 프로세스는 A를 B에 집어 넣고 싶고, 다른 한 프로세스는 B에 A를 집어 넣고 싶다. 결국 필요한 자원은 똑같다. <br>
한 프로세스는 A를 먼저 들었고 다른 프로세스는 B를 먼저 들었다면? <br>
둘은 서로에게 양보를 강요하며 서로의 자원을 내어놓지 않을 것이다. <Br>
그러면 두 프로세스는 하염없이 서로가 내려놓을 것을 기다리고 있게 되는 것이다! <br>
이런 자원의 대상은 하드웨어, 소프트워어 등 그 무엇이라도 될 수 있다.

## 1. Deadlock 발생의 4가지 조건
1. `Mutual Exclusion`: 상호배제. 매 순간 하나의 프로세스만이 자원 사용 가능
2. `No Preemption`: 비선점형. 강제로 자원을 빼앗기지 않는 프로세스
3. `Hold and Wait`: 보유 대기. 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유한 자원을 내려 놓지 않음!
4. `Circular Wait`: 순환 대기. 자원을 기다리는 프로세스간를 그려낸 Resource-Allocation Graph에서 사이클이 형성된 상황


이런 4가지 요소들이 있을 때 Deadlock이 발생할 수도 있다.

## 2. DeadLock의 처리 방법
DeadLock을 처리하는 방법으로는 4가지가 있다.
1. `DeadLock Prevention`: 데드락 자체를 막는 것이다. 데드락의 4가지 필요 조건 중 어느 하나를 만족하지 못 하게 막는다!
2. `DeadLock Avoidance`: 데드락을 피하는 것이다. 부가 정보를 활용해 Deadlock이 없을 때만 자원을 할당한다. 혹은 시스템 state가 원래 state로 돌아올 수 있는 경우에만 할당해준다. 
3. `Deadlock Detection and Recovery`: 자원을 요구하는 대로 다 할당해준다. 대신 Deadlock 상황시 복구 대책을 마련 해둔다.
4. `Deadlock Ignorance`: 데드락을 무시하는 것이다. **UNIX나 대부분의 OS가 채택함!** 사람이 알아서 느려지거나 하면 프로세스들을 끄게 한다. 결국 Deadlock은 빈번히 발생하는 문제가 아니므로 그냥 무시하는 것이다.

## 3. DeadLock Prevention
가장 강력한 방법 중 하나이다! 4가지 방법들을 살펴보면서 각 요소들을 막는 방법을 확인해보자. <br>

4가지 방법 중 `Mutual Exclusion`은 애초에 막을 수 있는 방법이 아니다. 꼭 필요하기도 하기 때문에 배제할 수 없다.. <br>

`Hold And Wait` 상황을 피하기 위해선 두 가지 방법을 생각해볼 수 있다.
1. 프로세스 시작시 모든 필요 자원을 할당 받게 한다! -> 당연히 엄청난 비효율이다. 달란대로 전부 주다니..
2. 자원이 필요할 경우 보유 자원을 모두 놓고 요청 -> 유효하다!

<br>

CPU나 Memory는 여러 자료구조들의 도움으로 중간에 흐름이 끊겼다가 다시 이어져도 이전 상태를 이어나가기가 편리했다. <br>
하지만 모든 자원들이 그렇게 될 수 있는 것은 아니다. <br> 
따라서 State를 쉽게 save하고 restore할 수 있는 자원들만 `비선점형`을 선점형으로 바꿔 주고, 나머지는 그대로 `No Preemption` 상태로 두어야 한다. <br>


`Circular Wait` 상황을 막으려면 자원들에 순서를 정해주면 된다. 아까 위에서 A, B 자원 중 서로 다른 것을 먼저 잡아서 문제가 됐었다! <br>
이에 **여러 자원이 필요한 경우, 순서를 정해서 자원을 얻도록 정해주는 것이다!** 예를 들어 **무조건 A -> B 순서로만 들 수 있게 하는 것이다!** <br>
좋은 방식이지만, Utilization이 저하되고, Throughput이 감소하고 Starvation 문제가 발생할 수 있다. <Br>
즉, 전부 순서가 정해져있으니 효율이 너무 떨어진다는 것이다..

## 4. DeadLock Avoidance
Deadlock 자체를 미리 방지한다! <br>
자원에 대한 인스턴스가 하나인 경우, Resource Allocation Graph를 그려본다. <br>
자원과 프로세스들을 노드로 나타내어, 프로세스가 자원을 요청할 경우 화살표로 이은다. <br>
그리고 평생에 한번이라도 요청할 **가능성이** 있다면 점선으로 긋는다. 언젠간 호출할 수도 있다는 것이고, 실제로 요청할 경우에만 실선으로 바뀐다. <br>
이를 Claim edge라고 부른다. <br>
**DeadLock Avoidance에서는 최악의 상황을 상정한다.**
만약 점선이 포함된 사이클이 형성되는 경우, deadlock의 위험이 있기 때문에 할당해주지 않는다. <br>

꽤나 비효율적인 방식이다. Cycle 생성 여뷰 확인시 무려 O(N)의 시간이 소요된다. <br>

이런 방식도 자원 인스턴스가 하나일 때나 가능하다. 여러개인 경우 뱅커스 알고리즘을 도입해야 한다!


## 5. Banker's Algorithm - DeadLock Avoidance
어떤 프로세스들이 자원 요청을 했을 때, 최대 할당을 고려해서 할당해 줄지 안 해줄지를 판단하는 알고리즘으로, <br>
**DeadLock을 해결하는 4가지 방법 중 DeadLock Avoidance에 속한다** <br>
1. 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하게 한다. 
2. 현재 남은 자원 양을 계속 체크한다
3. 비록 어떤 프로세스가 남은 양들 보다 적은 자원을 요구해도, <br> **해당 프로세스의 최대 사용량이 현재 남은 양보다 크다면, 할당해주지 않는다!** <br> 즉, **safe 상태를 유지할 경우에만 할당한다**

모든 프로세스는 요청 자원을 모두 할당 받은 경우 유한 시간 자원을 다시 반납한다. 그 덕분에 모든 프로세스들이 결국 자원을 할당 받을 수 있게 되는 것이다. 

### Safe State
프로세스들의 자원 할당 순서를 적절하게 조절해서 Banker's 알고리즘을 만족하면서 모든 프로세스들에게 할당해줄 수 있는 순서를 **safe sequence라고 하고,** 그러한 상태를 **safe state라고 한다.** <br>

어떤 순서 `P1, P2, P3, ... , Pn`이 있다고 하자. <br>
프로세스의 sequence가 safe하려면, 자원 요청이 `가용 자원 + 이전까지의 P들의 보유 자원`에 의해 충족 되어야 한다. <br>
조건을 만족한다면 safe하다. 어떤 Pi번째 자원 요청이 즉시 중족되지 않는다면, **이전까지의 모든 프로세스들의 종료를 기다린 다음, 자원요청을 만족 시켜 수행한다**  <br>

만약에 다른 정책이나 알고리즘으로, 가용 자원 보다 최대 요구가 높은 프로세스에게 자원을 할당 해줌으로서, 시스템이 unsafe state에 있다고 무조건 deadlock에 걸리는 것은 아니다. 그럴 가능성이 있는 것일 뿐. <br>
하지만 safe 상태는 아예 그럴 가능성을 없애기 때문에 DeadLock Avoidance방식은 참 좋다.


## 6. Deadlock Detection And Recovery
### Detection
데드락 감지의 경우 각 프로세스와 자원들을 표로 나타내어 찾아낼 수 있다. <br>
이미 할당된 자원, 요구 자원, 가용 자원들을 표로 나타내어 할당 하는 과정에서 감지한다. <br>
자원들이 1개씩만 있는 경우 각 프로세스와 자원을 그래프로 나타내어 dfs를 통해 사이클을 감지함으로써 찾아낼 수 있다. <br>
사이클이 있는 경우 deadlock이다.  <br>

### Recovery
복구라고 해서 꼭 진짜 복구는 아니다. 리커버리에는 두 가지 방법이 있다.
1. `Process Termination`: 데드락과 관련된 모든 프로세스를 죽여버린다. 데드락 사이클이 사라질 때까지 프로세스를 한번에 하나씩 사살한다
2. `Resource Preemption`: 비용을 최소화할 희생양 (victim)을 선정한다. <br> safe rollback하여 prcess를 restart한다! 한명만 희생하면 모두가 살 수 있잖아.. 한명만 죽인다..! <br> 대신 Starvation 문제가 발생할 수 있다! 계속해서 같은 프로세스가 희생양으로 선정되는 경우 굶어 죽을 수도 있다. <br> 따라서 희생양을 선정할 때 사용하는 cost factor에 rollback 횟수도 포함시킨다!

## Reference
- 운영체제와 정보기술의 원리 <반효경 저>  
