# 9. 디스크 관리
## 9.1 디스크의 구조
디스크는 마그네틱 원판들로 구성되어 있다. 하나의 디스크 내에 원판의 수는 하나일 수도, 여러개일 수도 있다. <br>

![디스크 구조](https://user-images.githubusercontent.com/71186266/212548388-bebfb5ce-18c5-4cf9-8b3b-9bd466278ea7.jpg)


하나의 원판은 여러 트랙으로 구성된다. 위의 그림과 같이 반지름에 따른 각 원들을 트랙이라고 부른다. 그리고 트랙은 여러 섹터로 나뉜다. <br>
여러 원판에서 상대적 위치가 동일한 트랙
디스크 외부에서 트랙은 1차원 배열처럼 취급된다. 
위의 그림을 보면 쉽게 이해가 갈텐데, 마치 원형으로 연결된 배열과 같이 취급한다. <br>
그리고 여러 원판들 사이에서 **상대적 위치가 동일한 트랙들의 결합을 실린더라고 부른다.** <br>
실린더는 최외곽 실린더를 0번 실린더로 넘버링하고, 중심 쪽으로 들어오면서 숫자가 커진다. <br>
데이터를 읽고 쓸 때는 **Arm이 해당 섹터가 위치한 실린더로 이동한 후, 원판이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달해야 한다.** <br>

### 논리 블록
디스크에 데이터를 다루는 기본 단위를 **논리블록이라고 부른다.** 데이터가 저장될 때에도, 전송될 때에도 이 논리블록 단위로 주고 받아진다. <Br>
각 논리블록들이 저장되는 물리적 위치가 바로 `섹터`인 것이다. 섹터 하나와 논리블록 하나는 1대 1로 매핑되어 저장된다.

## 9.2 디스크 스케줄링
디스크의 `Access Time`(접근 시간)은 3가지로 구분된다.
1. `Seek Time`: 탐색시간, 디스크의 헤드를 해당 실린더 위치로 이동시키는데 걸리는 시간. 회전축과 수직으로 이동하는 것.
2. `Rotational Latency`: 회전지연시간, 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치까지 도달하기까지 걸리는 시간.
3. `Transfer Time`: 전송시간, 해당 섹터가 헤드 위치까지 도달한 후, 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간.

이 세가지 시간이 합쳐져 접근 시간이 되는데, **회전지연시간과 전송시간은 탐색시간에 비해서는 짧고, 운영체제 입장에서 통제하기도 힘들다.** <br>
따라서 **성능 향상을 위해 시간을 줄이는 주요 타겟은 바로 `Seek Time`쪽이다.** <br>

운영체제는 탐색시간을 줄이기 위해, 헤드의 움직임을 최소화하는 스케줄링 작업을 하는데, 이를 **디스크 스케줄링이라고 부른다.** <Br>
디스크 스케줄링은 여러 섹터들의 입출력 요청이 들어왔을때, 처리 순서를 정하는 알고리즘이다! <Br>

**주요 목표는 디스크 헤드의 이동거리를 줄이는 것이다!**

### 1. FCFS 스케줄링
역시나 단골 등장하는 First Come First Served 스케줄링은 디스크에 요청이 들어온 순서대로 처리하는 방식이다. <Br>
당연히 효율성이라고는 눈꼽만큼도 없다! 만약에 디스크의 양쪽 끝 부분 입력이 계속해서 들어온다면? 미련하게 계속 먼 거리를 왔다 갔다 할 것이다. <br>
OS에 등장하는 대부분의 알고리즘에서 사용되는 방식이고, 항상 비효율적이다.

### 2. SSTF 스케줄링
`Shortest Seek Time First`, `SSTF` 스케줄링은 **헤드의 현재 위치로 부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘이다.** <br>

헤드의 이동거리를 확실히 줄여주기 때문에, FCFS보다는 효율이 좋다. <Br>
하지만 예를 들어 1번 200번 입출력이 요청된 다음 다음 2번 1번 입출력이 연속으로 계속해서 들어오게 된다면..? <Br>
서로 가까운 1번 2번을 계속 왕복할 것이고, 2등으로 요청된 200번은 영원히 기다리게 될 수도 있다.. <br>
**즉, Starvation 문제 발생의 가능성이 있기 때문에 우수한 알고리즘이라고 부르기엔 조금 무리가 있다.**

### 3. SCAN 알고리즘
일명 `엘레베이터 스케줄링 알고리즘`으로, 마치 엘레베이터와 같이, **일단 진행하던 방향으로 쭉 이동하면서 모든 요청을 처리하고, 디스크 맨 끝에서 반대쪽으로 쭉 이동한다.** 이렇게 양 끝을 왕복해서 처리하는 알고리즘이 `SCAN 알고리즘`이다. <br>

앞서 소개된 두 알고리즘 보다는 훨씬 낫다. FCFS처럼 불필요한 움직임도 없고, SSTF처럼 기아 문제도 없다. <br>
하지만, 모든 요청이 공평하게 처리되지 않는다는 문제가 있다. <br>
현재 순방향으로 나아가고 있을 때, 1등으로 가장 끝 번호 실린더의 입출력이 요청된다면? 그 실린더는 1등으로 요청했음에도 매우 오랜 시간을 기다려야 한다. 더 끔찍한 경우는 내가 이미 지나친 곳에 입력이 들어오는 경우 이러한 기다림은 더 길어진다. <Br>
애초에 더 문제가 되는것은 가운데에 비해 양쪽 끝은 항상 오래 기다려야 한다는 점이다. 

### 4. C-SCAN 알고리즘
그런 SCAN 알고리즘의 단점을 해소하려 노력한 것이ㅏ `Circular-SCAN` 알고리즘이다. <br>
왜 Circular냐면, 마치 원형 큐와 같이 예를 들어 0번 부터 199번 실린더를 모두 탐색한 이후, 다시 0번 부터 탐색해주기 위해 199번 부터 0번까지 아무런 입출력을 처리하지 않고 쭉~~~내달린다. <br>
**이런 방식은 SCAN보다 좀 더 균일한 탐색시간을 제공해준다. SCAN보다 헤드의 이동 시간은 당연히 더 길어지지만, 탐색시간의 편차를 줄여준다!**

### 5. LOOK, C-LOOK 알고리즘
SCAN 알고리즘의 비효율을 조금 줄여준다. <br>
SCAN은 요청이 있건 없건, 최외곽 실린더 부터 가장 안쪽 실린더까지 계속해서 왕복으로 움직이면서 입출력을 처리하는데, **LOOK은 입력이 없는 경우 더 나아가지 않고 돌아온다.** <br>
예를 들어 0 ~ 199 실린더가 있을 때, 순방향으로 나아가는 중이다. 그런데 해당 방향으로 177번까지만 입출력 요청이 있었다면, **굳이 199번가지 가지 않고, 177번까지만 찍고 다시 반대로 도는 것이다.** <br>
**진행 방향에 요청이 있는지를 살핀 후 이동하기 때문에 LOOK이라고 부르는 것이다.** <br>
C-LOOK은 마치 SCAN과 C-SCAN의 관계와 같이, 177번을 찍고 다시 176번으로 돌아오는 것이 아니라, 다시 맨 앞으로 달린다. <br>
예를 들어 0 ~ 14번에는 요청이 없고, 가장 숫자가 작은 요청이 15번 요청이라고 하자. **이때 C-LOOK에선, 시작지점도 LOOK이기 때문에 177번에서 0번으로 가지 않고, 15번까지만 쭉 내달린다.** <br>
설명들을 전부 읽어보면 알 수 있다 싶이, SCAN 시리즈가 개선된 LOOK과 C-LOOK과 같은 스케줄링 알고리즘들이 디스크 입출력이 많은 시스템에서 더욱 효율적인 것으로 알려져 있다.


## Reference
- 운영체제와 정보기술의 원리 <반효경 저>
