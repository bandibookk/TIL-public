# 스케줄링 알고리즘과 성능 평가
# 6.3 스케줄링 성능 평가
다양한 스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용된다. 이 지표들은 크게 시스템 관점의 지표와 이용자 관점의 지표로 나누어볼 수 있다.

1. `CPU Uilization`: **전체 시간 중 CPU가 일을 한 시간의 비율** CPU가 일을 하지 않는 idle 상태에 머무르는 시간을 최대한 줄이는 것은 스케줄링의 중요한 목표중 하나이므로, CPU 이용률은 높을 수록 좋다.
2. `throughput`: 처리량은 주어진 시간 동안 **Ready Queue에서 기다리는 프로세스 중 몇 개를 끝마쳤는지에 대한 지표이다. 즉, CPU 버스트을 완료한 프로세스의 갯수에 대한 지표이다.** 처리량을 늘리기 위해선 CPU 버스트가 짧은 프로세스가 우선적으로 CPU를 할당 받는 것이 유리하다.
3. `turnaround time`: **프로세스가 CPU를 요청한 시점 부터 CPU 버스트가 끝날 때까지의 시간.** 즉, `Ready Queue에서 기다린 시간 + 실제 CPU 사용 시간`임. *프로그램이 시작하고 나서 종료할 때까지의 시간이 아님에 주의! 하나의 프로그램이라도 CPU Burst 갯수만큼 별도로 측정된다.
4. `waiting time`: CPU burst 기간 중 프로세스가 Ready Queue에서 CPU를 얻기 위해 기다린 시간의 합. 즉, **Ready Queue에서 기다린 시간들의 합을 의미한다.**
5. `response time`: **프로세스가 Ready Queue에 들어온 후, 처음으로 CPU를 획득하기까지 기다린 시간.** 타이머 인터럽트가 빈번할 수록 response time은 줄어들게 된다. 대화형 시스템에서 중요한 척도라고 할 수 있다. 

# 6.4 스케줄링 알고리즘
## 1. First-Come First-Served: FCFS
FCFS는 프로세스가 Ready Queue에 도착한 **시간 순서대로 CPU를 할당한다.** 그저 순서대로 CPU를 먼저 요청한 프로세스에세 먼저 CPU를 할당해주고, **자발적으로 반납할 때까지 빼앗지 않는다. -> 비선점형 스케줄링이다.** <br>
CPU 버스트가 긴 프로세스들이 먼저 오는 경우 **average waiting time이 길어질 수 있다.** <br>
도착하는 프로세스들의 순서에 따라 대기시간이 달라질 수 있는 알고리즘.. CPU burst가 짧은 프로세스들이 긴 포르세스 하나를 위해 오랜 시간 기다려야 하는 현상을 콘보이 현상 - Convoy effect라고 한다.

## 2. Shortest-Job First: SJF
**최단작업 우선 스케줄링은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다.** <br>
SJF 스케줄링 알고리즘은 average waiting time을 가장 짧게 하는 optiaml algorithm으로 알려져 있다. <br>
SJF는 비선점형, 선점형 둘 다 구현이 가능한데, **선점형의 경우 CPU 버스트가 더 짧은 프로레스가 도착하면, 이미 프로세스가 할당되어 있는 상태일지라도, CPU를 빼앗아 준다.** <br>
이러한 **SJF의 선점형 구현 방식을 Shortest Remaining Time First: SRTF라고도 부른다.** <br>
일반적인 시분할 환경과 같이 프로세스들이 Ready Queue에 도착하는 시간이 불규칙한 환경에서는, 선점형이 프로세스 평균 대기시간을 최소화하는 최적 알고리즘이다. 선점형 방식에서는 프로세스가 새로 도착하거나 작업이 끝날 떄마다 CPU 버스트 시간을 비교한다 <br>

### CPU 버스트 시간 예측
SJF에 있어 가장 큰 걸림돌은 **미리 프로세스 CPU 버스트 시간을 알 수 없다는 점이다.** 그리서 예측을 통해 예측값이 가장 짧은 CPU 프로세스에게 CPU를 할당하는데, **과거의 CPU 버스트 시간을 통해 CPU 버스트 시간을 예측한다.** <br>

n+1 번째 CPU 버스트의 예측 시간 Tn+1은 
```
Tn+1 = ptn + (1 - p)Tn
```
위와 같이 상수 p에 의해 나타나는 점화식이다. p는 0과 1 사이의 값이므로, 자연스럽게 n이 커짐에 따라 오래된 과거일 수록 점점 더 반영이 안 되는 식으로 흘러간다. <br>
SJF는 분명히 **평균 대기시간을 최소화 하는 좋은 알고리즘이다.**
그렇다고 해서 평균을 줄이는 것이 항상 좋은 방식이라고 할 수는 없다. 버스트가 짧은 프로세스에게만 CPU가 할당되는 경우 버스트가 긴 프로세스는 Ready Queue 뒤에서 무한정 기다리는 불상사가 일어날 수도 있다. <br>
**이러한 현상을 starvation이라고 부른다. 이는 SJF의 심각한 문제점이다.**
 

## 3. 우선순위 스케줄링
priority scheduling이란 Ready queue에서 우선순위가 가장 높은 프로세스에게 우선적으로 CPU를 할당하는 방식이다. <br> 
우선순위를 CPU 버스트 시간으로 정하면 사실상 SJF와 똑같다. 우선순위 스케줄링도 비선점형과 선점형의 두 방식으로 구현할 수 있다. <br>

우선순위 스케줄링은 SJF의 단점을 똑같이 가지고 있는데, **starvation이 발생할 수 있다는 것이다.** <br>

### Aging
우선순위 스케줄링에서는 이런 문제 방지를 위해 Aging을 도입했다. 에이징은 노약자 우대 정책과 같이, 기다리는 시간이 길어지는 프로세스들의 우선순위를 조금 높여주는 것이다. 


## 4. Round Robin Scheduling
**라운드 로빈 스케줄링이야 말로 시분할 시스템의 성질을 가장 잘 활용한 스케줄링 방식이다.** <br>
라운드 로빈 스케줄링에서는 각 **프로세스가 CPU를 연속으로 사용할수 있는 시간을 정해주는데, 이를 time quantum이라고 부른다.** <br> 
이 시간이 끝나면, 프로세스는 CPU를 반납하고 큐의 가장 뒤로 돌아간다. 이래서 라운드 로빈 스케줄링이라고 부른다. <br> 
퀀텀은 너무 길거나, 너무 짧아서는 안 된다. 퀀텀이 너무 긴 경우는 사실상 FCFS와 같고 (왜 그런지 생각해보자.) 너무 짧은 경우엔 Context Switch가 너무 빈번히 일어나서 오버해드가 커진다. <br>
이런 방식은 프로세스를 잠깐씩만 사용하고 다시 뒤에 줄을 서는 FCFS 느낌이 나는데, 빠른 응답시간을 보장하면서도, CPU 버스트가 긴 프로세스들이 손해보지 않는다! **그저 각 프로세스의 대기시간은 자연스럽게 그 프로세스의 CPU 버스트 시간과 비례하게 형성된다.**


### 다른 알고리즘들과의 비교
SJF의 경우 평균 대기시간 측면에서는 우수하지만, CPU 버스트가 긴 프로세스들은 희생당했다. **라운드 로빈은 SJF에 비해 공정하다. 소요 시간이나, 대기시간이 자신이 사용하는 CPU 버스트 시간과 비례하다.** <br>

FCFS와도 비교해보자. 동일한 CPU 버스트를 가진 여러 프로세스에 대해, RR은 FCFS보다 평균 응답시간은 더 빠르지만 평균 대기시간과 평균 소요시간이 거의 2배나 느리다. <br>
하지만, 일반적인 시스템에서는 CPU 버스트 시간이 들쭉날쭉 한게 보통이다. 이런 경우에 FCFS는 프로세스마다 소요되는 시간의 편차가 아주 아주 크기 때문에, 평균값이 극단적으로 증가하게 된다. <Br>

결론적으로 현실의 세계 시스템에서, RR은 다른 알고리즘들 보다 공정하고, 평균적으로 빠르게 작동한다.


## Reference
- 운영체제와 정보기술의 원리 <반효경 저>  
