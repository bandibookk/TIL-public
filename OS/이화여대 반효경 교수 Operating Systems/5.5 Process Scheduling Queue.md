## 5.5 Process Scheduling Queue
프로세스를 스케줄링 하기 위한 큐.. <br>
OS는 여려 Queue를 운용한다. <br>
Ready State에서 CPU를 기다리기 위한 Ready Queue, <br>
Device를 기다리기 위한 Device Queue가 있고, 공유 데이터의 사용을 기다리기 위한 Software 데이터 큐가 있고 (따로 이름은 없는 듯) **시스템 내의 모든 Process들을 관리하기 위한 작업 큐 - Job Queue가 존재한다.** <Br>
**이들 프로세스를 위한 Queue는 PCB의 연결리스트로 구성되어 있다.** 포인터를 사용해 순서를 정하며, 가장 앞 부분은 Queue Header라고 부른다. <Br>

### 5.1 Ready Queue - 프로세스용
**Ready State 안의 프로세스들은 Ready Queue에 줄 세워져 있다.** 해당 큐에 줄 세워진 순서는 **CPU Scheduling 방식에 따라 다르게 정렬 되어 있다** 이대로 바로 가장 앞의 프로세스가 다음 Running State가 될 Process로 결정된다. <br>

### 5.2 Device Queue - 하드웨어 Resource
이런 Ready Queue 외에도 OS는 특정 **하드웨어 자원들을** 기다리는 프로세스들을 줄 세우기 위해 **자원별로 Device Queue를 둔다.** <br>
예를 들어 Disk에 I/O 서비스를 요청한 Process들은 Disk I/O Queue에 Keyboard 입력을 받아야 하는 경우에는 keyboard I/O Queue에 줄을 서게 되는 것이다. (I/O이기 때문에 대게 Blocked State)

### 5.3 Software Resource용 Queue
이런 Queue들은 Software의 공유 데이터에 접근할 때도 필요하다 <br>
**데이터 일관성을** 위해 공유 데이터에 대한 접근 권한은 Software Resource로 분류되어 관리된다. 공유 데이터는 매 시점 하나의 Process만이 접근 가능해야 한다. <br>
이 떄, 한가지 주의해야 하는 점이 있다. <Br>
**현재 CPU가 사용하지 않는 데이터도 보호가 필요할 수 있다.** 왜냐하면 꼭 Running State에 있는 Process가 아니더라도, 현재 Ready State나 Blocked State에 있는 Process에서 사용중인 데이터를 변경하게 된다면! 똑같이 **일관성이 깨질 수도 있다.** <Br>
따라서, `공유 데이터`라는 Software Resource는 접근 중인 프로세스가 반납할 때까지는 다른 Process가 접근할 수 없게 해야한다. <U>**큐에 줄을 서게 만들면서 말이다!**</U> <br>


### 5.4 Job Queue
앞서 이야기한 준비 큐와 장치 큐 외에 추가적으로 **시스템 내의 모든 Process를 관리하기 위한 Queue인 Job Queue가 존재한다.** <br>
Job Queue에는 프로세스의 **상태와 무관하게** 현재 시스템에 속한 모든 프로세스가 속하기 때문에, **작업 큐에 있다고 해서 반드시 메모리를 가진 것은 아니다.**
장치 큐에 있는 프로세스들은 Blocked State에 있기 때문이다. <br>
프로세스는 상태에 따라 준비 큐와 장치 큐를 오가며 실행된다. <Br>
**작업 큐가 가장 넓은 개념이고, 준비 큐와 장치 큐에 있는 프로세스들을 모두 작업 큐에 속한다.** <br>

## Reference
- 운영체제와 정보기술의 원리 <반효경 저>  
