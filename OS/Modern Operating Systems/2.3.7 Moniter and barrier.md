# 2.3.7 모니터
모니터 procedure
```txt
단 하나의 프로세스만 한 순간에 모니터에서 활동할 수 있다.

모니터라는 어떤 공간 위에 프로세스가 올라가서 실행되는데, 
단 한개만 있을 수 있다.
```
세마포어와 뮤텍스를 이용한 프로세스간 통신은 **어렵다.** down 연산의 순서만 틀려도 무한히 대기할 수도 있다. <br>

empty 전에 mutex가 먼저 감소되면 어떻게 될까? 버퍼가 가득 차게 되면 생산자는 mutex를 0으로 설정한 상태에서 대기하게 된다. 생산하지 못 했기 때문에 소비자가 다음 번에 버퍼를 접근할 때 mutex에 대해 down을 수행하고 이 값이 0이므로 소비자 역시 대기하게 된다. 이를 **deadlock - 교착상태** 라고 부른다. <br>

세마포어 프로그램을 좀 더 쉽게 작성할 수 있도록 도입된 것이 **고급 동기화 프리미티브 모니터** 이다. <br> 모니터는 특별한 형태의 모듈 또는 패키지에 모아진 procedure, variable, data structure의 모음이다. <Br> <br>


모니터는 상호배제를 위한 중요한 속성을 지니고 있다. 
**"단 하나의 프로세스만 한 순간에 모니터에서 활동할 수 있다."** <br> 
모니터는 PL의 구조적인 요소로, 컴파일러는 이들이 특별하다는 것을 알고 있다! 컴파일러는 moniter procedure의 호출을 다른 일반 procedure의 호출과 다르게 처리한다. <br> 

일반적으로 프로세스가 모니터 procedure를 호출하면 최초의 명령들이 **다른 프로세스가 이미 모니터에서 활동중인지 검사하고, 중단(suspend)한다.** 비어 있는 경우에만 모니터로 진입한다. <br>

전적으로 대부분의 책임이 컴파일러에게 있기 때문에, 잘못될 가능성이 매우 적음.  <br>


## 모니터 조건 변수
그러나 이런 체크의 구현이 또 쉬운 것은 아니다. 대기해야할 상황이나, 버퍼의 차있고 비어있는지에 대한 여부는 어떻게 체크가 진행되어야 할까? <br>

이는 **조건 변수(condition variables)와 이들에 대한 연산 <U>wait, signal</U>의 도입으로 해결할 수 있다.**  <br>

모니터 procedure가 버퍼가 가득 차거나 비어있는 등의 이유로 더 이상 진행할 수 없는 경우, 어떤 조건 변수에 대해 **wait를** 수행한다. 그 예로는 full, empty 변수가 될 수 있다. <br> 이 동작은 프로세스를 대기하게 만든다. <br> <br> 

**signal은 프로세스를 깨울 수 있다.** 생산자-소비자의 경우 파트너 프로세스로 여겨지는데, 서로를 깨운다. signal 이후를 잘 구현해 두어야 동시 활동을 막을 수 있다.
1. Hoare: 기존 프로세스를 중단시키고, 새로운 프로세스가 시작되어야 해.
2. **Brinch Hansen:** signal 수행한 프로세스는 즉시 나가라~

후자가 더 간단하므로 후자의 제안을 택함. 수행한 프로세스는 즉시 나가고, 스케쥴러가 프로세스 하나를 골라 올린다. <br> 

이 조건변수는 세마포어처럼 카운터가 아니라, signal이 허무하게 사라질 가능성도 있지만, signal 호출 이전에 무조건 wait의 호출이 있어야 한다는 규칙의 도입으로 이를 막을 수 있다.

## 모니터 Wait-Signal과 Sleep-Wakeup의 차이
모니터 연산은 모니터  procedure에 대해 자동적으로 상호배제가 이루어 진다는 점이 차이점.

```c
monitor example
    integer i;
    condition c;

    procedure producer();
    .
    .
    .
    end;

    procedure consumer();
    .
    .
    .
    end;
end monitor;
```

## 2.3.9 장벽
장벽 연산은 프로세스 그룹에 적용되는 메커니즘으로, 병렬화 작업을 통해 연산을 진행했다가, 모든 결과가 필요한 연산이 있을 때, 장벽 연산을 수행한다. 
다수의 프로세스들이 전부 완료 될 때까지, 먼저 완료된 프로세스가 잠시 기다려 준다는 메커니즘이다. 
가상의 장벽이 있고, 그 앞에서 먼저 도착한 프로세스들은 기다린다. 
마지막 프로세스가 도착하면, 그제서야 기다리던 모든 프로세스들이 장벽을 통과한다.


## Reference
- Modern Operating Systems \<ANDRE S,TANENBAUM 저>
