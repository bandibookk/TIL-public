## 2.3 프로세스간 통신

## 3가지 쟁점
### 1. 어떻게 다른 프로세스에게 정보를 전달할 것인가?
### 2. 둘 이상의 프로세스가 어떻게 서로를 방해하지 않을 수 있을까? 
### 3. 종속성이 존재할 떄 적절한 순서를 정하는 방법

위 3가지 쟁점이 핵심이다. <br>

2, 3번에 대한 해결책은 프로세스간 통신과 스레드간 통신에 동일하게 적용된다. 1번은 주소 공간을 공유하는 스레드에게는 쉽다.


### 2.3.1 race condition
공유되는 자원에 동시에 접근한다면 무슨 일이 일어날까? race condition이 있는 프로그램에서는 거의 동시에 두 프로세스가 어떤 처리를 하는 경우, 앞서 처리한 부분을 지워버리곤 한다.

### 2.3.2 임계 구역
이런 race condition을 어떻게 회피할 수 있는가? 핵심은 둘 이상의 프로세스가 동시에 공유 데이터에 읽기와 쓰기를 못하도록 금지하는 것이다. 다른 말로는 **Mutual Exclusion 상호 배제가 필요하다!** <br> **한 프로세스가 공유 변수나 파일을 사용중이면 다른 프로세스들은 똑같은 일을 수행하지 못하도록 하는 것이다.** <br> 때떄로 우리는 공유 메모리나 파일을 접근해야만 한다.. 이런 공유 메모리를 접근하는 프로그램 부분을 **임계구역**이라고 부른다. <br> 좋은 해결책은 아래 4가지 조건을 모두 만족한다. 

1. 두개의 프로세스가 동시에 자기의 임계구역 내에 존재하는 경우는 없어야 한다
2. CPU의 개수나 속도에 대해 어떤 가정도 하지 않는다.
3. **임계구역 외부에서 실행하고 있는 프로세스는 다른 프로세스들을 블록시켜서는 안 된다.** -> 밖에 있으면서 길막하지마
4. 임계구역에 진입하기 위해 무한히 기다리는 프로세스는 없어야한다. -> **무한 대기 금지**

## 2.3.3 Busy Wait
### 1. 인터럽트 끄기
가장 간단한 해결책은 그냥 프로세스가 임계 구역에 들어가면서 인터럽트를 종료해 버리는 것. 그럼 되는것 아닌가? <br>

**아니다, 이 방법이 구린 이유**
1. 사용자에게 인터럽트를 끌 수 있는 권한을 주는 것은 현명하지 못 하다. 만약에 얘가 다시 안 킨다면...? 시스템이 고장난다.  
2. 또한 여러 CPU를 가진 시스템의 경우 해당 명령이 본인의 CPU에만 영향을 미치기 때문에 사실상 막히지도 않는다. 


운영체제 내부에서 커널이 이런 방법을 쓰는 것은 가끔 유용하지만, 사용자간의 프로세스 상호배게를 워한건 아님!

### 2. Lock Variable
락 변수를 쓰는 것이다. 들어가면서 0을 1로 바꾸면서 나 쓰고 있다~~를 알리는 것. 
<br>

**실패!!** <br>
이건 왜 문제가 될까? **컨텍스트 스위치** <br> 프로세스 A가 0인걸 보고 들어가야지~ 하려다가 프로세스 B로의 컨텍스트 스위치가 일어나면 어떻게 될까.. 결국 A와 B가 동시에 건들게 된다.


### 3. Strict Alternation - 엄격한 교대
바쁜 대기 + 스핀 락을 사용한다. <br>
엄격한 교대는 두 프로세스가 임계 구역을 교대해서 쓰자는 컨셉이다! 웃기게도 **한 명이 수행을 마치면, 다른 한명이 마칠 때까지 절대 다시 들어가지 못 한다.** 풀어 말 하자면, 프로세스 A가 임계구역 밖에서 하루종일 작업 중이여도 프로세스 B는 한번 임계구역에 들어가 있다가 나오면, A가 들어갔다가 나올 때까지 아무것도 못 한다!! <br> 
**프로세스 하나가 다른 하나보다 많이 느릴 때 사용하기에 매우 나쁘다!**  <Br>  **임계구역에 속해있지 않은 프로세스가 다른 프로세스를 막아버린다는 것이다!**

```c
while (TRUE) {
  while (trun != 0) 
  critical_region();
  turn = 1;
  noncritical_region();
}

while (TRUE) {
  while (trun != 1) 
  critical_region();
  turn = 0;
  noncritical_region();
}
```

### 4. Peterson의 해법

임계 구역에 진입하기 전에, 각 프로세스는 자신의 프로세스 번호 0 또는 1를 제공하며 enter_region을 호출한다. <br>  **interested 배열은 현재 어떤 프로세스가 진입을 희망하는지 체크해준다.** 진입하며 `interested[process] = ture`로 대입해준 다음 leave_region에서 `FALSE`로 바꿔준다. <br>

혹여 거의 동시에 둘이서 진입하려고 `interested[process] = ture` 처리를 해주더라도, turn이라는 공유 변수 덕분에 **진입 시도가 빨랐던 쪽의 진입이 막힌다!!**

### 5. TSL Instruction
하드웨어의 도움을 약간 필요로 한다.
```
TSL REFISTER, LOCK
```
**Test and Set Lock!** 명령은 메모리 워드 LOCK의 값을 읽어 레지스터 REFISTER에 저장하고, 메모리 주소 LOCK에 0이 아닌 값을 기록합니다! <br> **레지스터가 동반된 특이한 방법!** **워드를 읽고 저장하는 연산은 Atomic 합니다!!!** CPU가  연산 동안 메모리 버스를 잠그기 때문에 아주 적절한 방식입니다!

```
enter_region:
    TSL REGISTER, LOCK
    CMP REGISTER, #0
    JNE enter_region
    RET

leave_region:
    MOVE LOCK, #0         | store a 0 in lock
    RET
```

1. copy lock to register and set lcok to 1
2. cmp -> was lock zero?
3. if it was zero, lock was set, so **loop!!!!!!!!**
4. return to caller~ critical region entered


# 그래봐야 Busy wait
마지막에 Peterson의 해법과 TSL instruction으로 분명 Mutual Exclusion을 이루어 냈다! <br> 하지만, 이 방법들도 결국엔 **Busy Wait를 이용하는 단점이 있는 것이였다..** 이는 CPU의 시간을 매우 매우 낭비하고, **우선순위 역전 문제가 발생할 수 있다.** <br> 우선순위가 낮은 L이 임계 구역에 진입한 다음 우선순위가 높은 G가 수행되면서 바쁜 대기를 해버리는 것이다. 그럼 **H가 수행중이므로, L은 스케쥴링 되지 않고, L은 임계구역을 벗어날 기회가 없다!!** **H는 무한 루프에 빠지게 된다..** <br> <br> 이런 단점을 해결하기 위해, 무한 루프인 busy wait 대신 잠시 잠재우는 Sleep와 WakeUp을 살펴보자..
  
 
## Reference
- Modern Operating Systems \<ANDRE S,TANENBAUM 저>
