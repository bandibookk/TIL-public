# 3.2 File Implementation
파일 저장 공간 구현에서 가장 중요한 문제는 **어느 블록이 어느 파일에 속하지는 추적하고 관리하는 것이다.** <Br>
이를 위한 파일의 구현을 알아보자.

## 1 Contiguous Allocation
![4 3 연속 할당](https://user-images.githubusercontent.com/71186266/203041799-d10d97a6-349d-40c7-91c9-2b446ed1cfb3.png)

아주 심플하게 파일을 연속된 디스크에 다다다다 저장하는 것이다. <br>
만약 디스크 블록의 크기가 1KB라고 하면, 50KB의 파일은 50개의 연속된 블록에 그냥 저장된다. <br>


그림의 (a)와 같은 상황은 빈 디스크에서 시작해서 순서대로 파일 A, B, C ... 가 디스크에 기록된 형태이다. <br>

**각 파일은 새로운 블록부터 저장되기 시작한다!** 그림에는 없지만, 어떤 파일의 끝부분이 블록 1/2만 차지하고 있어도, 다음 파일은 어쩔 수 없이 다음 블록에서 부터 저장된다. <br>
공간의 낭비가 있다는 것. (b)에서도 그렇다. **시간이 흘러갈 수록 빈 공간이 만들어 질 수 밖에 없는 구조다.** <br>

#### 파일은 No Compaction
**공간의 fragmentation이 발생한다. 파일 시스템은 이른 가용공간들을 통합하려는 시도를 하지 않는다. 그 비용이 너무 비싸기 때문이다.** <br>
미리 파일의 최종 크기를 가늠해서, 가용 공간 구멍 리스트를 만들고 유지함으로써 재사용이 가능하기는 하지만 결코 좋은 상황은 아니다.

#### 연속 할당 장점
1. 구현하기가 쉽다. 파일의 시작 블록, 블록 갯수 2개만 알면 된다. 나머지는 단순 덧셈
2. 읽기 성능이 뛰어나다. 단 한 번의 동작으로 전체 파일을 디스크에서 읽을 수 있다. <br> 이후, 더 이상의 탐색이나 회전 지연 시간은 필요 없다. 데이터를 디스크 최대 대역폭으로 읽을 수 있다. 

이러한 장점들 덕분에, 단점이 있음에도 불구하고, CD-ROM과 DVD같은 한번만 쓰기가 가능한 광 미디어 파일 시스템에서는 잘 사용한다.

## 2.2 Linked List Allocation - 연결 리스트 할당

![4 3 링크드](https://user-images.githubusercontent.com/71186266/203041808-a38cb6cb-9fe7-4b95-8b61-227b5ba163de.png)

파일 저장의 다른 방법으로 Linked List 형태로 관리하는 방법이 있다. <br>
각 블록의 첫 번째 Word는 다음 블록을 가리키는 포인터로 사용되고, <br>
블록의 나머지 공간에 데이터를 저장한다. <br>

링크드 리스트의 구조이기 때문에, fragmentation으로 인한 공간 낭비가 없다. 또한 Directory Entry에는 첫 디스크 블록 주소만 저장하면 된다. 나머지는 추적하면 되니까! <br>

물론 이런 구현은 Linked List의 단점을 그대로 안고 있다.
1. 임의 접근이 매우 느림 - 선형 탐색이니까!
2. 블록의 수 바이트가 포인터를 저장하기 위해 사용되기 때문에, 데이터 양이 2의 지수 배가 아니여서 비효율적이다.
3. 2번으로 인해 블록 단위로 읽을 때 정보만 읽어내서 이어 붙여야 하는데, 이런 복사 과정에서 약간의 오버헤드가 발생한다.

## 2.3 FAT - File Allocation Table
### Linked List Allocation Using in Memory Table
위와 같은 연결 리스트의 단점은 **각 블록에 존재하는 포인터들을 메모리 내에 있는 테이블에 저장함으로써 해결할 수 있다.** <br>
**메모리에 존재하는 File Allocation Table FAT를 이용한 Linked List Allocation.** <br>


![4 3 fat](https://user-images.githubusercontent.com/71186266/203041802-e5cc935e-aa18-4bac-bc56-b3dc64fefe47.png)

위에서 언급한 연결 리스트 할당의 단점 2개를 메모리에 존재하는 테이블을 이용함으로서 해결하려는 시도. 
1. **블록을 가르키는 포인터를 FAT에 저장! 체인을 따라가며 블록을 탐색한다.** -1은 체인의 끝을 의미한다. <br> 이러한 사용으로 한 블록 전체를 데이터 저장에 사용할 수 있게 된다!
2. 임의 접근이 아주 쉬워진다. 체인이 메모리에 존재하기 때문에, 디스크 참조가 필요 없다!

<br>

하지만 FAT을 이용한 방법에도 단점은 있다. <br> **전체 테이블이 메모리에 존재해야 잘 동작한다!** 그리고 **차지하는 양이 디스크 용량에 비례한다.** <br> 분명 효율적이지 않은 방법이다..


## 2.4 I-node :star:
**index-node!** **i-node는 파일의 속성들과 파일의 디스크 블록 주소를 가진다.** <br>

![4 3 i-node](https://user-images.githubusercontent.com/71186266/203041806-0ddf817b-d4d1-4e29-b3b6-f51b2260024f.png)


### i-node가 가지고 있는 것들
1. 파일의 속성들
2. 파일의 디스크 블록 주소


i-node를 통해 파일의 모든 블록을 발견할 수 있다. 
### 장점들
1. 어떤 파일을 열면(open) 해당 파일의 i-node만 메모리에 가지고 있으면 된다.
2. 만약 하나의 i-node가 n 바이트를 차지하고, 최대 k개의 파일을 동시에 열 수 있다면, <br> **열린 파일들의 i-node 배열을 저장하기 위해선 kn바이트만 필요한 것을 바로 알 수 있어서, 시스템은 이 정도의 공간만 미리 예약해두면 된다. -> 필요한 공간을 바로 알 수 있다.**
3. 디스크 용량에 비례하지 않는 테이블을 가진다! **동시에 개방되는 최대 파일 개수만큼의 배열만 가지고 있으면 된다.**

<br>

#### **단점**
1. 각 i-node에 디스크 블록 주소를 저장할 수 있는 공간이 유한함.
#### **해결책**
1. i-node의 마지막 주소가 가리키는 블록에 데이터 대신 다른 디스크 블록들의 주소를 넣는 것!
2. (발전) 마지막 두 세 개에 여러 디스크 블록 주소들을 가진 디스크 블록을 가리키거나, 그런 주소를 모아둔 블록을 가리키는 것!

## Reference
- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
