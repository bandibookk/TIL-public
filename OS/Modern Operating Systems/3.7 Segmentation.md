# 3.7 Segmentation
지금까지 논의 되었던 가상 메모리는 1차원적이였다. <br>
하지만, 두개 이상의 서로 분리된 가상 주소 공간을 갖는 것이 하나의 주소 공간을 갖는 것보다 더 편리한 경우가 많다. <br>
예를 들어 컴파일러는 컴파일 도중 다양한 테이블을 생성하는데 
1. 소스 텍스트
2. 심볼 테이블
3. 상수 테이블
4. 파싱 트리
5. 스택

상황에 따라 어떤 테이블은 공간이 부족해지고, 어떤 테이블은 공간이 남아 돌 수 있다. <br>
하나가 꽉찬다고 경고를 보내거나, 종료하기 혹은 유저가 직접 가용 공간들을 분배해주기는 너무나도 불편하다. 사용자가 직접 이런 것들을 관리하는 것은 절대 좋은 구현이 아니다. 복잡할 뿐더러, 침범의 문제가 발생할 수도 있기 때문이다. <br> 

최고의 상황은 각 메모리 부분을 증가하거나 감소시키는 작업을 시스템에서 자연스럽게 제공하는 것이다! <br> 

이를 위해 시스템은 **Segment라고 불리는 여러개의 서로 완전히 독립된 주소 공간들을 제공한다.** <br>

## 1. Segment
1. 각 세그먼트는 **자신만의 Address space를 갖는다.** 덕분에 서로 다른 길이를 
가질 수 있다. 
2. 세그먼트는 선형 주소로 구성되며, 0부터 시스템에서 허용된 최대 크기까지의 값을 갖는다.
3. 세그먼트의 크기는 실행 시간중에 변할 수 있다.
4. 프로그램이 사용하는 주소가 두 부분으로 되어 있어야 세그먼트를 사용할 수 있다.
5. n번째 세그먼트가 사용하는 주소는 (n, 0)과 같이 두 부분으로 나타낼 수 있고, 주소 0은 entry point라고 부른다. (시작점) <br> 이는 여러 함수를 세그먼트들로 관리했을 때 Linking을 편리하게 해준다.
6. 함수나 데이터를 **여러 프로세스들이 공유하기 쉽다.** 
7. Segment는 서로 다른 보호 모드를 가질 수 있다. - Can be distinguished and separately protected


## 2. Pageing vs Segmentation
![pagingvssegmentation](https://user-images.githubusercontent.com/71186266/206873464-77ecc2f7-0139-4da8-899e-e357933443dc.png)


|                        고려 사항                         |                              Paging                              |                                Segmentation                                 |
| :------------------------------------------------------: | :--------------------------------------------------------------: | :-------------------------------------------------------------------------: |
|     1. 프로그래머가 이 기술이 사용되는 것을 아는가?      |                                No                                |                                   **Yes**                                   |
|          2. 얼마나 많은 선형 주소를 지원하는가?          |                                1                                 |                                  **다수**                                   |
| 3. 전체 주소 공간의 크기가 물리 메모리보다 클 수 있는가? |                               Yes                                |                                     Yes                                     |
|    4. 함수와 데이터가 구분되고 분리되어 보호 되는가?     |                                No                                |                                   **Yes**                                   |
|   5. 크기가 자주 변하는 테이블을 적절하게 지원하는가?    |                                No                                |                                   **Yes**                                   |
|             6. 공유 지원이 쉽게 구현되는가?              |                                No                                |                                     Yes                                     |
|                  7. 기술이 발명된 이유?                  | 물리 메모리를 더 늘리지 않고도 <br> 큰 선형 주소를 제공하기 위해 | 프로그램을 논리적인 작은 주소 공간들로 구분하고, <br> 공유/보호 하기 위해서 |



4. code segment는 read only로, data segment는 read only로 설정할 수가 있다.
5. **paging:** 하나의 거대한 구조를 원해 <br> **segment:** sharing, protection으로 분리-관리 원해


## 3. Implementation of Pure Segmentation

Segmentation과 Paging은 구현 방법이 다르다! 본질적으로 페이징은 **고정크기,** 세그멘테이션은 **가변크기이다.** <Br>

![puresegmentation](https://user-images.githubusercontent.com/71186266/206873812-de21ecc4-4429-4437-98c4-0439dd2eaa7e.png)


위의 그림은 5개의 Segment를 포함한 물리 메모리이다. <br>
(a) => (b)는 Seg 1이 나가고 더 작은 Seg 7이 적재된 상황이다. <br>

(d)까지 쭉 진행되면서, 메모리는 작은 조각으로 계속 분할되고, 빈 조각들이 생겨난다. 이는 메모리 낭비를 초래한다. <br>

### checkerboarding, external fragmentation, compaction
이런 현상을 체커판 같다고 하여서, **checkerboarding** <br>
혹은 **external fragmentation** - 외부 단편화라고 부른다. <br>
이런 낭비되는 부분을 수집하는 **compaction** - 조각 모음을 통해 해결할 수 있고, 이는 (e)에 나타난다.

## Reference
- Modern Operating Systems <ANDRWE S. TANENBAUM 저>
 
