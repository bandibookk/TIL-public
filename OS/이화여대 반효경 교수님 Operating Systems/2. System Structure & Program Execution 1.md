# 2. System Structure & Program Execution

## 2.1 Computer

엄밀한 의미의 `컴퓨터`는 CPU와 Memory 만을 뜻한다. Disk나 모니터 등의 장치들은 I/O 장치로 보는 것이 맞다.

CPU를 제외한 장치들은 각 장치를 관리하는 컨트롤러들이 있다. 메모리는 memory controller가, 각 I/O Divce들은 device controller가 붙어 작은 CPU의 역할을 해준다. 

각 Divce의 내부를 통제하는 것은 CPU가 아니라, 이런 컨트롤러들이다. 키보드는 키보드 컨트롤러가, Disk는 Disk Controller가 통제한다.
이런 컨트롤러들 또한 CPU와 같은 작업 공간이 필요한데, I/O 장치의 작업 공간을 local buffer라고 한다.

CPU와 I/O 장치들의 처리 속도는 큰 차이가 난다. CPU에 비해 Disk의 처리 속도는 100만배나 느리다. CPU는 그저 평생동안 Memory의 instruction을 꺼내어 읽는 것을 반복한다.  이것이 CPU의 운명이다. 메모리 안의 여러 프로그램들이 시키는 명령들을 꺼내어 수행하고, 꺼내어 수행하는 것의 무한 반복.

그럼 I/O에는 어떻게 접근할까? CPU가 I/O에 접근하지 않고, 각 Device Controller들에게 데이터를 가져올 것을 요청한다. 어떤 프로그램이 I/O 요청이 필요해지는 경우, 직접 접근하지 않고, CPU에게 접근을 요청한 다음, 자진해서 제어권을 OS에게 넘긴다. 이러한 I/O 접근 요청은 처리에 오랜 시간이 걸리므로, CPU는 그동안 **I/O 접근을 요청한 프로그램이 아닌,** 다른 프로그램의 작업을 수행하고 있는다. 

## 2.2 메모리 제어권과 Mode bit

CPU 안에는 Memory 보다 접근이 빠른 저장 공간이 있는데, 이를 register라고 부른다. CPU는 mode bit이라는 register를 통해 현재 CPU를 제어하는 것이 유저인지 운영체제인지 파악할 수 있다. 앞서 언급한 제어권을 누가 가지고 있는지 확인할 수 있다.

**mode bit이 0일 떄는** `커널 모드` 혹은 `모니터 모드, 시스템 모드` 라고 부르며, **운영체제가 제어권을 가지고 있는 상태를** 의미한다. I/O 접근이나 메모리 접근 instruction 모두가 수행 가능하다. 이런 보안을 해칠 수 있는 중요한 명령어들을 특권명령 이라고 부른다.

**OS는 사용자 프로그램에게 memory 제어권을 넘길 때 이 mode bit을 1로 바꾼 다음에 제어권을 넘겨준다. mode bit이 1일 떄는 `유저 모드`라고 부르며, 사용자 프로그램이 제어권을 가진 상태로** 제한된 instruction만 수행이 가능하다. 보안을 위해 I/O 접근은 물론 불가능하고, 다른 프로그램이 사용중인 memory 또한 침범이 불가능하다.

# 2.3 Timer

이렇게 OS가 사용자 프로그램에게 memory 제어권을 넘겨 줄 때, **내부의 hardware Timer에 제한 시간을 설정한 다음 넘겨준다.**

이는 사용자 프로그램의 독점을 막기 위한 처리로, 약 100ms 정도의 시간을 설정한 다음 넘겨준다. 

정해진 시간이 끝나면, timer interrupt가 발생하며, 제어권이 사용자 프로그램에게서 OS로 넘어가게 된다. 이러한 timer의 도움으로 time sharing 구현이 가능해진다. 

## 2.4 DMA

I/O 장치의 작업이 완료되면, local buffer의 내용을 메모리에 기록해야 한다. 이런 기록을 위한 interrupt는 overhead가 크고, I/O 장치가 많아지면서 잦아질 수 밖에 없다.  

고성능 CPU를 좀 더 효율적으로 이용하기 위해, 이런 I/O 장치의 기록을 DMA가 도와준다. 

DMA는 I/O 장치들의 쓰기 요청을 직접 메모리에 access하여 처리해준다. CPU를 대신하여 memory에 IO 결과를 기록해준다. 

DMA는 작업이 끝난 이후, 작업이 끝났다는 사실만을 interrupt를 통해 CPU에게 알린다. 이런 방식으로 interrupt를 많이 줄일 수 있다.

CPU와 DMA가 메모리라는 하나의 공유자원을 사용하기  발생할 수 있는 충돌은 Memory Controller가 관리한다.

## 2.5 System Call

앞서 언급된 제어권의 문제로, 사용자 프로그램은 직접 권한을 해치는 서비스들을 수행할 수 없다.  **System Call은 사용자 프로그램이 OS의 서비스를 받기 위해, OS에게 서비스를 부탁하기 위해서 커널 함수를 호출하는 것이다.** 

일반적인 사용자 프로그램의 수행은 memory 안에서 주소들을 점프해가며 수행된다. 시스템 콜은 단지 메모리 주소를 바꾸는 것으로 해결되지 않는다. 사용자 프로그램이 OS 주소로 직접 넘어가는 것이 허용되어 있지 않으므로, 프로그램이 직접 interrupt line에만 손을 대서 수행을 요청하는 것.

이런 software를 통한 interrupt를 software interrupt 혹은 trap이라고 부른다. 기존의 timer interrupt와 같은 인터럽트들은 hardware interrupt라고 부른다.  사용자 프로그램이 OS 함수를 사용하고 싶으면, 직접 소프트웨어 인터럽트를 걸어서 요청한다. 그러면 OS가 올바른 요청인지를 확인한 다음, 대신 수행해준다.

I/O 요청은 software interrupt를 통해 요청되고, 이후 hardware interrupt를 통해 메모리에 저장된다.

현대의 운영체제는 인터럽트에 의해 구동된다고 표현할 수도 있다. 마지막으로 이와 관련된 두 가지 개념을 살펴보자.

- 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다
- 인터럽트 처리 루팅: 인터럽트 핸들러 - 해당 인터럽트를 처리하는 커널 함수 - 실제로 처리하는 부분이 된다.

## Reference
- KOCW 반효경 교수 
