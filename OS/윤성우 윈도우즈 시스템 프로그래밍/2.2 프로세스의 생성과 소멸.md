# 5. 프로세스의 생성과 소멸
오늘날의 OS는 **Multi-Process 운영체제**라고 불리운다. 이 Process에 대해 알아보겠습니다. (중요 개념)

## 5.1 프로세스란 무엇인가? 
**프로세스란 실행 중에 있는 프로그램을 의미합니다.** <br> 

**어떤 프로그램을 실행하면, 프로그램을 실행을 위해 메모리 할당이 이루어지고, 이 메모리 공간으로 바이너리 코드가 올라가게 됩니다.** <br> 
**이 순간 부터 프로그램은 프로세스라고 불리게 됩니다.** <br>
**즉, 프로세스란 실행 중에 있는 프로그램을 의미합니다.**

인터넷 접속을 위해선 인터넷 익스플로러를 실행시킵니다. 이 떄, 익스플로러의 실행 파일인 `iexplorer.exe`는 프로그램이고, 익스플로러 창은 `Process`입니다. 두 개의 인터넷 익스플로러를 실행시킨다면, 둘 이상의 프로세스를 생성한 셈이 되는 것입니다.

## 5.2 프로세스를 구성하는 요소
### Execution of "C" Program
프로그램이 실행될 때 구성되는 메모리 공간은 다음과 같습니다.
- **Data영역**: **전역변수나, static 변수 할당**
- **Stack영역**: **지역변수 할당**이나, 함수 호출시 parameter의 저장
- **Heap영역**: 동적 할당을 위해 존재. **ex) malloc, calloc 함수에 의한 할당**

기존엔 이정도가 중요했고, 여기에 Code영역이 추가 된다.
- **Code영역: 프로그램이 실행되면, 실행 파일 내에 존재하는 명령어들이 올라가는 메모리 영역**

![5단원 1](https://user-images.githubusercontent.com/71186266/184344802-2597a484-7e19-4653-a2e6-1e59252abb3d.png)


이들을 하나로 묶으면 **프로그램 실행 시 메모리 공간의 구성을 짐작할 수 있다. 이것이 프로세스의 실체이다.**  <br> 이것이 프로레스 생성 시 메인 메모리에 만들어지는 메모리 구조이고, 이 자체를 프로세스라고 부르기도 한다. 왜냐하면 
1. **명령어들이 메모리 공간에 올라와 있는 상태이고,** (프로그램 실행을 위한)
2. **메모리 공간이 할당되어 있는 상태이기 때문이다.** (프로그램 실행을 위한) <br>
하나의 프로그램이 실행 될 때 마다 위와 같은 메모리 구조가 구성된다. 예를 들어, 게임, 음악, 인터넷 세 개의 프로그램이 실행중이라면, 위와 같은 메모리 구조는 총 3개가 구성된다.
### 즉, 위의 그림과 같은 메모리 구조는, 실행되고 있는 프로세스의 개수만큼 생성된다!

### Register Set
프로세스를 구성하는 요소로, 메모리 구조만 중요한 것이 아니다. CPU 내에 존재하는 **Register들 또한 프로그램의 실행을 위해 절대적으로 필요하므로, 매우 중요하다** <br>

어떤 프로그램이 실행된다면, CPU를 구성하는 레지스터들은 프로그램의 실행을 위해 필요한 데이터들로 채워지게 된다. **따라서, 레지스터들의 상태까지도 프로세스의 일부로 포함시켜 말할 수 있다.** 이 부분을 알고 있어야, Context Switching을 이해할 수 있다. 

### RAM의 크기와 프로세스의 크기
위의 그림과 같은 메모리 구조가 구성되는 곳은 메인 메모리-RAM이다. RAM은 크기가 작은데, RAM의 크기를 넘어서는 프로세스는 만들지 못 할까? 그렇지 않다. **RAM의 크기 만큼으로 프로세스의 크기가 제한된다면 단 하나의 프로세스도 만들어지지 못 한다.** 이와 관련된 내용은 20장 Memory Management에서 배우게 된다. 일단은 그냥 받아들여라 **프로세스가 구성되는 곳은 RAM(메인 메모리)이지만, RAM의 크기 보다 큰 메모리 구조도 구성될 수 있다.** 

# 프로세스의 스케줄링과 상태 변화
CPU는 하나인데, 어떻게 여러 프로그램이 동시에 실행 가능한 것인가? 
<br> 

**하나의 CPU가 여러 개의 프로세스를 번갈아 가면서 실행해주면 된다!**

## 5.3 프로세스의 Scheduling
CPU는 하나인데, 동시에 실행되어야 할 프로세스는 여러개이다.. 논리적으로 생각해 보면, 이를 해결할 수 있는 방법은 **CPU가 여러 개의 프로세스를 번갈아 가며 실행하는 것 뿐이다!** <br> 
CPU는 아주 아주 빠르기 때문에, 여러 프로세스를 고속으로 번갈아 가며 실행시키기 때문에, 사용자가 느끼기에는 동시에 일어나는 것 처럼 보이게 되는 것이다. 즉, 너무 빨라서 동시에 일어난다고 착각하게 된다는 것입니다. <br> 
**결국 우리가 사용하는 멀티 프로세스 운영체제에서 여러 개의 프로세스가 실행되는 것처럼 보이는 이유는 여러 개의 프로세스들이 CPU 할당 시간을 나누기 때문이다.**

### 스케줄링 기본 원리
여러 프로세스들에 어떻게 CPU를 할당 해줄 지를 정해야한다. 예를 들어 "A, B, C 세 개의 프로세스가 있다면, 공평하게 순서대로 돌아가며 정해진 시간에만 CPU를 할당 받게 하자!"라고 정할 수 있겠습니다. <br> 

프로세스의 CPU 할당 순서 및 방법을 결정짓는 일을 가리켜 **스케줄링(Scheduling)**이라고 부른다. 그리고 이때 사용되는 알고리즘을 **Scheduling Algorithms**이라 부릅니다. 그리고 이런 스케줄링 알고리즘을 적용해서 실제로 프로세스를 관리하는 OS의 요소를(모듈을) 가리켜 **스케줄러(Scheduler)**라고 합니다. 스케줄러는 소프트웨어적으로 구현되어있는 요소입니다. 물리적 장치가 아닙니다.

### 멀티 프로세스
멀티 프로세스는 왜 효율적일까? 동시에 실행되는 형태가 효율적인 이유는 프로세스 종료시간의 차이에 있다! <br>
예를 들어, A 실행하고, 종료되면 B 실행하고, 완전히 종료되면 C 실행하면 안 돼? 라고 생각할 수 있다. 그런데 모든 일을 끝내는 데 걸리는 시간은 차이가 클 수 있기 때문에, 이런 방식은 비효율적이다. <br> 문제는 I/O이다. 프로그램은 많은 시간을 입출력에 쓴다. 입출력은 단순히 데이터의 입력 및 출력 뿐만 아니라, 호스트와 서버간의 데이터 송수신도 I/O라고 부른다. 당연히 서버 부하 상태에 따라 정말 오랜 시간이 걸릴 수도 있는 것이다. **프로세스가 I/O와 작업을 수행 중이라면, CPU는 아무 것도 못 하고 쉬게 된다.**<br> 
<br>

이 때, CPU는 다른 일을 하고 있도록 하는게 낫지 않을까? 이런 이유 때문에 **멀티 프로세스 기반으로 프로세스들을 처리하는 것이 훨씬 더 효율적이다.** A 프로세스가 I/O에 관련된 일을 할 경우, 운영체제는 스케줄러를 통해 다른 프로세스 B가 실행되도록 해준다. 그러면 A 프로세스가 I/O작업을 하는 중에 B 프로세스도 CPU에서 실행되고 있다. 정말 멋지다.. 결국 실행되어야 할 프로세스가 다수 존재한다면 CPU는 쉴 틈이 없이 바쁘게 되는 것이다.

## 5.4 프로세스 상태 변화
멀티 프로세스는 여러 개의 프로세스들이 돌아가며 실행되기 때문에, 프로세스는 각각 **상태**를 가지고, 그 상태는 시간의 흐름에 따라 변화한다! <br> 상태는 아래 5가지 상태가 존재하고,

1. S
2. Ready
3. Running
4. Blocked
5. E

![process state](https://user-images.githubusercontent.com/71186266/184368496-39f9beb0-c5fb-40c7-b420-b9aba6df8767.png)


그리고 6가지의 상황이 존재한다.
1. S -> Ready
2. Ready -> Running
3. Running -> Ready
4. Running -> Blocked
5. Blocked -> Ready
6. Blocked -> E

- Running은 E 전에 Blocked를 거친다.
- Blocked된 프로세스는 바로 다시 시작할 수 없고 Ready를 거친다.

### 상태 전이 Case
1. **S -> Ready** (S에서 Ready로의 상태 전이)
S는 프로세스가 생성되었음을 의미한다. **프로세스는 생성과 동시에 Ready 상태로 들어간다**. Ready 상태에 있는 프로세스는 CPU에 의해 실행되기를 희망하는 상태이다. 스케줄러에 의해 간택(?)되기를 바라며.. Ready 상태가 된다.
2. **Ready -> Running** (Ready 상태에서 Running 상태로의 전이)
Ready 상태에 있는 프로세스들은 스케줄러에 의해 관리되는 프로세스들이다. **스케줄러는 스케줄러 알고리즘을 기반으로 Ready 상태의 프로세스들 중 하나를 선택해서 CPU에 의해 실행될 수 있도록 한다.** Ready 상태의 프로세스 중 스케줄러에 의해 선택된 프로세스는 Running 상태가 되어 실행되는 것이다.
3. **Running -> Ready**
프로세스에는 그 중요도를 정하는 **Priority(우선순위) 개념이 존재한다.** 그리고 이 우선순위가 깡패다. 예를 들어 B라는 프로세스가 현재 실행 중인데, 갑자기 우선순위가 더 높은 프로세스 A가 실행된다면 (S를 거쳐 Ready 상태가 되었다면,) **스케줄러는 B의 실행을 멈추고, 우선순위가 높은 A를 실행한다.** B는 Ready 상태가 되어서 A가 종료되기만을... 양보해 주기만을..ㅠㅠ 오매불망 기다린다.
4. **Running -> Blocked**
실행중인 프로세스가 실행을 멈추는 상태로 들어가게 되는 것이다. 일반적으로 데이터 입-출력에 관련된 일을 하는 경우 발생한다. **어차피 I/O 작업 중에는 아무 것도 못 하고 있으니까, 그 동안은 다른 프로세스를 실행하고 있는게 맞지 않는가?** 그 시간이 길기도 하니까 이게 맞다. <br> I/O 작업을 진행중인 프로세스는 잠시 내려오게 하고, (Blocked상태가 되게 하고) Ready 상태에 있는 프로세스 중 하나를 대신 실행한다! (Running으로 상태 전이) **완전 효율!**
5. **Blocked -> Ready**
Blocked 상태와 Ready상태의 다른 점은 무엇일까? **바로 스케줄러에 의해 선택될 수 없다는 점이다.** 둘 다 실행중이 아니지만, Blocked에서는 선택되지 않는다. 프로세스를 종료 시킬 경우 Blocked상태를 거쳐 E 상태로 가고, 입-출력 작업이 완료된 프로세스는 다시 Ready 상태가 되어서 스케줄러의 선택을 기다린다!
<br> <br>
Running과 Blocked 상태의 차이를 좀 더 설명하겠다. Running -> Ready는 할 일이 있는데도, 어쩔 수 없이 다른 프로세스에게 실행을 양보하는 상황이고, Blocked 상태는 스케줄러의 관심 밖에 있는 상태다. CPU 연산이 필요 없는 작업들은 굳이 Ready 상태에 있을 필요가 없기 때문에 Blocked로 넘기면 된다. (ex I/O) 이런 작업들이 끝나면 다시 Ready로 넘겨주면 된다. <br>

### 프로세스 상태 전이 시나리오
예를 들어 메일 서버용 PC가 있다고 가정하자. 이 컴퓨터에서 워드를 사용할 것이다. 워드가 더 높은 Priority를 가지고 있고, 메일 서버 업무가 더 낮다. <br> 이런 경우 나는 워드로 문서를 작성할 것이다. 일단 워드가 더 우선순위가 높은 관계로 워드를 실행시키면 워드는 S -> Ready 상태가 되었다가 메일 서버의 자리를 빼앗아 Running이 되고, 메일 서버 업무는 Running -> Ready 상태가 된다. <br> 우리가 문서 작업을 하면서 1초도 쉬지 않고 작업을 하지는 않는다. CPU가 일을 처리하는 속도에 비해 우리의 타이핑 속도는 느리고, 중간에 전화를 하거나, 잠깐 고민을 할 수도 있다. **메일 서버는 이 짧은 틈을 이용해 일을 한다.** <br> 또 이번엔 문서를 저장하려고 한다. 그러면 운영체제는 이 짧은 저장 시간에도 워드를 Blocked상태로 변경하고 메일 서버를 Running 상태로 둔다. <br> 저장이 완료되면 워드는 Ready가 된다. 물론 메일 서버는 계속 Running중이다. 이후, 우선순위가 더 높은 워드가 Ready에 있는 것을 발견하고 다시 실행하여 Running 상태로 전이시킨다. 

## 5.5 Context Switching (컨텍스트 스위칭) - 멀티 프로세싱의 단점
이제까지는 멀티 프로세스 운영체제의 장점만 보았다. 하지만 단점도 존재한다. 실행 중인 프로세스를 변경시킨다는 것은 시스템에 부하를 가져다주기도 한다. **이유는 레지스터에 있다.** <br> 어떤 프로세스가 실행 될 때, CPU 내의 레지스터들에는 프로세스와 관련된 데이터들로 채워진다고 배웠다. <br> 그런데 중간에 현재 실행중인 프로세스를 치우고, 다른 프로세스를 Running으로 둔다면? 레지스터에 있는 데이터들을 잠시 치워둬야 할 것이다. 나중에 다시 실행할 가능성이 있으므로, 데이터를 잘 보존해 두어야 할 것이다. (당연히 메모리 어딘가) <br> 이런 작업은 딱 봐도 부하가 되는 작업이지 않는가 이를 **컨텍스트 스위칭**이라고 부른다. <br> 당연하게도, 레지스터의 개수와 프로세스별로 관리되어야 할 데이터 종류가 많을 수록 이 부담은 커진다. **이것이, 컨텍스트 스위칭 작업으로 인한 부하가 바로 멀티 프로세스 운영체제의 단점이다.** <br> <br> 고려할 사항이 늘었다. 프로그램의 실행 과정에서 발생하는 I/O 때문에 멀티 프로세스 기반의 프로그램 실행은 분명 성능 향상에 도움이 된다. 그러나 Context Switching이 미치는 영향까지 고려하면 오히려 성능이 저하될 수 있다. <br> 어떻게 구현해 주는 것이 정답인가? **이것에 답은 없다.** **구현하는 프로그램의 성격에 따라 달리해줘야 하는 부분이다.** 공식화 할 수 없는 부분이고, 다양한 프로그램을 구현해나가면서, 다양한 분야를 공부해가며 조금씩 알아가야 한다고 한다.

## 5.6 프로세스의 생성 예제
