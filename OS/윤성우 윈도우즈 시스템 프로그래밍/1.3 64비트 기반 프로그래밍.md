# 3. 64 bit 기반 프로그래밍
CPU는 I/O 버스를 통해서 데이터를 외부로 전송하기도 하고, 수신하기도 한다. **이 떄 한 번에 전송 및 수신할 수 있는 데이터의 크기에 따라 32bit 시스템과 64bit 시스템으로 나뉜다.** 한 번에 처리할 수 있는 데이터의 양에 따라 구분 짓는 것이다.

## 2. 프로그래머에게 64 bit 컴퓨터가 가지는 의미
그래서 64 bit 컴퓨터는 어떤 의미를 가질까? <br>
프로그래머 입장에서 표현할 수 있는 주소값의 범위가 넓으면 넓을수록 좋다. 메모리 공간만 충분하다면, **주소값의 범위가 넓은 만큼, 더 넓은 메모리 공간을 활용할 수 있기 때문이다.** 따라서 주소값 표현을 위해 활용할 비트 수는 32비트 컴퓨터에서는 32비트, 64비트 컴퓨터에서는 64비트가 최선의 선택이다. <br> **한번에 처리할 수 있는 데이터의 크기 만큼의 비트로 주소값을 표현하면, 주소값의 이동 및 연산이 한 번에 이루어지게 된다!** 표현 가능한 주소의 범위가 넓은 것은 덤이다! <br> 결론: `한번에 처리 가능한 데이터의 크기 == 주소값 표현에 사용할 비트 수`인 경우가 최적.

## 2.1 프로그램 구현 관점에서의 WIN32 vs WIN64
Window 32비트 환경에서는 int, long, 포인터가 전부 4 byte로 표현 된다. 64비트 환경에서는 호환성을 위해 int, long은 그대로 4 byte이고, **포인터만 8byte로 표현된다.** 따라서, **이전 32비트에서 허용되었던, 포인터를 int로 형변환하기는 64 비트에서는 하면 안 된다.** 데이터가 손실될 수 있다. 이러한 데이터 모델을 LLP64라고 부른다. unix는 LP64를 따른다.
- Window: LLP64, UNIX: LP64

## 2.2 Window 스타일 자료형
**유니코드와 아스키코드를 공통으로 지원하도록 예제를 작성하되, 64비트 시스템에서 새롭게 정의된 자료형은 가급적 사용하지 말라.**

## 2.3 Polymorphic 자료형
MS에서는 WIN64로 넘어가며 Polymorphic 자료형을 정의하고 있다. **32비트 시스템과 64비트 시스템의 호환성을 높히기 위해 정의된 자료형으로, 실행되는 시스템에 따라 다른 자료형이 된다.** <br> Polymorphic 자료형 UINT_PTR, ULONG_PTR은 실행하는 환경에 따라 다르게 선언된다. 32비트 시스템에서는 32비트로, 64비트 시스템에서는 64비트로 선언된다.

# 3. 오류의 확인
Windows 시스템 함수들은 오류가 발생한 경우 **NULL**을 반환한다. 그리고 `GetLastError` 함수 호출을 통해 오류의 원인을 확인할 수 있다. 오류가 발생했을 떄, 바로 이어서 `GetLastError` 함수를 호출하면, 오류의 원인에 해당하는 에러코드를 얻을 수 있다. <br> 해당 에러 코드는 MSDN을 참조하면 그 의미를 알 수 있고, 에러가 없을 경우, 에러코드 0을 반환한다. <br> <br>

Windows 시스템 함수가 호출될 때마다, `GetLastError` 함수의 호출 값은 변경된다. 쉽게 생각하면, 가장 최근 호출된 Windows 시스템 함수의 에러코드를 반환하는 함수인 것이다. 그래서 원인을 파악하기 위해서는 에러가 발생한 함수의 호출 직후 `GetLastError`가 호출 되어야 한다.
