# 1. 컴퓨터 구조와 프로그래밍 모델
## 1-1. 컴퓨터 구조 I
**시스템 프로그래밍**이란 무엇일까? "컴퓨터 시스템을 동작시키는 프로그램으로" Winow와 UNIX와 같은 OS들이 시스템 프로그램의 범주에 속한다. 이런 소프트웨어들은 사용자들이 하드웨어에 대해 깊히 알지 않고도 컴퓨터를 쉽게 사용할 수 있도록 도와줍니다. **하드웨어를 컨트롤 한다면, 어셈블리나 C 처럼 직접적으로 컨트롤 하지 않아도, 시스템 프로그래밍이라고 할 수 있다.** <br> <br> 

이러한 Windows 시스템 프로그래밍을 이해하기 위해서는 MSDN의 함수들이 제공하는 기능들을 이해하면 된다. 그러나, 이에는 운영체제에 대한 이해가 필요하고, 운영체제에 대한 이해에는 컴퓨터 구조에 대한 이해가 필요하다. 따라서 일단 컴퓨터 하트웨어에 대한 이해 부터 출발해야한다. <br>

이러한 컴퓨터 구조와 운영체제를 이해하게 되면, 더 효율적인 프로그램을 구현하는 것이 가능하다. 즉, 더 빠르고, 메모리를 효율적으로 사용하는 프로그래밍을 구현해낼 수 있다.

### 1. 컴퓨터 시스템의 Main Components
1. 컴퓨터 구조 (Computer Architecture)
- CPU
- 캐쉬 (Cache)
2. 운영체제 (Operating System)
- 메인 메모리 (Main Memory - RAM)
- 하드디스크 (Hard Disk)
![운영체제](https://user-images.githubusercontent.com/71186266/181134639-daa99e2e-d637-4da3-931e-b7596d3ce95b.png)
**CPU <-> 캐쉬 <-> 메인 메모리 <-> 하드디스크**


### 2. 컴퓨터 하드웨어의 구성

![하드웨어 구성](https://user-images.githubusercontent.com/71186266/181134640-b6b87345-279b-4a43-97a3-d2c82a68a5c5.png)

1. **CPU** 
**중앙 처리 장치**. 컴퓨터의 머리에 해당한다. 다음 소단원에서 자세히.
2. **메인 메모리 (Main Memory - RAM)** 
**RAM이라는 저장장치로 구성된 메인 메모리.** **컴파일이 완료된 코드가 올라가서 실행되는 영역이다.** 프로그램 실행을 위해 존재하는 메모리라고 생각하면 된다.
3. **입-출력 버스 (Input/Output Bus)**
데이터를 주고 받기 위해 사용되는 경로. 전달하는 데이터의 종류에 따라 Address Bus, Data Bus, Control Bus 세 가지로 나뉜다. **대부분의 것들이 서로 Bus로 연결되어 있다.** 데이터의 고속도로와도 같다.

### 3. CPU 자세히 들여보기
위의 그림에 들어있는 요소들에 대한 설명
1. **ALU (Arithmetic Logic Unit)**
 **연산이 수행되는 곳이 바로 ALU다!** **산술연산과 논리연산의 두 가지 연산을 통해 통해 실제 연산들을 처리한다.** 아주 복잡한 프로그램도 CPU 입장에서는 이 두 연산의 형태를 띌 뿐이다.
2. **컨트롤 유닛 (Control Unit)**
이진 코드로 되어있는 32 bit 명령어가 있다고 생각해보자. 예를 들어
`10011010 00011010 10011110 10010011`가 있을 때, **ALU는 어떻게 이 명령어를 이해할까?** ALU는 이해하기 보다는 연산만 할 줄 아는 단순한 요소이다. **ALU에게 명령어를 해석해 주는 구성 요소가 바로 컨트롤 유닛(Control Unit)이다.** 컨트롤 유닛에서 명령어를 해석한 다음, ALU에게 연산 신호를 보내준다. **CPU의 총 사령관과도 같은 역할을 한다.** 
3. **Register Set (CPU 내부 레지스터들)**
각종 피연산자나, 잠시 저장해야할 요소는 CPU 안의 어디에 저장되는가? 바로 CPU 안에 Register라는 아주 작은 메모리이다. CPU 내부의 여러 Register가 16, 32, 64 비트의 2진 데이터를 임시적으로 저장한다. 레지스터들은 각각의 용도가 정해져 있으며, CPU의 연산을 위해 필수적이다. 
4. **버스 인터페이스 (Bus Interface)**
각 요소들이 데이터를 주고 받을 때 이용하는 것이 I/O Bus이다. I/O Bus는 그 통신방식을 이해하고 있어야만 이용할 수 있는데 **버스 인터페이스(Bus Interface)가 버스의 프로토콜 혹은 통신방식으로 알고 있다.** 따라서, CPU는 버스 인터페이스를 통해, CPU 내부에 저장되어 있는 데이터를 주고 받는다!
5. **클럭 신호 (Clock Pulse)**
클럭 신호는 CPU를 구성 하고 있는 요소는 아니다. 하지만 Timing을 제공하기 위해 필요한 중요한 의미를 갖는다. 컴퓨터의 오실레이터(클럭 발생기)가 주기적으로 클럭을 발생시키고, 그 클럭에 맞춰 CPU가 일을 하는 것이다. 예를 들어 1.6Mhz CPU는 1초에 1백 6십만번의 연산을 할 수 있다. <br> 컴퓨터의 여러 요소들은 서로 다른 수행 시간을 가지고 있는데, 이들간의 제대로 된 동기화를 위해 가장 느린 수행 시간을 가진 요소에 맞춰, 데이터를 이동시키면 안전하게 동기화를 해줄 수 있다. <br> 큰 공장에서 분업을 하는데, 한 쪽만 속도가 빨라서 물건을 빨리 넘겨준다면, 다음 파트에서는 고생 고생을 하게 되므로, 가장 느린 파트에 박자를 맞춰 주는 것이 좋을 것이다. 이와 같은 원리이다. 
<br> 코어들을 직접 다루는 개발을 하면, 클럭을 프로그램 코드 상에서도 조절 할 수가 있다. 너무 올려서 발생하는 것이 오버 클럭킹이다..

### 4. 프로그램의 실행 과정
폰 노이만 구조는, 프로그램이 컴퓨터 내부에 저장되는 구조를 말 한다. 다른 말로는 `Stored Program Concept`이라고도 불리운다.

### 실행 파일 생성 과정
**전처리기 -> 컴파일러 -> 어셈블러 -> 링커**
1. **전처리기:** 지시자의 지시에 따라 소스코드를 적절히 변경함. `#include`, `#define`과 같은 지시자들이 있음.
2. **컴파일러로 번역하기:** 소스코드를 어셈블리 코드로 번역해준다.
3. **어셈블러로 바이너리 코드 생성:** 어셈블러를 통해 어셈블리어로 작성 되어 있는 코드를 **이진수로 이루어진 바이너리 코드로 변환 시켜줍니다.** 
4. **링커로 연결하고 결합하기:** 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는 역할을 한다. **이 작업을 마치면 실제로 실행이 가능한 실행파일이 생성된다. (바이너리 코드로 이루어진!)**

### 바이너리 코드와 폰 노이만 구조로 프로그램 실행 설명
![프로그램 실행과정](https://user-images.githubusercontent.com/71186266/181140620-117bb455-d1ae-4677-be1a-978afd7e717c.png)

링커로 연결을 마친 뒤 생성된 실행파일은 메모리에 로드됩니다. 앞서 메인 메모리에서 실제 프로그램을 실행한다는 설명과 일치합니다. <br> 메모리에 명령어들이 쌓이면, **Fatch를 통해 명령어들을 CPU로 보냅니다.** 이후 CPU의 컨트롤 유닛에서 명령어를 **Decode 과정을 통해 해석합니다.** 그렇게 **해석한 명령어를 ALU에서 실행하는 과정을 Execution이라고 부릅니다.**

- **단계 1. Fetch:** 메인 메모리 RAM 상에 존재하는 명령어를 **BUS와 버스 인터페이스를 통해** CPU로 가져옴. **명령어를 가져온 다음 IR(Instruction Regiser)라고 불리는 레지스터에 저장함**
- **단계 2. Decode:** CPU의 컨트롤 유닛이 명령어를 분석하는 단계.
- **단계 3. Execution:** 해석된 명령어 대로 CPU의 ALU가 연산을 수행하는 단계  

다시, **BUS Interface는 I/O Bus를 통해 데이터를 주고 받기 위해 BUS의 통신 방식에 맞게 데이터 입-출력을 돕는 인터페이스 장치이다.** 해당 인터페이스 장치를 컨트롤러, 혹은 어댑터(Adapter)라고 부른다.
