# 4. 컴퓨터 구조 2
컴퓨터 구조에 대한 근본적인 이해는, 프로세스와 쓰레드를 이해하는데 큰 도움이 된다! 컴퓨터 구조를 더 깊게 이해하기 위해 가상의 컴퓨터를 디자인해보자! 특히 CPU를 디자인 해볼 것이다.

<br> 시스템 프로그래머는 CPU의 특성을 잘 알고 있어야한다. 이 때, 프로그래머가 CPU를 바라보는 관점의 대부분이 **레지스터**에 집중된다. 나머지 ALU나 컨트롤 유닛은 이미 있다고 가정한다. 레지스터를 잘 이해하는 것이 CPU를 이해하는 것이고, 이것이 컴퓨터 구조를 잘 이해하고 있는 것이다.

## 4.1 레지스터 디자인
레지스터를 디자인 함에 있어서, 다음 3가지 요소가 결정해야할 중요 요소이다.
1. **레지스터를 몇 비트로 구성할 것인가?**
2. **레지스터를 몇 개 정도로 구성할 것인가?**
3. **레지스터 각각을 어떤 용도로 사용할 것인가?**
위 세가지 요소가 레지스터 디자인의 핵심이다. **이 책에서는 16비트 레지스터를 갯수 8개로 만들기로 했다.**
<br> <br>
앞선 챕터들에서 봤듯이, 이런 경우 주소 할당을 위해서는 4개의 레지스터를 쓰는 것이 좋을 것이다. 왜냐하면 16비트로 맞춰주면 입출력이 한번에 이루어지기 때문이다. 그래서 r0~r3 까지는 주소 할당을 위해 쓰고, 나머지 4개는 특수 레지스터로 둔다.
- r4: ir (instuction register - 다음 번 실행 명령어를 미리 준비)
- r5: sp (stack pointer)
- r6: lr (link register)
- r7: pc (program counter)

## 4.2 명령어 디자인
**디자인한 레지스터를 기반으로, CPU에 일을 시키기 위한 명령어 구조 및 명령어의 종류를 디자인 할 수 있다.** CPU의 구성 형태에 따라, (레지스터의 구성형태) 명령어의 구조가 달라지기 때문이다. 따라서, 어셈블리 언어로 구현된 프로그램들은 구조가 다른 CPU로의 이식이 불가능하다

### 4.2.1 명령어를 몇 비트로 구성할 것인가?
앞에서 레지스터 크기를 16비트로 결정하였기 때문에, 같은 16비트로 구성하는 것이 좋다. **레지스터 크기와 명령어의 크기는 동일한 편이 좋다.** <br> <br>

16비트를 어떻게 활용하는 것이 좋을까? 더하기 명령어를 예시로 들겠다.
```markdown
ex) 레지스터 r1의 값과 숫자 7을 더해서 레지스터 r2에 저장해라.
```
위와 같은 명령어가 있을 때, 저 한 줄을 통째로 16비트에 어떻게 넣는 것이 좋을까? <br> 일단, 16비트가 담고 있어야 할 정보는 4가지 이다. <br>

`연산자`, `저장소`, `피연산자 1, 2` -> `더하기`, `레지스터 r1`, `레지스터 r2`, `숫자 7` <br> 그러므로 16비트를 쪼게서 각각 역할을 나눠준다.
ex)
- 연산자: 3비트 (-> 더하기)
- 저장소: 3비트 (-> 레지스터 r2)
- 피연산자1: 4비트 (-> 레지스터 r1)
- 피연산자2: 4비트 (-> 숫자 7)
- 남게되는 맨 앞 2비트는 다른 곳에 쓰일 수 있으니, 일단 keep

이런 식으로 해준다면, **8개의 연산자**를 지정할 수 있다. 레지스터는 어차피 8개이니까 저장소는 3비트면 충분하다. 피연산자는 4비트 밖에 안 되는데.. 심지어 피연산자1을 보면 레지스터고, 피연산자2는 숫자이다. 이 두가지를 구분하기 위해 첫 비트를 레지스터와 숫자의 구분 용도로 주어야한다. 즉, 8개의 숫자만 할당이 가능하다. <br> 

이런 방식이면 16비트 안에 여러 정보들을 한 큐에 넣어줄 수가 있다. 그리고 어셈블리 프로그래밍을 할 때 사용되는 Symbol도 결정해준다.
|연산|심볼|2진코드|
|:---:|:---:|:---:|
|덧셈|ADD|001|
|뺄셈|SUB|010|
|곱셈|MUL|011|
|나눗셈|DIV|100|

<br>

|레지스터 심볼|2진 코드|
|:---:|:---:|
|r0|000|
|r1|001|
|r2|010|
|r3|011|
|r4, ir|100|
|r5, sp|101|
|r6, lr|110|
|r7, pc|111|

이렇게 만든 명령어를 컨트롤 유닛으로 전달하면, 컨트롤 유닛은 CPU의 각 모듈에 명령어를 내리게 된다. 그리고 각 CPU 모듈은 이 명령어에 따라 적절한 연산을 수행한다. <br> 명령어의 형태에 따라 명령어를 해석하는 컨트롤 유닛의 구조가 결정된다. 컨트롤 유닛은 명령어의 구성 및 해석방법을 정확히 알고 있어야만 하고, 이 형태에 때라 논리회로를 디자인 해줘야 해석을 하지 않겠는가. <br> <br>

디자인을 해보니 몇 가지 제약 사항이 보인다. 예를 들면 연산자 위치는 왜 꼭 메모리가 아닌 레지스터에 저장하는가? (실제 범용 RISC의 특징이기도 함.) 이러한 제약 사항들은 깊히 이해하기에 조금 깊은 내용이므로 다음 문장 정도만 받아들여라 -> **"이런 제약사항들은 CPU의 성능이나 비용 등 종합적인 측면을 모두 고려한 가운데서 등장한 사항들이다. 일단은 그냥 받아들여라"** 어셈블리 언어는 high-level 언어들과 달리 하드웨어의 성능과 그 향상에 깊은 연관이 있기 때문에, 여러 제약사항들이 존재하고 일단은 합리적인 결과임을 이해해라. 

## 4.3 LOAD & STORE 명령어 디자인
이제 메인 메모리로 부터 데이터를 읽어오고 저장하는 LOAD, STORE 명령어를 디자인 하며, **레지스터의 필요성을 느껴보자.**

### 4.3.1 Register의 필요성?
위에서 언급한 것과 같은 디자인은, 피연산자로 `메모리`를 지정할 수 없다. 단지 `레지스터`를 지정할 수 있을 뿐이다. 따라서 메모리와 레지스터간의 정보 교환이 가능해야, 메모리에 저장된 값들을 이용한 연산이 가능하지 않겠는가? <br> 이를 위한 명령어가 LOAD와 STORE가 되겠다.

### 4.3.2 LOAD & STORE
이전 사칙연산과 달리, 위 명령어는 피연산자가 2개면 된다. **레지스터, 그리고 메모리 정보** 따라서 비트를 줄 때, **레지스터엔 3 bit, 메모리 정보엔 8 bit나 줄 수가 있다.** (명령어엔 3 비트를 썼으니, 나머지 2 비트는 여기서도 예약으로 남겨둘 수가 있다.) 
```
LOAD r3, 0x07
```
명령어다. 위와 같은 명령어가 들어오면, **0x07에 있는 정보를 불러와서 레지스터 r3에 저장하라는 뜻으로 이해하면 된다.** LOAD에는 110을 줬다.
```
00/110/011/00000111
```
STORE에는 111을 줬다. 목적지와, 데이터 존재 위치 정보를 주면 될 것 이다.
```
STORE r2, 0x08
00/111/010/00001000
```
위와 같은 모습이 될 것이다. 그럼 더하기 연산을 보이겠다.
```
// (연산 예시)
int a = 10;   // 0x10번지에 할당됨.
int b = 20;   // 0x20번지에 할당됨.
int c = 0;   // 0x30번지에 할당됨.
c = a + b;

// (명령어 예시)
LOAD r1, 0x10
LOAD r2, 0x20
ADD r3, r1, r2
STORE r3, 0x30

```

STORE와 LOAD명령어를 만들어 보며, 좀 더 생각해 보면 명령어 형태에 따라 컨트롤 유닛이 디자인 된다는 말의 의미를 명확히 이해할 수 있는데, 컨트롤 유닛이 앞에서 부터 명령어를 읽어내다가, **사칙연산 명령어가 오면 피연산자가 3개임을 알고, LOAD STORE 명령어가 오면 피연산자가 2개임을 알게 되는 방식이다.**

## 4.4 Direct & Indirect MODE
이제까지 명령어를 디자인 할 때, 16비트 안에 여러 정보들을 담도록 디자인했다. 분명 좋은 방법이지만, 문제점이 있다. 바로 **표현 데이터의 크기에 제한이 있다는 점이다.** 무슨 말인가 하면, LOAD & STORE를 만들 때 확인했던 것 처럼, 메모리 정보를 표현하는 비트 수가 8비트 밖에 없기 때문이다. <br> 만약 주소가 0x0100인 곳을 가르키고 싶다면? 그냥 불가능 하다.. 8 비트로는 0x00ff까지만 표현이 가능하기 때문이다. **이래서 등장한 것이 바로 Indirect Mode이다.** 

## Indirect Mode!
Direct Mode는 이제까지 해왔던 것 처럼, 메모리 주소를 기입하는 칸에 그대로 메모리 주소를 기입한다. **Indirect Mode는 마치 포인터 처럼, 원하는 목적지의 주소값을 저장하고 있는 메모리의 주소를 기입한다.** <br> <br> 
**Direct Mode와의 구분은 어떻게 할까?** 명령어에서 이를 구분하기 위해, 항상 **안 쓰던 맨 앞 두 비트**를 이용하자! 이 두 비트에 00외의 어떤 값이든 넣어서 구분을 하고, 심볼의 구분은 `[]`로 메모리 주소 값을 감싸주는 식으로 한다. <br> <br>

LOAD 명령어로 0x0100번지에 저장된 데이터를 r1으로 옮기는 예시는 아래와 같다.

```
// 일단 256이라는 숫자 얻어내기
// 숫자도 255까지만 표현이 가능하므로 아래와 같이 256을 얻어낸다.
MUL r1, 4, 4
MUL r2, 4, 4
MUL r3, r1, r2

// 가져오기
// 1. STORE로 r3에 저장되어 있는 값을 메인 메모리 0x0030에 옮긴다.
// 2. 0x0030을 Indirect Mode로 참조한다!
STORE r3, 0x0030
LOAD r2, [0x0030]

// 이렇게 하면 0x0100에 있는 값을 r2로 가져올 수 있게 된다!
```

