# 4. 컴퓨터 구조 2
컴퓨터 구조에 대한 근본적인 이해는, 프로세스와 쓰레드를 이해하는데 큰 도움이 된다! 컴퓨터 구조를 더 깊게 이해하기 위해 가상의 컴퓨터를 디자인해보자! 특히 CPU를 디자인 해볼 것이다.

<br> 시스템 프로그래머는 CPU의 특성을 잘 알고 있어야한다. 이 때, 프로그래머가 CPU를 바라보는 관점의 대부분이 **레지스터**에 집중된다. 나머지 ALU나 컨트롤 유닛은 이미 있다고 가정한다. 레지스터를 잘 이해하는 것이 CPU를 이해하는 것이고, 이것이 컴퓨터 구조를 잘 이해하고 있는 것이다.

## 4.1 레지스터 디자인
레지스터를 디자인 함에 있어서, 다음 3가지 요소가 결정해야할 중요 요소이다.
1. **레지스터를 몇 비트로 구성할 것인가?**
2. **레지스터를 몇 개 정도로 구성할 것인가?**
3. **레지스터 각각을 어떤 용도로 사용할 것인가?**
위 세가지 요소가 레지스터 디자인의 핵심이다. **이 책에서는 16비트 레지스터를 갯수 8개로 만들기로 했다.**
<br> <br>
앞선 챕터들에서 봤듯이, 이런 경우 주소 할당을 위해서는 4개의 레지스터를 쓰는 것이 좋을 것이다. 왜냐하면 16비트로 맞춰주면 입출력이 한번에 이루어지기 때문이다. 그래서 r0~r3 까지는 주소 할당을 위해 쓰고, 나머지 4개는 특수 레지스터로 둔다.
- r4: ir (instuction register)
- r5: sp (stack pointer)
- r6: lr (link register)
- r7: pc (program counter)

## 4.2 명령어 디자인
**디자인한 레지스터를 기반으로, CPU에 일을 시키기 위한 명령어 구조 및 명령어의 종류를 디자인 할 수 있다.** CPU의 구성 형태에 따라, (레지스터의 구성형태) 명령어의 구조가 달라지기 때문이다. 따라서, 어셈블리 언어로 구현된 프로그램들은 구조가 다른 CPU로의 이식이 불가능하다

### 4.2.1 명령어를 몇 비트로 구성할 것인가?
앞에서 레지스터 크기를 16비트로 결정하였기 때문에, 같은 16비트로 구성하는 것이 좋다. **레지스터 크기와 명령어의 크기는 동일한 편이 좋다.** <br> <br>

16비트를 어떻게 활용하는 것이 좋을까? 더하기 명령어를 예시로 들겠다.
```markdown
ex) 레지스터 r1의 값과 숫자 7을 더해서 레지스터 r2에 저장해라.
```
위와 같은 명령어가 있을 때, 저 한 줄을 통째로 16비트에 어떻게 넣는 것이 좋을까? <br> 일단, 16비트가 담고 있어야 할 정보는 4가지 이다. <br>

`연산자`, `저장소`, `피연산자 1, 2` -> `더하기`, `레지스터 r1`, `레지스터 r2`, `숫자 7` <br> 그러므로 16비트를 쪼게서 각각 역할을 나눠준다.
ex)
- 연산자: 3비트 (-> 더하기)
- 저장소: 3비트 (-> 레지스터 r2)
- 피연산자1: 4비트 (-> 레지스터 r1)
- 피연산자2: 4비트 (-> 숫자 7)
- 남게되는 맨 앞 2비트는 다른 곳에 쓰일 수 있으니, 일단 keep

이런 식으로 해준다면, **8개의 연산자**를 지정할 수 있다. 레지스터는 어차피 8개이니까 저장소는 3비트면 충분하다. 피연산자는 4비트 밖에 안 되는데.. 심지어 피연산자1을 보면 레지스터고, 피연산자2는 숫자이다. 이 두가지를 구분하기 위해 첫 비트를 레지스터와 숫자의 구분 용도로 주어야한다. 즉, 8개의 숫자만 할당이 가능하다. <br> 

이런 방식이면 16비트 안에 여러 정보들을 한 큐에 넣어줄 수가 있다. 그리고 어셈블리 프로그래밍을 할 때 사용되는 Symbol도 결정해준다.
|연산|심볼|2진코드|
|:---:|:---:|:---:|
|덧셈|ADD|001|
|뺄셈|SUB|010|
|곱셈|MUL|011|
|나눗셈|DIV|100|

<br>

|레지스터 심볼|2진 코드|
|:---:|:---:|
|r0|000|
|r1|001|
|r2|010|
|r3|011|
|r4, ir|100|
|r5, sp|101|
|r6, lr|110|
|r7, pc|111|
