# 테스트와 아키텍처
테스트는 품질 보증을 위한 도구이기도 하지만, 설계를 위한 도구이기도 하다. <br>
테스트와 설계는 상호 보완 단계. 

결국 테스트하기 쉬운 코드가 좋은 코드일 확률이 높다.
테스트하기 어렵다면 잘못된 아키텍쳐일 가능성이 높다.

- 아키텍처 : 어떤 비즈니스 문제를 해결하기 위해 준수해야 하는 제약.
결국 제약이기 때문에 꼭 필요하지 않다면 불편할 수도 있다.

아키텍처는 종착지가 아니라 여정이다. 
고정된 산출물 아니라 계속된 탐구 과정에 더 가까움을 이해해야 한다.

## 1. 레이어드 아키텍처의 단점
레이어드 아키텍처는 우리가 처음 개발을 배울 때 배우는 구조로, <Br>
유사한 기능들을 같은 계층으로 묶어 관리한다. <br>
이런 레이어드 아키텍처를 사용하면 도메인이 죽고, 많은 유연성을 잃게 된다. <Br> 
단점들을 좀 더 자세하게 나누어 살펴보자. <br>

### 1.1 소형테스트의 어려움
이런 레이어드 아키텍처에서의 테스트는 Mockito와 같은 외부 라이브러리나 <br> 
h2와 같은 인메모리 레포지토리의 도움이 필요했다. <Br>
도메인의 코드들이 순수한 자바 코드로 이루어져 있지 않기 떄문이 크다. <Br>


### 1.2 Fat Service
뚱뚱한 서비스로 도메인이 죽어버린다. <br>
서비스가 온갖 작업을 주도하게 되며 전부 처리하는 신 같은 존재가 된다. <br>
자연스럽게 도메인은 죽어버리는데, 빈약한 도메인이 완성된다.

### 1.3 DB 위주의 사고를 유도한다
레이어드 아키텍처는 Repository와 같은 영속성 객체를 바로 사용하면서,  
개발자들이 엔티티와 영속성 레이어를 어떻게 만들지 먼저 고민하게 된다. <br>
도메인과 Use Case에 집중하기 보단 먼저 구현체에 대해 고민하게 된다. <Br>

물론 하향식으로 고민해도 프레임워크에 대해 먼저 생각하게 된다.

**소중한 의존성에 대한 고민 기회를 잃어버리게 한다! <Br> 구체적인 구현은 많은 유연성과 확장성을 놓치게 만든다.** <br>


### 1.4 동시 작업이 어렵다.
레포지토리 -> 서비스 -> 컨트롤러 순으로 구현을 고민하고, <br> 
전 단계가 확보 되어 다음 단계를 구현할 수 있기 때문에 **동시 작업이 어려워진다.** <br>
소중한 인적 자원이 낭비되며, <Br>
한 기능을 한명이 도맡아 처리하게 됨으로써, 소중한 '함께' 고민하기 기회를 날리게 된다.


# 2. 아키텍트

## 2.1 아키텍트의 목표
레이어드 아키텍처는 언급한 대로 여러 단점들이 존재한다. <Br>
OOP의 목적은 '변경하기 쉬움'인데, 점점 그 목표와 멀어지게 만든다. <Br>
그렇다면 우리가 아키텍트를 통해 진정으로 지향해야 하는 목표는 무엇일까? <Br>


### 2.1.1 큰 정책을 만들고 세부사항을 미루는 시스템 개발 
일단, 구체적인 DB, 서버, REST, 의존성 주입 등의 고민에 빠질 것이 아니라,
소프트웨어로 해결한 도메인에 먼저 집중해야 한다. <Br>
아키텍트를 통해 큰 정책을 미리 만들고, <br>
세부사항에 해당하는 구체적인 사항들.. DB, 서버, REST, 의존성 주입 
그러니까, JPA, Nginx, REST API, Spring 등을 나중에 고민할 수 있게 된다.

### 2.2.2 동시 작업 가능으로 개발 인적 자원 절감
좋은 아키텍처를 통해 인적 자원을 절감할 수 있다. <Br>
그러려면 동시 작업이 가능해야 하는데, 이는 관심사를 분리하면서 가능해진다. <Br>
그럼 관심사는 어떻게 분리할 것인가? 하면 경계를 나누면 된다!! <br>
의존성 역전은 대표적인 경계를 나누는 방법이다.

1. 의존성 역전을 통해 경계를 나눈다
2. 관심사를 분리할 수 있다
3. 동시 작업이 가능하다
4. 인적 자원이 절감된다!


## 2.2 의존성 역전과 포트-어뎁터 패턴
의존성 역전으로 관심사를 분리하는 구체적인 패턴을 살펴보자. <br>

결국, <Br>
**관심사를 분리하고 싶다** <Br>
-> 고립시키고 싶다 <Br>
-> 서로에게 영향을 받고 싶지 않다 <br>
-> **포트-어뎁터 패턴!!**

![image](https://github.com/binary-ho/TIL-public/assets/71186266/ba209af1-9843-4f14-99bd-9883d591c09c)


하나의 포트엔 규격만 맞으면 어떤 어뎁터도 꽂을 수 있다. <br>
220V 규격 포트엔 규격에 맞는 어떤 전자제품이든 꽂을 수 있는 것과 같다. <br>
인터페이스라는 포트에다가 필요한 어댑터를 꽂아주는 느낌으로 의존성을 역전하는 패턴을  <br>
포트와 어뎁터 패턴이라고 한다. <br>

### Input & Output Adapter
포트에 입력을 넣는 쪽도, 받아보는 쪽도 어뎁터라고 볼 수 있다. <br>
이에 어뎁터와 Port를 Input과 Output으로 구분할 수 있는데, <Br>
인터페이스를 통해 명령을 입력하는 쪽을 Input Adapter & Input Port <br>
인터페이스의 명령을 수행해서 출력하는 쪽을 Output Adapter & Output Port라고 부른다.

## 3. 헥사고날 아키텍처

결국 레이어드 아키텍처를 계선하면 아래와 같은 그림으로 나타낼 수 있다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/518c1a89-3fea-4552-82d2-396d738de369)

이때, 앞서 언급한 포트와 어뎁터 개념을 적용하면,

![image](https://github.com/binary-ho/TIL-public/assets/71186266/f3f27b2d-1112-4c63-b613-3264dad57747)

위와 같은 그림이 된다. 이제 사실상 계층의 의미는 없어진다.

여기서 Input Adapter와 Output Adapter를 잡아 쭉 늘리면 아래와 같은 그림이 된다. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/7f46157f-4e2d-4624-80ae-a06640c13164)

이것이 헥사고날 아키텍처이다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/45f52d90-d8bc-464f-95e5-c2f1d7c809a1)

<br>

![image](https://github.com/binary-ho/TIL-public/assets/71186266/c7e95549-fe22-43cb-a7a8-f08921d1ef8b)

## 3.1 핵사고날 아키텍처의 장점

1. 외부에서 도메인으로 향하는 방향이 단방향으로 유지된다.
따라서, 도메인은 고립되고, 순수해진다.
2. 외부 세계는 관심없어지고, 소프트웨어가 오직 도메인에 충실하는 것을 돕는다.
본질만 남기고 테스트하기 어려운 부분을 분리하는 것을 돕는데,  <br> 
Controller나 RepositoryImpl등 도메인과 결합되선 안되고, 테스트 하기 어려운 부분을"Humble" 이라고 부른다. <Br>
본질과 험블을 구분하는 능력은, 본질을 고민하는 능력을 키워줍니다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/2318f5ce-0d49-4216-af8d-0aa37bd8bead)
![image](https://github.com/binary-ho/TIL-public/assets/71186266/8f242add-a1a1-4884-bad1-6ab2311d0f7a)

## 3.2 어뎁터의 역할

### Input Adapter
1. HTTP 요청을 자바 객체로 매핑한다 -> **Spring**
2. 권한을 검사한다 -> **Spring Security**
3. 입력 유효성을 검증한다 -> **Spring @Valid**
4. 입력을 Use Case의 입력 모델로 매핑한다
5. Use Case를 호출한다
6. Use Case의 출력을 HTTP로 매핑한다
7. HTTP 응답을 반환한다. -> **Spring**

Use Case 입력 모델에서 했던 유효성 검증을 똑같이 웹 어댑터에서도 구현할 필요는 없지만, <Br>
**웹 어뎁터의 입력 모델을 Use Case의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.** <Br>

### Output Adapter
1. 입력을 받는다
2. 입력을 DB 포맷으로 매핑한다.
3. 입력을 DB로 보낸다.
4. DB 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

자바 프로젝트에선 DB와 통신할 때 일반적으로 JPA를 사용하기 떄문에 <br>
입력 모델을 데이터베이스 테이블 구조를 반영한 JPA 객체로 매핑할 것이다. <Br>
맥락에 따라 입력 모델을 JPA 엔티티로 매핑하는 것이 들이는 노력에 비해 얻는 것이 많지 않을 일이 될 수도 있다. <br>
어찌됐건 핵심은 **영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않아야 한다는 것이다.**

### Use Case
Use Case는 핵사고날에서는 Input Port, <br>
앱에선 Service Interface, <br>
클린 아키텍처에선 Use Case라고 부른다.  <br>
우리는 다른 것에 집중하는 경우가 많은데, 결국 Use Case와 도메인에 집중하는게 핵심이다.
예를 들어 TODO 앱을 부를 때, TODO Spring Backend App이라고 부른 경우가 많은데, 
여기서 Spring은 플랫폼이고, Backend APp은 어플리케이션에 대한 설명이다. <Br>
결국 언어나 플랫폼에 국한되지 않은 본질은 TODO, 즉 Use Case이다. 


# 3. 모델은 어디까지 세분화 해야 하는가?
그래서 모델은 어디까지 세분화 해야 할까? <Br>
강의에선 Domain Entitiy와 Jpa Entity 를 분리해서 사용했다. <Br>
그러면서 정말 많은 변환 과정이 추가 되었다. <Br>

## 3.1 웹 어뎁터를 위한 모델
현실적으로 최소 분리 단위이다. <br>
웹 어뎁터, 즉 컨트롤러를 위한 모델의 분리는 사실상 현업에서 꼭 필요하다 <br>
구체적으로 말 하면 바로 이해가 가는데, Response와 Request DTO를 만들자는 이야기이다. <Br>
웹 어댑터는 유스케이스의 출력을 HTTP응답으로 매핑 해줘야 하는데, 모델을 그대로 날리면 당연히 보안상 끔찍한 일일 수 밖에 없다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/61eacbaf-df6b-42ce-b955-8b96175ab0e2)

## 3.2 도메인과 영속성 엔티티의 분리
도메인과 DB의 분리는 의견이 많이 갈리는 지점이다. <Br>
둘은 분리하지 않는다면 도메인이 DB에 종속되고 ORM에 강결합 된다. <br>
1. 도메인 모델에 JPA 어노테이션이 붙는 순간, 이 시스템은 RDB 시스템이라고 못이 박혀버린다. <br>
2. 도메인에 Table 이름, Column, JPA 로딩 전략 등이 명시되는데, 부자연스럽다.


분리하는 경우 아래와 같은 장점들이 있다. 

![image](https://github.com/binary-ho/TIL-public/assets/71186266/1a3ad06c-bb11-44a0-a020-9e0cef81b25c)


## 3.3 Input & Output Port 모델 구분

![image](https://github.com/binary-ho/TIL-public/assets/71186266/d21b8099-e467-4a4a-a58e-12751f21b0c3)


큰 시스템에서 이상적으로는 위와 같이 Use Case와 GateWay를 위한 모델이 필요하다.  
순환 참조를 막고, 깔끔하다.

그러나 구성이 너무 과하다!!
작은 프로젝트에서 이정도의 정책은 너무 불편하다.
그래서 원칙과 편의성 사이에서 조율하며 어디까지 분리해 낼지 고민할 필요가 있다.

![image](https://github.com/binary-ho/TIL-public/assets/71186266/31ab9e8d-cb03-4469-935e-80f186176f2e)


이상적으로는 원칙이 중요하지만, 정답이 없는 문제이다.
단, **도메인 모델만큼은 순수하면 됐다**


## Reference
- [Java/Spring 테스트 강의 <김우근>](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8/dashboard)
