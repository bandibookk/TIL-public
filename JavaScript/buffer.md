# Buffer

1. 모든 수를 실수 처리함.
2. string은 작은 따옴표로 나타내라.
3. 문자열은 변경이 불가능하다. 새로운 문자열을 메모리에 생성하고 할당할 뿐. 그냥 새로운 문자열을 가르킬 뿐이다.
4. 문자열은 유사배열이라 인덱스 접근이 가능하다. 이 경우 인덱스로 일부 문자를 변경해도 반영이 되지 않는다. 또한 에러도 뜨지 않는다.
5. 문자열은 더하기 연산도 먹한다. 새로 할당하는 것이지만.
6. **비어있는 문자열**, `null`, `undefined`, 0은 `false`로 간주됨.
7. `undefined`는 선언 이후 값을 할당하지 않은 변수! 실제로 개발자가 `undefined`을 할당해 주는 것은 원래 취지와 혼동될 가능성이 있으므로, 사용하면 안 된다.. 대신 `null`을 써라
8. `null`은 `Null`, `NULL`과는 다르다 소문자 주의.
9. `typeof`연산자로 null 값을 연산하면 null이 아닌 object가 나옵니다. (설계상 오류) **따라서 `null` 타입인지 확인 할 때는 typeof 연산자가 아닌 일치연산자 `===` null을 이용해야한다.**
10. 변수의 중복 선언이 가능. 값을 덮어 쓴다. 위험한듯 하다. 문법적으로는 허용되지만, 사용하지 않는 것이 좋다.
11. 호이스팅(Hoisting)에 대한 이해 필요. **마치 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성.** 모든 선언문은 선언되기 이전에 참조가 가능하다. 단, 선언만 옮겨가는 것이기 때문에, 할당문 이전까지는 값을 참조해도 `undefine`을 반환하게 된다. 실제 코드레벨에서 옮겨간다기 보다는, **변수 객체가 미리 등록되고, undefined로 초기화 되는 것이다.**

### 12. **var 키워드로 선언된 변수의 문제점**
`var` 키워드는 다른 C-family 언어와는 달리 **함수 레벨 스코프**를 가지고 있습니다. (C-family는 보통 블록 레벨 스코프)  ES6 전에는 이 `var`이 유일한 변수 선언 키워드이기 때문에, 많은 문제가 있었고, 이는 명백한 **설계 오류**입니다. 
1. 함수 레벨 스코프
- 전역 변수 남발
- for loop 초기화 식에서 사용한 변수를 외부 또는 전역에서도 참조가 가능함
2. var 키워드 생략 허용 - 의도치 않게 변수가 전역화됨.
3. 중복 선언 허용 - 의도하지 않게 변수값을 변경하는 일이 발생함.
4. 변수 Hoisting - 변수를 선언하기 전에 참조가 가능함

이를 위한 해결방법으로 ES6에서 `let`과 `const`가 도입 되었습니다.

### 블록 레벨 스코프 변수 `let`
1. 블록 레벨 스코프를 따릅니다.
2. 변수를 중복 선언 할 수 없습니다.
3. Hoisting은 비슷합니다. **하지만, let 키워드로 선언된 변수는 선언문 이전에 참조시 참조에러(ReferenceError)가 발생합니다.** let 키워드로 선언된 변수는 **스코프의 시작에서 변수의 선언까지 일시적으로 사각지대에 빠지기 때문입니다.** (Temporal Dead Zone; TDZ) .`var`는 그냥 `undefine`이 떴던 것과는 대조적입니다. <br> <br> 이는 호이스팅 방식의 차이에서 오게 되는데, 호이스팅은 선언 단계 -> 초기화 단계 -> 할당 단계의 세 단계로 나누어집니다. **실행 컨텍스트**의 변수 객체에 변수를 등록하고(선언) -> 이를 위한 공간을 할당하고(초기화) -> 실제로 값을 할당합니다.(할당) <br> `var`은 선언과정과 초기화 과정이 동시에 일어나기 때문에, (`undefine` 으로) 값을 참조해도 오류가 뜨지 않았던 것이고, `let`은 실제 배정문 까지는 초기화를 하지 않기 때문에 참조시 오류가 발생했던 것입니다. 그런데 이런 식이면 호이스팅이 없는 것과는 뭐가 다른걸까요? <br> <br> 
```js
let foo = 1; // 전역 변수
{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2; // 지역 변수
}
```
위와 같은 예제에서 foo는 원래대로라면 블록 밖의 foo를 참조해야 하지만, 이 경우에는 블록 안의 foo를 참조하여 참조에러가 발생됩니다.  <br> **`let`의 호이스팅은 블록의 맨 위로 선언문을 옮긴 것과 같게 이루어진다고 이해하면 될 것 같습니다.**
4. 자유변수?, 클로저
5. 전역 객체와 `let`: `var`로 전역 변수를 만들면 전역 객체의 프로퍼티가 된다. **`let`키워드로 선언된 변수를 전역 변수로 사용하는 경우에는 `let` 전역 변수는 전역 객체의 프로퍼티가 아닙니다.** <br> <br> 
```js
var foo = 123; // 1. var 전역변수
console.log(window.foo); // 123
```
```js
let foo = 123; // 2. let 전역변수
console.log(window.foo); // undefined
```
Browser-side의 전역 객체 `window`와 Server-side 전역 객체 `global` 객체를 이용한 접근입니다. 1번과 같은 접근은 가능한데, 2번과 같은 접근은 불가능합니다. **`let` 전역변수는 보이지 않는 개념적인 블록 내에 존재하게 됩니다.**

### 상수 `const`
`let`과 대부분 동일합니다. **블록 레벨 스코프를 갖습니다.** 꼭 상수만을 위해 쓰는 개념은 아닙니다.
1. 재할당 금지 + 선언과 동시에 할당이 이루어져야함.
2. 상수로 쓸 때는 식별자를 대문자로 
3. 객체로 쓸 때, 참조는 변경하지 못 하지만 프로퍼티는 변경할 수 있다. (보호되지 않음)

### var vs. let vs. const
1. `var` 금지
2. 재할당이 필요한 경우에만 한정해 `let` 사용. 스코프는 최대한 좁게 만듭니다.
3. 재할당이 필요 없는 원시 값과 객체에는 `const` 키워드 사용. `const`가 안전하다.
일단 선언 시점에는 재할당이 필요할지 잘 모르기 때문에 일단 `const`로 선언한 다음 재할당이 필요하면 그 때 바꿔라.


# 실행 컨텍스트

[실행 컨텍스트](https://poiemaweb.com/js-execution-context)
물리적으로는 객체의 형태를 가진다. 그리고 3가지 프로퍼티를 소유한다. 
1. Variable object: vars, function declarations, parameter + arguments ... 
2. Scope chain: Variable object + all parent scopes
3. thisValue: Context object
