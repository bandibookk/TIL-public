# 도메인 모델 단위 CQRS
이제까지 나는 CQRS를 조금 안다고 생각했다. <br>
그거 그냥 Command 메서드와 Query 메서드 분리하면 되는거 아닌가? <br>
어떤 상태를 변화시키면 값을 반환하지 않게 해주면 되네, 상태를 조회하는 경우엔 상태 값을 변화시키지 않으면 되네 <br>
하며 Command Query Responsibility Segregation - CQRS를 잘 안다고 생각했다. <br> 
물론 이는 사실이 아니였다. <br>
생각보다 쉽네! 선배님이 CQRS 어렵댔는데, 테스트 하기가 어려워서 그런가? 했다. <br>
CQRS는 왜 중요할까? 나는 멀티 스레드 환경에서 일관성과 관련된 문제라고 알고 있었다. <br>
이제 보니 중요한 이유도 잘못 알고 있었다. <br> 
나는 굉장히 좁은 시야로 CQRS를 바라보고 있었고, 중요한 이유조차 몰랐다. <Br>


## 1. CQRS
CQRS가 필요한 이유는 뭘까? <br>
CQRS는 도메인이 복잡할 때 그 진가를 발휘한다. <br>
보통 값의 조회는 여러 애그리거트를 참조하면서 진행되는 경우가 많다! <br>
주문정보만 보고 회원 정보를 가져오려면, 주문 정보에 있는 회원 정보를 가져다가 회원 정보를 불러와야 한다. <br>
이것보다 더욱 복잡한 상황이 있다고 해보자. <br>
이를 JPA로 구현했을 때 어떤 불편한 점이 있을까? <br> <br>

일단 즉시 로딩이 불가능하다. 애초에 하나의 정보 안에 있는 식별자를 이용해 다른 객체를 또 구해오고, 거기서 정보를 빼는 식으로 일이 흘러간다. <br>
때문에 즉시 로딩을 하기엔 식별자를 이용해 구해오는 쪽의 객체를 가져오기가 어렵다. <br>
그러니까 일단 한번의 SELECT로 필요한 데이터를 불러올 수가 없다. <br>
그럼 그냥 다 가져와서 직접 찹조하는건 어떨까? <br>
어차피 이렇게 구현해도 조회 화면의 특성에 따라 로딩 처리가 다르다. <br>
또 DB가 제공하는 기능을 활용하려면 JPA의 네이티브 쿼리가 필요하다. <br>
혹시 그냥 JPA가 별로라는 말을 하고 싶은건 아닐까? <br>
아니다. 위에서 들은 예시들의 공통점을 찾아보자. <br>
이는 **조회 연산이라는 것이다.** <br>
**무적의 객체지향 기법의 하나로 보이는 ORM은 상태를 변화시키는데는 유용하지만, <br> 여러 애그리거트를 참고해 조회하는 상황에서는 고려할 것도 많고 굉장히 복잡하다.** <br>


## 2. 도메인 모델 관점의 CQRS
이제 내가 알고 있던 메서드 단위에서 더 큰 도메인 모델 관점의 CQRS를 알아보자. <br>

### 서로 다른 범위
이 뿐만이 아니다. **도메인이 복잡해질 수록, 상태 변경 로직의 범위랑 상태를 조회하는 범위가 꼭 같지 않을 때도 있다.** <br>
이런 경우, 단일 모델로 만드는 경우 한 쪽은 무조건 불필요하게 복잡해지는 것이다. <br>
이런 복잡도 문제 또한 CQRS로 쉽게 해결할 수 있다.



### 서로 다른 구현
앞서 언급했던 것 처럼, ORM은 상태 변경에 용이하지만, 조회에는 효율적이지 않을 때가 있다. <br>
**CQRS를 사용하면 각 모델에 맞는 기술로 구현할 수 있게 된다.** <br>
명령 모델은 객체 지향 기반이 유용하기 떄문에 JPA로 설계하고, **조회 모델은 SQL로 조회할 때 좋기 때문에 마이바티스를 사용해도 되고, 가벼운 NoSQL을 사용해도 된다.** <br>
CQRS를 통해 도메인 모델에 따라 비슷한 내용들을 갖고 있어도, 필요에 따라 서로 다른 구현이 가능해진다! <br>
커멘드는 복잡하니까 컨트롤러, 응용 서비스, 도메인, 인프라를 통해 값을 변경하는데, <br>
조회는 사실 간단하니까 컨트롤러 -> DTO -> 인프라로 바로 서비스를 거치지 않고 지름길로 갈 수도 있는것 아닌가? <Br> <br>

설계 또한 다를 수 있다. <Br>
커멘드 설계는 복잡한 객체들의 관계를 한 눈에 볼 수 있게 나타내야 하고, 조회를 위한 자료형만 잘 만들면 복잡한 로직이 필요없다. <br>
이전까지는 서로 참고 살았는데, 그럴 필요 있나? 따로 살면 된다. <br> <br>

### 같은 자료를 가리키는 두 저장소
만약 같은 자료를 가리키고 있다면, CAP을 고려하면 되겠다. <br>
만약 자료의 동시성이 너무나도 중요한 상황이라고 하자. <br>
그러면 그냥 커멘드 DB에 커멘드로 인한 변경이 일어날 때, 한 트랜잭션으로 엮어 조회 DB까지 변경 시켜주면 되는것 아닌가? <br>
이벤트나 메시지 큐로 말이다. 물론 더 느려질 것이다. <Br>
반대로 좋아요나 댓글 등 SNS는 동시성의 중요성이 좀 더 낮다 누가 언제 댓글을 달았느냐, 하트를 눌렀느냐가 엄청나게 중요하지는 않다. <br>
따라서 그냥 설렁 설렁 시간이 될 때, 혹은 주기적으로 동기화만 시켜주면 되는 것이다.

### 조회가 더 많을 수 밖에 없는 상용 프로그램
상용 프로그램은 대부분 조회가 커멘드 보다 압도적으로 많다. <br>
주문이 더 많은 쇼핑몰이나 배달앱이 있는가? 글을 읽는것 보다 쓰고 전송하는 일이 더 많은 SNS가 있는가? <Br> 
절대 아니다, CQRS를 통해 DB 뿐만 아니라 서버까지 분리할 수 있다면, 서버 설정이나 서버 자원들을 서버가 견뎌내는 부하에 맞게 설정해 줘도 될 것이다. <Br>
이렇게 해주면 더 효율적인 운영이 가능하다. <br>

캐싱 할때도 효율이 좋다. <Br>
아예 도메인 객체 그 자체가 아닌 **보여줘야 할 형태로 캐싱을 하면 된다.** <br>
조회를 위한 객체를 보관하고 있으면 조회 속도가 더 빨라지고, 객체를 다듬는데 들이는 자원도 아낄 수 있다. <br>

## 3. CQRS의 장단점
이제까지 CQRS의 장점만을 알아봤다. <br>
명령 모델을 구성할 때 도메인 자체에만 집중할 수 있게 되었고, <br>
복잡한 도메인에서 복잡한 상태 변경 모델과 조회 모델을 나눔으로써, 구현도 훨씬 쉬워지고, 복잡도가 낮아진다. <br>
조회 성능도 빨라지고, 더 나은 캐싱이 가능하며, 조회에 특화된 쿼리들을 날릴 수가 있으며, 조회량에 따른 조회 전용 저장소를 구축하여 큰 부하에 대비할 수 있다. <br>
그럼에도 조회 전용 모델이 있기 때문에 커멘드 쪽에 아무런 영향을 주지 않을 수 있다.

### CQRS도 당연히 단점이 있다.
칭찬 감옥에서 꺼내주겠다. <br>
1. 코드가 훨씬 복잡해지고, 구현할 양이 많아진다. <br> 오히려 나누는 것이 손해인 경우도 충분히 있다. <br> **도메인이 충분히 크거나 복잡할 때나, 대규모 트래픽이 발생한느 경우에만 사용하라.** <br> 오히려 유지 보수에도 좋아진다.
2. 더 많은 구현 기술을 요한다. <br> 위에서 보았다 싶이 다양한 기술들이나 메시징 시스템과 같은 새로운 기술들이 요구된다.


## Reference
- 도메인 주도 개발 시작하기 <최범균 저>
