# 3.4 ID를 이용한 애그리거트 참조
## 1. 필드를 통한 애그리거트 참조
애그리거트는 내부적으로 객체들을 꽁꽁 숨겨둔 채, <br>
루트 엔티티를 앞세워 외부와 협력한다. <Br>
다른 애그리거트의 참조를 필드로 두게 된다면, 다른 애그리거트를 편하게 참조할 수 있다. <br>
아래는 '주문자'가 '회원'을 참조하는 형태이다. 

```java
public class Orderer {

  private Member member;

  ...

}
```
JPA에서도 `@ManyToMany`나 `@OneToOne`과 같은 다양한 애노테이션들로, 관련있는 객체들을 손쉽게 참조하는 것을 돕는다. <Br>
분명 편리하지만, 다음 문제들을 일으키는 씨앗이 된다. <Br>


1. **너무 편해서 잘못된 탐색을 저지른다.** (유혹에 취약)
2. **성능에 대한 고민을 수반한다.**
3. **확장이 어렵다.**

이런 문제점들을 인지해보자.
### 1.1 너무 편해서 잘못된 탐색을 저지른다
너무 편하다는게 뭐가 문제일까? 어떤 유혹에 취약하다는 것일까? <Br>


**한 애그리거트에서 다른 애그리거트에 접근할 수 있다면, 다른 애그리거트의 상태를 너무 쉽게 변경할 수 있게 된다.** <Br>

**한 애그리거트가 트랜잭션을 걸어 관리하는 범위는 자기 자신으로 한정해야 한다.** <br>
다른 애그리거트를 관리한다면, **애그리거트간 의존도를 높히고, 응집도를 낮추게 되어 버리는데, 이러면 굳이 애그리거트로 나눈 이유가 없지 않는가?** <Br>
결론적으로, **애그리거트는 변경에 유연하지 못하게 된다.** 즉, 객체지향의 패러다임의 기본 이념에 반하게 된다. 

### 1.2 성능에 대한 고민을 수반한다
애그리거트의 기능에 따라, 참조 객체를 지연 로딩할지 즉시 로딩할지 결정해야 한다. <br>
단순하게 관련 있는 객체들의 데이터를 한방에 보여줘야 한다면 즉시 로딩을 선택해야 하지만, <br>
상태를 변경시켜야 한다면 필요한 객체만 로딩하기 위해 지연 로딩을 선택해야 한다. <br>

### 1.3 확장이 어렵다. 

예를 들어 우리 사이트의 손님이 너무나도 많아졌다고 생각해보자. <br>
그러다 보니, 하위 도메인별로 시스템을 분리하게 되었다고 생각해보자. <br>
그런데 만약 하위 도메인마다 다른 DB를 쓰고 싶다면? 어떤 도메인은 NoSQL이 유리하고, 어떤 도메인은 RDBMS가 유리한 상황에서, JPA와 같은 단일 기술을 사용할 수 없게 될 수 있다. <Br>

## 2. ID를 통한 애그리거트 참조
이런 세가지 문제를 완화할 수 있는 달콤한 방법이 있다. <Br>
**필드가 아닌 식별자를 통해 애그리거트를 참조하는 것이다!** <Br>
마치 외래키를 참조하듯, ID를 통해 다른 애그리거트를 참조하는 것은 참으로 훌륭하다. <br>

### ID 참조의 장점들
1. **모든 객체가 참조로 연결되지 않게 된다.** <Br> 덕분에 경계가 더욱 명확해져서, 복잡도가 낮아진다.
2. **의존성이 제거된다.** -> 응집도가 높아진다.
3. **구현 난이도가 낮아진다.** <br> 이제 지연 로딩 즉시 로딩을 고민할 필요가 없다. <Br> 참조하는 애그리거트가 필요할 때면, Application Service를 통해 로딩하면 그만이다. <Br> 이렇게 되면, **애그리거트 수준에서 지연 로딩을 하는 것이나 마찬가지다.**
4. **애그리거트 별로 다른 세부 구현이 가능해진다** <Br> 앞서 말했던 도메인별 다른 DB 구현이 용이해진다.
### 5. 수정 불가능하다!! :star:
-> 직접 참조하지 않기 때문에 상태를 변경할 수 없다.


## 3. ID 참조와 N+1 문제
필드 참조 방식은 `N+1 문제`를 야기한다. <br>
예를 들어 한 주문에서 주문한 상품들을 보려고 생각해보자. <BR>
**필드로 참조한다면 JOIN을 통해 가져오지 못하고, 상품을 순회하면서 계속해서 쿼리를 날리게 될 것이다.** <br>
이런 문제를 N + 1 문제라고 부른다. <Br>
N+1 문제는 조회 대상은 N개인데, **N번의 쿼리로 끝나지 않고, 관련된 정보를 가져오기 위한 N번의 쿼리가 추가로 발생하는 성능 악화 이슈이다.** <br>

다양한 해결 방법이 있지만, **JOIN을 통해 해결할 수 있다.** <Br>
JOIN을 구현하는 가장 쉬운 방식은 객체 참조 방식을 이용해 즉시 로딩을 하는 것이다. <Br>
이 방식은 N+1을 해결하는 방법으로 잘 알려져 있지만, 애그리거트 간 참조를 어렵게 ID 참조로 바꿨는데, 다시 객체 참조로 바꿀 필요가 있겠는가? <br>


이제 ID 참조 방식에서의 JOIN을 살펴보자. <br>
**조회 전용 쿼리를 사용하면 된다.** <br>
그냥 조회 메서드에서 **관련된 테이블들을 묶어서 필요한 정보만을 조회하는 JOIN 쿼리를 직접 짜주면 된다.** <Br>
그러면 단 한번에 가져올 수 있고, 로딩 전략을 고민할 필요도 없다! <br>

물론 애그리거트 별로 다른 DB를 통해 구현하기로 마음 먹었다면, 어쩔 수 없이 **조회 전용 저장소를 이용하던가, 캐싱해라** <Br>
만약 대량의 트래픽을 다룬다면, 조회 전용 저장소와 캐싱을 적극적으로 고려해라. <br>

(조회 전용 쿼리는 5장에서 다룬다.)


## 결론!
애그리거트간에 참조가 필요하다면, ID를 참조해라. <br>
그냥 필드를 두는 식의 객체 잠조 형식은 여러 문제들의 씨앗이 된다. <Br>

## Reference
- 도메인 주도 개발 시작하기 <최범균 저>

