# 5. Classless Addressing

Classless Addressing은 기존의 Classful addressing에서 클래스만 사라진 것입니다. 원래는 정해진 크기의 Class A, B, C의 크기대로만 분할이 가능하고, 필요하면 subnetting을 하는 방식으로 사용되었습니다. **그러나 이러한 방식은 꼭 필요한 만큼만 할당 받는 것이 불가능해 비효율적이였습니다. (fixed length 문제)** 예를 들어, 치킨 한 조각이면 배가 부른 사람인데, 무조건 1마리 부터 주문이 가능한다거나.. 물이 2.5L만 필요한 사람에게 무조건 1L의 물만 판매한다면 쓸데없는 추가 구매가 이루어지겠죠?
<br/>


#### 그렇게 도입된 것이 바로 Classless Inter-Domain Routing 즉, CIDR입니다.     
<br/>

# 5.1 CIDR
CIDR addressing block은 아래와 같은 특징들을 가지고 있습니다.

1. Non-overlapping
2. **Addresses in the same block share the same prefix**
3. 길이가 2의 제곱으로 제한 되어있다.
4. **시작 주소와 prefix의 length로 나타낸다.**

**CIDR 주소 블럭은 같은 prefix를 가지고, 서로 non overlapping입니다.** 2번의 이유 때문에 mask를 만들 수 없어 supernetting이 안 됩니다.    
단점으로는 **어디까지가 net id고, 어디 부터가 host id인지 알 수 없다**는 점이 있습니다. **이는 네트워크 마스크를 파악하기 힘들다는 문제로 이어집니다.** 이를 해결하려면 위해 마치 subnetting 에서 그러했던 것 처럼 **prefix length를 알려주는 무언가가 필요합니다. 이렇게 도입된 것이 CIDR Notation 입니다.**
<br/>

# 5.2 CIDR Notation
![cidr notation](https://user-images.githubusercontent.com/71186266/168458067-615efe85-7c8e-4396-93ac-6344647a95b9.PNG)

위의 그림은 CIDR 표기법을 나타낸 것입니다. 
맨 뒤의 `/n` 부분을 제외하고는, 클래스풀 어드레싱과 똑같이 보면 됩니다.    
추가된 `/n` 부분은 **Prefix Length를 나타냅니다. n만큼의 길이의 mask를 가지고 있다고, 친절하게 알려주는 표기법입니다.** 해당 블럭이 가지고 있는 주소의 갯수는 간단하게 2의 32-n 제곱으로 구할 수 있겠죠?

## 빠르게 마스크를 파악하는 법!
별건 아니고 시험을 대비한 빠른 풀이입니다.
1. **n의 길이를 확인해서 변하지 않는 byte 부분을 빠르게 파악합니다.** 
1 byte는 8bit이므로, n이 8~15이면 첫 byte는 숫자 그대로가 마스크이고, 16~23이면 앞에서 두 byte는 숫자 그대로가 mask입니다. 더 짧게 표현하자면 **n/8의 몫의 갯수만큼의 byte는 주소 그대로 mask가 됩니다.** <br/>        
    
2. **변하지 않는 부분을 완성합니다.**    
n/8의 나머지 만큼의 bit이 변하지 않는 byte 뒤로 또 마스크가 됩니다. **그러니까 처음 변하는 byte 부분을 8자리 2진수로 나타낸 다음,  앞에서 부터 n%8 만큼을 마스크로 잡아줍니다.** <br/>


3. **이후 나머지 뒷 부분에 0을 채워주면 시작 주소를 찾게 됩니다.**
반대로 1을 채워주면 마지막 주소가 되겠지요?

예를 들어 설명하겠습니다.
주소 140.120.84.24/20이 주어졌을 때의 시작 주소를 찾겠습니다.
1. 20 bit가 마스크로 쓰이기 때문에 20/8 의 몫인 16 bit = 2 byte가 변하지 않게 되므로, 일단 140.120. 까지 마스크입니다.
2. 이후 4 bit 만큼이 더 mask이기 때문에 3번째 byte를 2진수화 시켜주면    
84 = <U>0101</U>0100(2)입니다. 여기서 밑줄 친 앞에서 4 bit만큼이 mask가 되겠습니다. 그러니까 **<U>0101</U>0000(2) = 80이 3번째 칸의 mask가 됩니다.**
3. **mask, 시작 주소는 140.120.80.0이 되겠습니다!**
4. 번외로 마지막 주소는 **<U>0101</U>1111(2) = 95**가 3번째 byte인 **140.120.95.255가 되겠습니다.**


# 5.3 Subnetting in classless addressing
클래스리스 어드레싱에서는 서브네팅이 더 쉽습니다. 그냥 서브네팅을 진행해준 다음 표기법에서 n만 새로운 prefix의 길이로 바꿔주면 됩니다. <br/>
**직접 나눠주는 방식은 좀 중요합니다. (시험에 나옴)**

# Subnetting 하는 법
**한 가지 원칙에 충실해야 합니다! 나눠주는 갯수를 주소에 나눴을 때, 나머지가 0이 나와야합니다! 해당 조건을 적용하며, 가장 조건이 까다로운 순서대로 나눕니다!**

예시 문제: 시작 주소가 **14.24.74.0/24**인 블록이 있다. 해당 블록은 자연히 2의 8제곱인 256개의 주소를 갖습니다. 아래 11개의 subnet을 요구하오니, 주소를 나누어 주십시오.

<조건>
a. 2 subnet, each with 64 addresses.
b. 2 subnet, each with 32 addresses.
c. 3 subnet, each with 16 addresses.
d. 4 subnet, each with 4 addresses.

해당 문제는 a ~ d순으로 조건이 까다롭기 때문에, 해당 순서로 주소를 나눠주겠습니다.
1. a는 0\~63/26, 64\~127/26 -> 맨 뒷 바이트만 나타냄. 시작 주소를 64로 나눈 나머지가 0이고, 64개씩 두 개로 잘 나누어짐. 마스크는 당연히 2 bit만큼 늘어난 26이 된다. 첫 번째 서브넷은 <U>00</U>000000 \~ <U>00</U>111111 까지 차지했고, 두 번째 서브넷은 <U>01</U>000000 \~ <U>01</U>111111 까지 차지했기 떄문이다. <br/>

2. b는 128\~159/27, 160\~191/27 -> 맨 뒷 바이트만 나타냄. 시작 주소를 32로 나눈 나머지가 0이고, 32개씩 두 개로 잘 나누어짐. 마스크는 3 bit만큼 늘어난 27이 된다. 첫 번째 서브넷은 <U>100</U>00000 \~ <U>100</U>11111 까지 차지했고, 두 번째 서브넷은 <U>101</U>00000 \~ <U>101</U>11111 까지 차지했기 떄문이다. <br/>

3. c는 192\~207/28, 208\~223/28, 224\~239/28 로 나누어진다. -> 맨 뒷 바이트만 나타냄. 시작 주소를 16로 나눈 나머지가 전부 0이고, 16개씩 세 개로 잘 나누어짐. 마스크는 4 bit만큼 늘어난 28이 된다. 첫 번째 서브넷은 <U>1100</U>0000 \~ <U>1100</U>1111 까지 차지했고, 두 번째 서브넷은 <U>1101</U>0000 \~ <U>1101</U>1111, 그리고 세 번째는 <U>1110</U>0000 \~ <U>1110</U>1111 까지 차지했기 떄문이다. <br/>

4. d도 똑같이 진행한다 14.24.74.240/30, 14.24.74.244/30, 14.24.74.248/30, 14.24.74.252/30 4개를 부여 받는다.

이런 문제는 무조건 중간 고사에 나올 수 있고, 과제와 퀴즈 문제를 다시 풀어보자.


# 5.4 Internet address allocation
ISP가 allocation 해줍니다. 해당 내용도 시험에 반드시 나오기 때문에 문제를 여러번 풀어볼 필요가 있겠습니다.

ex) An ISP is granted a block of addresses starting with 190.100.0.0/16 (65,536 addresses). The ISP needs to distribute these addresses to three groups of customers as follows:

a. The first group has 64 customers; each needs 256 addresses.     
b. The second group has 128 customers; each needs 128 addresses.     
c. The third group has 128 customers; each needs 64 addresses.

**이번에도 제약 조건이 많은 블록 부터 처리합니다 a, b, c 순이 되겠습니다!**

a: 256개의 주소니까 깔끔하게 맨 뒷 byte를 주면 그만이므로, 시작 주소에서
   일단, 190.100.0.0/24 \~ 190.100.0.255/24이 한 고객에게 주어지게 됩니다.
   24인 이유는 기존 3번째 byte가 고정되기 때문입니다. 이렇게 64명 이니까, 시작 주소만 모아 두면.. 190.100.0.0/24 \~ 190.100.63.0/24가 되겠습니다. <br/>
   
b: 다음은 128개를 줘야 하니까 3번쨰 byte하나 당 2 명한테 줄 수 있겠습니다.
    그런 첫 2개의 시작 주소는.. 190.100.64.0/25 \~ 190.100.64.127/25, 190.100.64.128/25 \~ 190.100.64.255/25가 되겠습니다. 이후는 똑같이 주어지고, 시작 주소만 모아두면..  190.100.64.0/25 \~ 190.100.127.128/25이 되겠습니다. <br/>
    
c: 마지막은 똑같이 128개인데, 이번엔 64개의 주소를 나눠줍니다. 즉, 3번째 byte   하나 당 4명에게 줄 수가 있겠네요 그래서 또 첫 1 byte 4명의 주소를 적으면..
190.100.128.0/26 \~ 190.100.128.63/26, 190.100.128.64/26 \~ 190.100.128.127/26, 190.100.128.128/26 \~ 190.100.128.191/26, 190.100.128.192/26 \~ 190.100.128.255/26가 되겠고, 마지막 주소는 190.100.159.192/26이 되겠습니다.  <br/>

해당 문제도 100% 출제가 되니 여러번 풀어볼 필요가 있겠습니다. 그림으로 나타낸 것도 첨부 할테니, 모양을 맞춰 작성하는 법을 익힙시다. **표기 할 때는 가장 첫 주소 부터, 가장 마지막 끝 번호를 적는 것 같습니다!** 시작 주소만 모아 놓은 형태로 적지 말라는 것 입니다. <br/><br/>

![isp](https://user-images.githubusercontent.com/71186266/168461574-dcf62850-edc8-492d-a076-1de8ed0a5bad.PNG)



# Special Addresses and NAT
특수 주소들에 대한 설명입니다. 5.5 Special Addresses와 5.6 NAT에 대해서는 다른 문서에서 설명하겠습니다. 

**[Specila Addresses, NAT 문서 바로가기](https://github.com/binary-ho/TIL-public/blob/main/3%ED%95%99%EB%85%84%201%ED%95%99%EA%B8%B0/Computer%20Network/Special%20Addresses%20and%20NAT.md)**

### 참조
TCP/IP 프로토콜 <(주)한터에듀>
